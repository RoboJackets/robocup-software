--- a/firmware/robot/cpu/tools/find_tty.py
+++ b/firmware/robot/cpu/tools/find_tty.py
@@ -1,25 +1,28 @@
 import os
 
+
 def find(vendor, product):
-	# Try to find the device with sysfs.
-	# This is Linux-specific.
-	usb_path = '/sys/bus/usb/devices'
-	usbs = os.listdir(usb_path)
-	devices = []
-	for u in usbs:
-		try:
-			def contents(filename):
-				f = file(filename)
-				x = f.read()
-				f.close()
-				return x
-			
-			v = int(contents('%s/%s/idVendor' % (usb_path, u)), 16)
-			p = int(contents('%s/%s/idProduct' % (usb_path, u)), 16)
-			if v == vendor and p == product:
-				t = '/dev/' + os.listdir('%s/%s/%s:1.0/tty' % (usb_path, u, u))[0]
-				if os.path.exists(t):
-					devices.append(t)
-		except:
-			pass
-	return devices
+    # Try to find the device with sysfs.
+    # This is Linux-specific.
+    usb_path = '/sys/bus/usb/devices'
+    usbs = os.listdir(usb_path)
+    devices = []
+    for u in usbs:
+        try:
+
+            def contents(filename):
+                f = file(filename)
+                x = f.read()
+                f.close()
+                return x
+
+            v = int(contents('%s/%s/idVendor' % (usb_path, u)), 16)
+            p = int(contents('%s/%s/idProduct' % (usb_path, u)), 16)
+            if v == vendor and p == product:
+                t = '/dev/' + os.listdir('%s/%s/%s:1.0/tty' %
+                                         (usb_path, u, u))[0]
+                if os.path.exists(t):
+                    devices.append(t)
+        except:
+            pass
+    return devices

--- a/firmware/robot/signal_captures/plot-kicker/plot-kicker.py
+++ b/firmware/robot/signal_captures/plot-kicker/plot-kicker.py
@@ -52,6 +52,7 @@
 # Index of maximum current
 imax_pos = list(i_rlc).index(imax)
 
+
 # Find the parameters of the damped oscillation with least squares estimation.
 # This depends only on the measured current, so it will not be affected by the unknown
 # resistances in the capacitor and inductor.
@@ -60,7 +61,9 @@
     fit_i = exp(-a * tt) * sin(wd * tt) * s
     return i_rlc - fit_i
 
-((wd, a, iscale), success) = scipy.optimize.leastsq(residual_i, [100, 100, 1000])
+
+((wd, a, iscale), success) = scipy.optimize.leastsq(residual_i, [100, 100, 1000
+                                                                 ])
 print wd, a, iscale, success
 print residual_i
 assert success
@@ -76,6 +79,7 @@
 
 fit_imax_time = fit_imax_pos / sample_rate
 
+
 # Best-fit current evaluated at an arbitrary time.
 # Use this for integration.
 def eval_fit_i(t):
@@ -95,8 +99,10 @@
 # Find the total charge that has left the capacitor at each time.
 # Use the best-fit current for more accurate integration.
 charge = array([scipy.integrate.quad(eval_fit_i, 0, t)[0] for t in tt])
+
 #charge = array([scipy.integrate.trapz(fit_i[:n], dx=1/sample_rate) for n in range(num_samples)])
 
+
 def residual_c(X):
     #(vmax, c, rc) = X
     rc = X
@@ -152,7 +158,7 @@
 fit_vl = fit_vc - fit_i * r
 
 ec_max = c * vmax**2 / 2
-el_max = scipy.integrate.trapz(fit_pl[:fit_imax_pos], dx=1/sample_rate)
+el_max = scipy.integrate.trapz(fit_pl[:fit_imax_pos], dx=1 / sample_rate)
 
 # Energy left in the capacitor if we cut off current at Imax
 cutoff_final_energy = c * fit_vc[fit_imax_pos]**2 / 2
@@ -169,23 +175,30 @@
 print 'Alpha (zeta*w0):        %7.3f' % a
 print 'Damping ratio (zeta):   %7.3f' % z
 print 'Current curve scale:   %8.3f' % iscale
-print 'Capacitance (each):    %6.1f uF' % (c * 1e6/2)
+print 'Capacitance (each):    %6.1f uF' % (c * 1e6 / 2)
 print 'Inductance:             %5.1f uH' % (L * 1e6)
 print 'Sense resistor:          %2.0f milliohms' % (rsense * 1e3)
 print 'Capacitor resistance:    %5.2f milliohms' % (rc * 1e3)
 print 'Inductor resistance:    %6.2f milliohms' % (rl * 1e3)
 print 'Total Resistance:       %6.2f milliohms' % (r * 1e3)
 print 'Initial energy:         %6.2f J' % (0.5 * c * vmax**2)
-print 'Total energy delivered: %6.2f J' % scipy.integrate.trapz(pc, dx=1/sample_rate)
-print 'Total loss:             %6.2f J' % scipy.integrate.trapz(fit_pr, dx=1/sample_rate)
-print 'Final inductor energy:  %6.2f J' % scipy.integrate.trapz(fit_pl, dx=1/sample_rate)
+print 'Total energy delivered: %6.2f J' % scipy.integrate.trapz(
+    pc,
+    dx=1 / sample_rate)
+print 'Total loss:             %6.2f J' % scipy.integrate.trapz(
+    fit_pr,
+    dx=1 / sample_rate)
+print 'Final inductor energy:  %6.2f J' % scipy.integrate.trapz(
+    fit_pl,
+    dx=1 / sample_rate)
 print 'Max inductor energy:    %6.2f J' % el_max
 
 # Efficiency if we use all energy in the inductor
 print 'Max efficiency:          %4.1f%%' % (el_max / ec_max * 100)
 
 # Efficiency if we cut off current at Imax, so the capacitor does not fully discharge
-print 'Cutoff efficiency:       %4.1f%%' % (el_max / (ec_max - cutoff_final_energy) * 100)
+print 'Cutoff efficiency:       %4.1f%%' % (el_max / (
+    ec_max - cutoff_final_energy) * 100)
 
 fig = figure()
 fig.canvas.set_window_title(sys.argv[1])
@@ -202,8 +215,8 @@
 ylabel('Voltage (V)')
 legend(['Measured', 'Best fit'])
 subplot(313)
-plot(tt, fit_pc/1e3, 'g', tt, fit_pl/1e3, 'r', tt, fit_pr/1e3, 'b')
-vlines(fit_imax_time, 0, fit_pr[fit_imax_pos]/1e3)
+plot(tt, fit_pc / 1e3, 'g', tt, fit_pl / 1e3, 'r', tt, fit_pr / 1e3, 'b')
+vlines(fit_imax_time, 0, fit_pr[fit_imax_pos] / 1e3)
 grid(True)
 legend(['Out of capacitor', 'Into inductor', 'Lost in resistance'])
 ylabel('Power (kW)')

--- a/soccer/gameplay/evaluation/double_touch.py
+++ b/soccer/gameplay/evaluation/double_touch.py
@@ -16,14 +16,12 @@
 #      where the infringement occurred (see Law 13)"
 #
 class DoubleTouchTracker(fsm.StateMachine):
-
     class State(enum.Enum):
         start = 1
         restart_play_began = 2
-        kicking = 3             # we go to this state once we have determined which of our bots is the kicker
-        kicker_forbidden = 4    # the kicker has kicked or fumbled and is no longer allowed to touch it
-        other_robot_touched = 5 # after another bot has touched the ball, the double touch rule is no longer applicable
-
+        kicking = 3  # we go to this state once we have determined which of our bots is the kicker
+        kicker_forbidden = 4  # the kicker has kicked or fumbled and is no longer allowed to touch it
+        other_robot_touched = 5  # after another bot has touched the ball, the double touch rule is no longer applicable
 
     def __init__(self):
         super().__init__(start_state=DoubleTouchTracker.State.start)
@@ -32,60 +30,57 @@
             self.add_state(state)
 
         # FIXME: is it only restart plays?
-        self.add_transition(DoubleTouchTracker.State.start,
+        self.add_transition(
+            DoubleTouchTracker.State.start,
             DoubleTouchTracker.State.restart_play_began,
-            lambda: (main.root_play().play != None
-                and main.root_play().play.__class__.is_restart()
-                and main.game_state().is_our_restart()),
+            lambda: (main.root_play().play != None and main.root_play().play.__class__.is_restart() and main.game_state().is_our_restart()),
             'we start running an offensive restart play')
 
-        self.add_transition(DoubleTouchTracker.State.restart_play_began,
+        self.add_transition(
+            DoubleTouchTracker.State.restart_play_began,
             DoubleTouchTracker.State.kicking,
             lambda: any(bot.has_ball() for bot in main.our_robots()),
             'one of our bots has the ball')
 
         self.add_transition(DoubleTouchTracker.State.kicking,
-            DoubleTouchTracker.State.kicker_forbidden,
-            lambda: not self.kicker_has_possession(),
-            'kicker kicks or fumbles ball')
+                            DoubleTouchTracker.State.kicker_forbidden,
+                            lambda: not self.kicker_has_possession(),
+                            'kicker kicks or fumbles ball')
 
         self.add_transition(DoubleTouchTracker.State.kicker_forbidden,
-            DoubleTouchTracker.State.other_robot_touched,
-            lambda: self.other_robot_touching_ball(),
-            'another robot has touched the ball')
-
+                            DoubleTouchTracker.State.other_robot_touched,
+                            lambda: self.other_robot_touching_ball(),
+                            'another robot has touched the ball')
 
     def kicker_has_possession(self):
         if self.kicker_shell_id != None:
             for bot in main.our_robots():
                 if bot.shell_id() == self.kicker_shell_id:
                     # we use two methods here because the ball-sensor output is often jittery
-                    return bot.has_ball() or evaluation.ball.robot_has_ball(bot)
+                    return bot.has_ball() or evaluation.ball.robot_has_ball(
+                        bot)
         return False
 
-
     ## The shell id of the robot that isn't allowed to touch the ball
     # returns None if everyone is allowed to touch
     def forbidden_ball_toucher(self):
         return self.kicker_shell_id if self.state == DoubleTouchTracker.State.kicker_forbidden else None
 
-
     # returns True if a bot other than the kicker is touching the ball
     def other_robot_touching_ball(self):
         max_radius = constants.Robot.Radius + constants.Ball.Radius + 0.03
         for bot in list(main.our_robots()) + list(main.their_robots()):
-            if bot.visible and (not bot.is_ours() or not bot.shell_id() == self.kicker_shell_id):
+            if bot.visible and (not bot.is_ours() or
+                                not bot.shell_id() == self.kicker_shell_id):
                 if bot.pos.near_point(main.ball().pos, max_radius):
                     return True
 
         return False
 
-
     # reset
     def on_enter_start(self):
         self.kicker_shell_id = None
 
-
     # when we've identified that one of our bots has the ball,
     # record it's shell id
     def on_exit_restart_play_began(self):
@@ -94,15 +89,14 @@
                 self.kicker_shell_id = bot.shell_id()
                 return
 
-
     def on_enter_kicker_forbidden(self):
-        logging.info("Due to DoubleTouch rule, robot '" + str(self.kicker_shell_id) + "' can't touch the ball")
-
-
+        logging.info("Due to DoubleTouch rule, robot '" + str(
+            self.kicker_shell_id) + "' can't touch the ball")
 
 # global double touch tracker
 _tracker = DoubleTouchTracker()
 
+
 def tracker():
     global _tracker
     return _tracker

--- a/firmware/robot/cpu/tools/motor_model.py
+++ b/firmware/robot/cpu/tools/motor_model.py
@@ -5,71 +5,74 @@
 # g*cm^2 -> kg*m^2
 # g*cm^2/1000/10000 = kg*m^2
 
+
 class MotorModel:
-	def __init__(self):
-		self.vbatt = 12.483		# Battery voltage
-		self.kr = 379			# Speed constant, rpm/V
-		self.kt = .0255			# Torque constant, Nm/A
-		self.sample_time = 0.005	# Time per step, s
-		self.oversample = 50	# Fine steps per sample time
-		self.speed = 0			# Motor speed, rad/s
-		self.rbatt = 0.39		# Battery internal resistance, ohms
-		self.rmot = 1.2			# Winding resistance, phase-to-phase, ohms
-		self.angle = 0			# Cumulative rotor angle, rad
-		self.load = 120/1e7			# Load inertia, kg*m^2
-		self.kosc = 2.7/1e7		# Oscillation amplitude coefficient, Nm/(m/s)^2
-		self.cmd = 0			# FPGA command, 0..127
-		self.ticks_per_rev = 1440	# Encoder ticks per motor revolution
-		self.friction = 0		# Constant (kinetic) friction, Nm
-		self.enc_delta = 0		# Encoder count change since last sample
-		self.cmd_scale = 127.0	# Command value for 100% duty cycle
-		
-		# Outputs from each step
-		self.torque = 0			# Total torque, Nm
-		self.accel = 0			# Angular acceleration, rad/s^2
-
-	def step(self):
-		dtime = self.sample_time / self.oversample
-		last_angle = self.angle
-		for i in range(self.oversample):
-			self.fine_step(dtime)
-		
-		self.enc_delta = (self.angle - last_angle) / (2 * pi) * self.ticks_per_rev
-
-	def fine_step(self, dtime):
-		# PWM duty cycle
-		self.pwm_duty = self.cmd / self.cmd_scale
-		
-		# Back-EMF
-		self.vmot = self.speed / (self.kr / rad_s_to_rpm)
-		
-		# Winding current
-		#FIXME - This use of rbatt may not work with PWM
-		self.imot = (self.vbatt * self.pwm_duty - self.vmot) / (self.rmot + self.rbatt)
-		
-		# Measured supply voltage
-		self.vs = self.vbatt - self.imot * self.rbatt
-		
-		# Torque exerted by the motor
-		self.torque = self.kt * self.imot
-		
-		if False:
-			# Friction
-			if self.speed == 0:
-				#FIXME - Static friction
-				pass
-			# Kinetic friction
-			elif self.speed > 0:
-				self.torque -= self.friction
-			else:
-				self.torque += self.friction
-		self.torque -= self.friction
-		
-		# Wobbling shaft/rotor
-		self.torque += self.speed * self.speed * self.kosc * sin(self.angle)
-		
-		self.accel = self.torque / self.load
-		
-		# Update motor state
-		self.angle += self.speed * dtime + 0.5 * self.accel * dtime * dtime
-		self.speed += self.accel * dtime
+    def __init__(self):
+        self.vbatt = 12.483  # Battery voltage
+        self.kr = 379  # Speed constant, rpm/V
+        self.kt = .0255  # Torque constant, Nm/A
+        self.sample_time = 0.005  # Time per step, s
+        self.oversample = 50  # Fine steps per sample time
+        self.speed = 0  # Motor speed, rad/s
+        self.rbatt = 0.39  # Battery internal resistance, ohms
+        self.rmot = 1.2  # Winding resistance, phase-to-phase, ohms
+        self.angle = 0  # Cumulative rotor angle, rad
+        self.load = 120 / 1e7  # Load inertia, kg*m^2
+        self.kosc = 2.7 / 1e7  # Oscillation amplitude coefficient, Nm/(m/s)^2
+        self.cmd = 0  # FPGA command, 0..127
+        self.ticks_per_rev = 1440  # Encoder ticks per motor revolution
+        self.friction = 0  # Constant (kinetic) friction, Nm
+        self.enc_delta = 0  # Encoder count change since last sample
+        self.cmd_scale = 127.0  # Command value for 100% duty cycle
+
+        # Outputs from each step
+        self.torque = 0  # Total torque, Nm
+        self.accel = 0  # Angular acceleration, rad/s^2
+
+    def step(self):
+        dtime = self.sample_time / self.oversample
+        last_angle = self.angle
+        for i in range(self.oversample):
+            self.fine_step(dtime)
+
+        self.enc_delta = (self.angle - last_angle) / (2 *
+                                                      pi) * self.ticks_per_rev
+
+    def fine_step(self, dtime):
+        # PWM duty cycle
+        self.pwm_duty = self.cmd / self.cmd_scale
+
+        # Back-EMF
+        self.vmot = self.speed / (self.kr / rad_s_to_rpm)
+
+        # Winding current
+        #FIXME - This use of rbatt may not work with PWM
+        self.imot = (self.vbatt * self.pwm_duty - self.vmot) / (
+            self.rmot + self.rbatt)
+
+        # Measured supply voltage
+        self.vs = self.vbatt - self.imot * self.rbatt
+
+        # Torque exerted by the motor
+        self.torque = self.kt * self.imot
+
+        if False:
+            # Friction
+            if self.speed == 0:
+                #FIXME - Static friction
+                pass
+            # Kinetic friction
+            elif self.speed > 0:
+                self.torque -= self.friction
+            else:
+                self.torque += self.friction
+        self.torque -= self.friction
+
+        # Wobbling shaft/rotor
+        self.torque += self.speed * self.speed * self.kosc * sin(self.angle)
+
+        self.accel = self.torque / self.load
+
+        # Update motor state
+        self.angle += self.speed * dtime + 0.5 * self.accel * dtime * dtime
+        self.speed += self.accel * dtime

--- a/firmware/robot/signal_captures/plot-step/plot-step.py
+++ b/firmware/robot/signal_captures/plot-step/plot-step.py
@@ -5,10 +5,10 @@
 from matplotlib.pyplot import *
 
 if len(sys.argv) != 2:
-	print >> sys.stderr, 'Usage: %s <filename>' % sys.argv[0]
-	sys.exit(1)
+    print >> sys.stderr, 'Usage: %s <filename>' % sys.argv[0]
+    sys.exit(1)
 
 data = loadtxt(sys.argv[1])
-speed = data[1:,1]
+speed = data[1:, 1]
 plot(speed)
 show()

--- a/soccer/gameplay/fsm.py
+++ b/soccer/gameplay/fsm.py
@@ -15,7 +15,6 @@
 #
 # Subclasses of StateMachine can optionally implement them and they will automatically be called at the appropriate times.
 class StateMachine:
-
     def __init__(self, start_state):
         # stores all states in the form _state_hierarchy[state] = parent_state
         self._state_hierarchy = {}
@@ -23,24 +22,20 @@
         self._start_state = start_state
         self._state = None
 
-
     @property
     def start_state(self):
         return self._start_state
 
-
     ## Resets the FSM back into the start state
     def restart(self):
         self.transition(self.start_state)
 
-
     ## Registers a new state (which can optionally be a substate of an existing state)
     def add_state(self, state, parent_state=None):
         if not isinstance(state, Enum):
             raise TypeError("State should be an Enum type")
         self._state_hierarchy[state] = parent_state
 
-
     ## Runs the FSM
     # checks transition conditions for all edges leading away from the current state
     # if one evaluates to true, we transition to it
@@ -66,12 +61,17 @@
             # transition if an 'event' fires
             next_states = []
             if self.state in self._transitions:
-                for next_state, transition in self._transitions[self.state].items():
+                for next_state, transition in self._transitions[
+                        self.state].items():
                     if transition['condition']():
                         next_states += [next_state]
 
             if len(next_states) > 1:
-                logging.warn("Ambiguous fsm transitions from state'" + str(self.state) + "'.  The following states are reachable now: " + str(next_states) + ";  Proceeding by taking the first option.")
+                logging.warn(
+                    "Ambiguous fsm transitions from state'" + str(self.state) +
+                    "'.  The following states are reachable now: " + str(
+                        next_states) +
+                    ";  Proceeding by taking the first option.")
             if len(next_states) > 0:
                 self.transition(next_states[0])
 
@@ -80,16 +80,13 @@
         if s1 != self.state:
             StateMachine.spin(self)
 
-
-
-
     # if you add a transition that already exists, the old one will be overwritten
     def add_transition(self, from_state, to_state, condition, event_name):
         if from_state not in self._transitions:
             self._transitions[from_state] = {}
 
-        self._transitions[from_state][to_state] = {'condition': condition, 'name': event_name}
-
+        self._transitions[from_state][to_state] = {'condition': condition,
+                                                   'name': event_name}
 
     # sets @state to the new_state given
     # calls 'on_exit_STATENAME()' if it exists
@@ -102,7 +99,9 @@
                     method_name = "on_exit_" + state.name
                     state_method = None
                     try:
-                        state_method = getattr(self, method_name)    # call the transition FROM method if it exists
+                        state_method = getattr(
+                            self, method_name
+                        )  # call the transition FROM method if it exists
                     except AttributeError:
                         pass
                     if state_method is not None:
@@ -113,7 +112,9 @@
                 method_name = "on_enter_" + state.name
                 state_method = None
                 try:
-                    state_method = getattr(self, method_name)    # call the transition TO method if it exists
+                    state_method = getattr(
+                        self, method_name
+                    )  # call the transition TO method if it exists
                 except AttributeError:
                     pass
                 if state_method is not None:
@@ -121,12 +122,10 @@
 
         self._state = new_state
 
-
     # traverses the state hierarchy to see if it's in @state or one of @state's descendent states
     def is_in_state(self, state):
         return self.state_is_substate(self.state, state)
 
-
     def state_is_substate(self, state, possible_parent):
         ancestor = state
         while ancestor != None:
@@ -135,7 +134,6 @@
 
         return False
 
-
     # looks at the list @ancestors and returns the one that the current state is a descendant of
     # returns None if the current state doesn't descend from one in the list
     def corresponding_ancestor_state(self, ancestors):
@@ -147,7 +145,6 @@
 
         return None
 
-
     # returns a list of the ancestors of the given state
     # if B is a child state of A and C is a child state of B, ancestors_of_state(C) == [A, B]
     # if @state has no ancestors, returns an empty list
@@ -159,7 +156,6 @@
             state = self._state_hierarchy[state]
         return ancestors
 
-
     # returns a graphviz.Digraph object
     def as_graphviz(self):
         g = gv.Digraph(self.__class__.__name__, format='png')
@@ -168,8 +164,12 @@
         subgraphs = {}
         subgraphs[None] = g
         for state in self._state_hierarchy:
-            if state not in subgraphs and state in self._state_hierarchy.values():
-                sg = gv.Digraph('cluster_' + str(cluster_index), graph_attr={'label': state.__module__ + "::" + state.name, 'style': 'dotted'})
+            if state not in subgraphs and state in self._state_hierarchy.values(
+            ):
+                sg = gv.Digraph(
+                    'cluster_' + str(cluster_index),
+                    graph_attr={'label': state.__module__ + "::" + state.name,
+                                'style': 'dotted'})
                 cluster_index += 1
 
                 subgraphs[state] = sg
@@ -180,7 +180,10 @@
             if not has_children:
                 enclosing_graph = subgraphs[self._state_hierarchy[state]]
                 shape = 'diamond' if state == self.start_state else 'ellipse'
-                enclosing_graph.node(state.name, label=state.__module__ + "::" + state.name, shape=shape)
+                enclosing_graph.node(
+                    state.name,
+                    label=state.__module__ + "::" + state.name,
+                    shape=shape)
 
         for state, subgraph in subgraphs.items():
             if state != None:
@@ -188,17 +191,18 @@
 
         for start in self._transitions:
             for end, event in self._transitions[start].items():
-                g.edge(start.name, end.name, label=event['name'], decorate='True')
+                g.edge(start.name,
+                       end.name,
+                       label=event['name'],
+                       decorate='True')
 
         return g
 
-
     # writes a png file of the graphviz output to the specified location
     def write_diagram_png(self, filename):
         g = self.as_graphviz()
         g.render(filename=filename, cleanup=True)
 
-
     @property
     def state(self):
         return self._state

--- a/soccer/gameplay/evaluation/passing.py
+++ b/soccer/gameplay/evaluation/passing.py
@@ -18,8 +18,8 @@
     pass_dir = to_point - from_point
     pass_perp = pass_dir.perp_ccw()
     receive_seg_half_len = math.tan(pass_angle) * pass_dist
-    receive_seg = robocup.Segment(to_point + pass_perp*receive_seg_half_len,
-        to_point + pass_perp*-receive_seg_half_len)
+    receive_seg = robocup.Segment(to_point + pass_perp * receive_seg_half_len,
+                                  to_point + pass_perp * -receive_seg_half_len)
 
     win_eval = robocup.WindowEvaluator(main.system_state())
     for r in excluded_robots:

--- a/soccer/gameplay/generate_fsm_diagrams.py
+++ b/soccer/gameplay/generate_fsm_diagrams.py
@@ -5,7 +5,6 @@
 import sys
 import traceback
 
-
 sys.path.append('../../run')
 
 
@@ -25,7 +24,8 @@
 main.init()
 
 for behavior_type in ['skills', 'tactics', 'plays']:
-    entries = class_import.recursive_import_classes('.', [behavior_type], fsm.StateMachine)
+    entries = class_import.recursive_import_classes('.', [behavior_type],
+                                                    fsm.StateMachine)
 
     for entry in entries:
         try:
@@ -37,5 +37,6 @@
             klass().write_diagram_png(filepath)
             print("generated " + filepath)
         except Exception as e:
-            logging.error("Error generating fsm diagram for behavior '" + klass.__name__ + "':" + str(e))
+            logging.error("Error generating fsm diagram for behavior '" +
+                          klass.__name__ + "':" + str(e))
             traceback.print_exc()

--- a/soccer/gameplay/evaluation/touchpass_positioning.py
+++ b/soccer/gameplay/evaluation/touchpass_positioning.py
@@ -27,14 +27,21 @@
 
     if kick_point.x > 0:
         # Ball is on right side of field
-        toReturn = robocup.Rect(robocup.Point(0, min(constants.Field.Length - offset_from_edge, main.ball().pos.y - offset_from_ball)),
-                robocup.Point(-constants.Field.Width / 2 + offset_from_edge, min(constants.Field.Length * 3 / 4, main.ball().pos.y - 2)))
+        toReturn = robocup.Rect(
+            robocup.Point(0, min(constants.Field.Length - offset_from_edge,
+                                 main.ball().pos.y - offset_from_ball)),
+            robocup.Point(-constants.Field.Width / 2 + offset_from_edge, min(
+                constants.Field.Length * 3 / 4, main.ball().pos.y - 2)))
     else:
         # Ball is on left side of field
-        toReturn = robocup.Rect(robocup.Point(0, min(constants.Field.Length - offset_from_edge, main.ball().pos.y - offset_from_ball)),
-                robocup.Point(constants.Field.Width / 2 - offset_from_edge, min(constants.Field.Length * 3 / 4, main.ball().pos.y - 2)))
+        toReturn = robocup.Rect(
+            robocup.Point(0, min(constants.Field.Length - offset_from_edge,
+                                 main.ball().pos.y - offset_from_ball)),
+            robocup.Point(constants.Field.Width / 2 - offset_from_edge, min(
+                constants.Field.Length * 3 / 4, main.ball().pos.y - 2)))
     return toReturn
 
+
 ## Returns a list of robocup.Segment object that represent candidate lines. Takes in a robocup.Rect.
 #
 # These lines will be evaluated later by the window_evaluator.
@@ -48,17 +55,22 @@
     while currentx <= rect.max_x():
         currenty = rect.max_y()
         # Don't include goal area.
-        if constants.Field.TheirGoalShape.contains_point(robocup.Point(currentx, rect.min_y())):
+        if constants.Field.TheirGoalShape.contains_point(robocup.Point(
+                currentx, rect.min_y())):
             continue
-        while constants.Field.TheirGoalShape.contains_point(robocup.Point(currentx, currenty)):
+        while constants.Field.TheirGoalShape.contains_point(robocup.Point(
+                currentx, currenty)):
             currenty = currenty - threshold
 
-        candiate = robocup.Segment(robocup.Point(currentx, rect.min_y()), robocup.Point(currentx, currenty))
+        candiate = robocup.Segment(
+            robocup.Point(currentx, rect.min_y()), robocup.Point(currentx,
+                                                                 currenty))
         outlist.extend([candiate])
         currentx = currentx + threshold
     currentx = rect.min_x()
     return outlist
 
+
 ## Evaluates a single point, and returns the probability of it making it.
 #
 # The value returned is the probability that a pass from the kick_point to the receive_point will make it,
@@ -70,17 +82,21 @@
         else:
             return None
 
-    currentChance = evaluation.passing.eval_pass(kick_point, receive_point, ignore_robots)
+    currentChance = evaluation.passing.eval_pass(kick_point, receive_point,
+                                                 ignore_robots)
     # TODO dont only aim for center of goal. Waiting on window_evaluator returning a probability.
     targetPoint = constants.Field.TheirGoalSegment.center()
-    currentChance = currentChance * evaluation.passing.eval_pass(receive_point, targetPoint, ignore_robots)
+    currentChance = currentChance * evaluation.passing.eval_pass(
+        receive_point, targetPoint, ignore_robots)
     return currentChance
 
 
 ## Finds the best receive point for a bounce-pass.
 #
 # Takes in an initial kick point and an optional evaluation zone.
-def eval_best_receive_point(kick_point, evaluation_zone=None, ignore_robots=[]):
+def eval_best_receive_point(kick_point,
+                            evaluation_zone=None,
+                            ignore_robots=[]):
     win_eval = robocup.WindowEvaluator(main.system_state())
     for r in ignore_robots:
         win_eval.add_excluded_robot(r)
@@ -99,7 +115,8 @@
     bestChance = None
 
     for segment in segments:
-        main.system_state().draw_line(segment, constants.Colors.Blue, "Candidate Lines")
+        main.system_state().draw_line(segment, constants.Colors.Blue,
+                                      "Candidate Lines")
         _, best = win_eval.eval_pt_to_seg(kick_point, segment)
         if best == None: continue
 

--- a/soccer/gameplay/main.py
+++ b/soccer/gameplay/main.py
@@ -15,16 +15,18 @@
 GAMEPLAY_DIR = os.path.dirname(os.path.realpath(__file__))
 PLAYBOOKS_DIR = GAMEPLAY_DIR + '/playbooks'
 
-
 # main init method for the python side of things
 _has_initialized = False
+
+
 def init():
     # by default, the logger only shows messages at the WARNING level or greater
     logging.getLogger().setLevel(logging.INFO)
 
     global _has_initialized
     if _has_initialized:
-        logging.warn("main robocoup python init() method called twice - ignoring")
+        logging.warn(
+            "main robocoup python init() method called twice - ignoring")
         return
 
     # init root play
@@ -37,13 +39,13 @@
     _play_registry = play_registry_module.PlayRegistry()
 
     # load all plays
-    play_classes = class_import.recursive_import_classes(GAMEPLAY_DIR, ['plays'], play.Play)
+    play_classes = class_import.recursive_import_classes(GAMEPLAY_DIR,
+                                                         ['plays'], play.Play)
     for entry in play_classes:
         # keep in mind that @entry is a tuple
         mod_path = entry[0][1:]
         _play_registry.insert(mod_path, entry[1])
 
-
     # this callback lets us do cool stuff when our python files change on disk
     def fswatch_callback(event_type, module_path):
         # the top-level folders we care about watching
@@ -61,17 +63,22 @@
                     try:
                         module = importlib.import_module('.'.join(module_path))
                     except:
-                        logging.error("Error reloading module '" + '.'.join(module_path) + "': e")
+                        logging.error("Error reloading module '" + '.'.join(
+                            module_path) + "': e")
                         traceback.print_exc()
                         return
 
                     try:
-                        play_class = class_import.find_subclasses(module, play.Play)[0]
-                        _play_registry.insert(module_path[1:], play_class) # note: skipping index zero of module_path cuts off the 'plays' part
+                        play_class = class_import.find_subclasses(module,
+                                                                  play.Play)[0]
+                        _play_registry.insert(
+                            module_path[1:], play_class
+                        )  # note: skipping index zero of module_path cuts off the 'plays' part
                     except IndexError as e:
                         # we'll get an IndexError exception if the module didn't contain any Plays
                         # FIXME: instead, we should unload the module and just log a warning
-                        raise Exception("Error: python files within the plays directory must contain a subclass of play.Play")
+                        raise Exception(
+                            "Error: python files within the plays directory must contain a subclass of play.Play")
             elif event_type == 'modified':
                 try:
                     # reload the module
@@ -82,20 +89,24 @@
                     try:
                         module = imp.reload(module)
                     except:
-                        logging.error("Error reloading module '" + '.'.join(module_path) + "': e")
+                        logging.error("Error reloading module '" + '.'.join(
+                            module_path) + "': e")
                         traceback.print_exc()
                         return
 
-                    logging.info("reloaded module '" + '.'.join(module_path) + "'")
+                    logging.info("reloaded module '" + '.'.join(module_path) +
+                                 "'")
 
                     if is_play:
                         # re-register the new play class
                         # FIXME: this logic should go inside the play_registry
-                        play_reg_node = _play_registry.node_for_module_path(module_path[1:])
-                        play_reg_node.play_class = class_import.find_subclasses(module, play.Play)[0]
+                        play_reg_node = _play_registry.node_for_module_path(
+                            module_path[1:])
+                        play_reg_node.play_class = class_import.find_subclasses(
+                            module, play.Play)[0]
                         # _play_registry.modelReset.emit()
 
-                    # kill currently-running stuff if needed
+                        # kill currently-running stuff if needed
                     if not is_play:
                         _root_play.drop_current_play()
                         _root_play.drop_goalie_behavior()
@@ -103,7 +114,8 @@
                         _root_play.drop_current_play()
 
                 except Exception as e:
-                    logging.error("EXCEPTION in file modified event: " + repr(e))
+                    logging.error("EXCEPTION in file modified event: " + repr(
+                        e))
                     traceback.print_exc()
                     raise e
             elif event_type == 'deleted':
@@ -117,8 +129,8 @@
                     _root_play.drop_current_play()
                     _root_play.drop_goalie_behavior()
             else:
-                raise AssertionError("Unknown FsWatcher event type: '" + event_type + "'")
-
+                raise AssertionError("Unknown FsWatcher event type: '" +
+                                     event_type + "'")
 
     # start up filesystem-watching
     watcher = fs_watcher.FsWatcher(GAMEPLAY_DIR)
@@ -127,17 +139,23 @@
 
     _has_initialized = True
 
+
 #loads the specified file_name from the playbooks folder
 #isAbsolute should be passed as True if the file_name is an absolute path
 def load_playbook(file_name, isAbsolute=False):
     global _play_registry
-    _play_registry.load_playbook(playbook.load_from_file((PLAYBOOKS_DIR + '/' if not isAbsolute else '') + file_name))
+    _play_registry.load_playbook(playbook.load_from_file((
+        PLAYBOOKS_DIR + '/' if not isAbsolute else '') + file_name))
+
 
 #saves the playbook into the specified file_name in the playbooks folder
 #isAbsolute should be passed as True if the file_name is an absolute path
 def save_playbook(file_name, isAbsolute=False):
     global _play_registry
-    playbook.save_to_file((PLAYBOOKS_DIR + '/' if not isAbsolute else '') + file_name, _play_registry.get_enabled_plays_paths());
+    playbook.save_to_file(
+        (PLAYBOOKS_DIR + '/' if not isAbsolute else '') + file_name,
+        _play_registry.get_enabled_plays_paths())
+
 
 ## Called ~60times/sec by the C++ GameplayModule
 def run():
@@ -150,20 +168,26 @@
             root_play().spin()
     except:
         exc = sys.exc_info()[0]
-        logging.error("Exception occurred in main.run(): " + str(exc) + "ignoring for now")
+        logging.error("Exception occurred in main.run(): " + str(exc) +
+                      "ignoring for now")
         traceback.print_exc()
 
 
 _root_play = None
+
+
 def root_play():
     return _root_play
 
 
 _play_registry = None
+
+
 def play_registry():
     global _play_registry
     return _play_registry
 
+
 # returns the first robot in our robots with matching ID,
 # or None if no robots have the given ID
 def our_robot_with_id(ID):
@@ -173,45 +197,70 @@
 ############################################################
 
 _game_state = None
+
+
 def game_state():
     global _game_state
     return _game_state
+
+
 def set_game_state(value):
     global _game_state
     _game_state = value
 
+
 _ball = None
+
+
 def ball():
     global _ball
     return _ball
+
+
 def set_ball(value):
     global _ball
     _ball = value
 
+
 _our_robots = None
+
+
 def our_robots():
     global _our_robots
     return _our_robots
+
+
 def set_our_robots(value):
     global _our_robots
     root_play().robots = value
     _our_robots = value
 
+
 _their_robots = None
+
+
 def their_robots():
     global _their_robots
     return _their_robots
+
+
 def set_their_robots(value):
     global _their_robots
     _their_robots = value
 
+
 _system_state = None
+
+
 def system_state():
     global _system_state
     return _system_state
+
+
 def set_system_state(value):
     global _system_state
     _system_state = value
 
+
 def set_field_constants(value):
     constants.setFieldConstantsFromField_Dimensions(value)

--- a/soccer/gameplay/fs_watcher.py
+++ b/soccer/gameplay/fs_watcher.py
@@ -7,7 +7,6 @@
 
 ## Watches the filesytem for changes and executes any registered callbacks
 class FsWatcher(Observer):
-
     def __init__(self, path):
         super().__init__()
         handler = FsWatcher.FsEventHandler(self)
@@ -15,28 +14,25 @@
         self.schedule(handler, path, recursive=True)
         self.root_path = path
 
-
     ## the callback is passed event_type, module_path
     # where event_type is a string with the following possible values: 'modified', 'created', 'deleted'
     def subscribe(self, callback):
         self._subscribers.append(callback)
 
-
     ## removes a given subscriber
     def unsubscribe(self, callback):
         idx = self._subscribers.index(callback)
         del self._subscribers[idx]
 
-
     ## The directory to watch recursively
     @property
     def root_path(self):
         return self._root_path
+
     @root_path.setter
     def root_path(self, value):
         self._root_path = value
 
-
     # the handler calls _notify on its parent FsWatcher
     def _notify(self, event_type, path):
         if not isinstance(path, str):
@@ -49,7 +45,7 @@
             # remove the prefix @root from @subpath
             root = os.path.abspath(self.root_path)
             subpath = name[len(root):]
-            if len(subpath) > 0 and subpath[0] == '/': subpath = subpath[1:] 
+            if len(subpath) > 0 and subpath[0] == '/': subpath = subpath[1:]
 
             # if we're watching /robocup/soccer/gameplay and within that, plays/my_play.py changes,
             # we extract ['plays', 'my_play'] into the @modpath list
@@ -69,10 +65,7 @@
             for subscriber in self._subscribers:
                 subscriber(event_type, modpath)
 
-
-
     class FsEventHandler(FileSystemEventHandler):
-
         def __init__(self, watcher):
             super().__init__()
             self._watcher = watcher
@@ -90,8 +83,8 @@
                 self._watcher._notify('deleted', event.src_path)
 
 
-
 if __name__ == '__main__':
+
     def watcher_callback(event_type, modpath):
         print("CALLBACK")
         is_play = modpath[0] == 'plays'

--- a/soccer/gameplay/play.py
+++ b/soccer/gameplay/play.py
@@ -7,11 +7,9 @@
 # however, by overriding the handles_goalie() class method, a Play can choose to handle
 # the goalie on its own, which allows for greater coordination.
 class Play(composite_behavior.CompositeBehavior):
-
     def __init__(self, continuous):
         super().__init__(continuous)
 
-
     ## Used to determine when to run a play
     # Return float("inf") if the play cannot be used or a score (lower is better) used to select the best play.
     @classmethod
@@ -20,8 +18,7 @@
 
     @classmethod
     def is_restart(cls):
-    	return False
-
+        return False
 
     ## Override to opt-in to handling the Goalie
     # By default, the root play allocates and runs the goalie behavior

--- a/soccer/MainWindow.cpp
+++ b/soccer/MainWindow.cpp
@@ -304,9 +304,10 @@
              i < liveFrame->debug_layers_size(); ++i) {
             const QString name =
                 QString::fromStdString(liveFrame->debug_layers(i));
-            bool enabled = !std::any_of(
-                defaultHiddenLayers.begin(), defaultHiddenLayers.end(),
-                [&](QString string) { return string == name; });
+            bool enabled =
+                !std::any_of(defaultHiddenLayers.begin(),
+                             defaultHiddenLayers.end(),
+                             [&](QString string) { return string == name; });
             addLayer(i, name, enabled);
         }
 
@@ -392,11 +393,9 @@
     }
 
     _ui.refStage->setText(NewRefereeModuleEnums::stringFromStage(
-                              _processor->refereeModule()->stage)
-                              .c_str());
+                              _processor->refereeModule()->stage).c_str());
     _ui.refCommand->setText(NewRefereeModuleEnums::stringFromCommand(
-                                _processor->refereeModule()->command)
-                                .c_str());
+                                _processor->refereeModule()->command).c_str());
 
     // convert time left from ms to s and display it to two decimal places
     _ui.refTimeLeft->setText(tr("%1 s").arg(QString::number(
@@ -1053,7 +1052,7 @@
     QMenu menu;
     QAction* all = menu.addAction("All");
     QAction* none = menu.addAction("None");
-    QAction *single = nullptr, *notSingle = nullptr;
+    QAction* single = nullptr, * notSingle = nullptr;
     if (item) {
         single = menu.addAction("Only this");
         notSingle = menu.addAction("All except this");

--- a/soccer/gameplay/plays/restarts/defend_penalty.py
+++ b/soccer/gameplay/plays/restarts/defend_penalty.py
@@ -7,26 +7,28 @@
 
 
 class DefendPenalty(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         # lineup
-        line = robocup.Segment(robocup.Point(1.5, 1.3), robocup.Point(1.5, 2.5))
+        line = robocup.Segment(
+            robocup.Point(1.5, 1.3), robocup.Point(1.5, 2.5))
         lineup = tactics.line_up.LineUp(line)
         self.add_subbehavior(lineup, 'lineup')
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False,)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False, )
 
     @classmethod
     def score(cls):
         gs = main.game_state()
-        return 0 if gs.is_their_penalty() and gs.is_setup_state() else float("inf")
+        return 0 if gs.is_their_penalty() and gs.is_setup_state() else float(
+            "inf")
 
     @classmethod
     def is_restart(cls):

--- a/soccer/Processor.cpp
+++ b/soccer/Processor.cpp
@@ -308,22 +308,23 @@
 
             if (packet->wrapper.has_geometry()) {
                 // DEMO: Test out field sizes
-                const SSL_GeometryFieldSize fieldSize = packet->wrapper.geometry().field();
-                cout << "Len: " << fieldSize.field_length() << " Width: " <<
-                    fieldSize.field_width() << endl;
+                const SSL_GeometryFieldSize fieldSize =
+                    packet->wrapper.geometry().field();
+                cout << "Len: " << fieldSize.field_length()
+                     << " Width: " << fieldSize.field_width() << endl;
                 // FIXME - Account for network latency
 
-
                 cout << "line count: " << fieldSize.field_lines_size() << endl;
 
                 if (fieldSize.field_length() != 0 &&
                     // Compare floats with a small threshold
-                    (currentDimensions->Length() - (fieldSize.field_length() / 1000.0f)) > 0.001f) {
+                    (currentDimensions->Length() -
+                     (fieldSize.field_length() / 1000.0f)) > 0.001f) {
                     // Set the changed field dimensions to the current ones
                     decodeGeometryPacket(&fieldSize);
-                }
-                else  {
-                    decodeGeometryPacket(&fieldSize); // TODO REMOVE FORCE OVERRIDE
+                } else {
+                    decodeGeometryPacket(
+                        &fieldSize);  // TODO REMOVE FORCE OVERRIDE
                 }
             }
 
@@ -618,30 +619,35 @@
         return;
     }
 
-    cout << "Detected data!!!" <<endl;
+    cout << "Detected data!!!" << endl;
 
     const SSL_FieldCicularArc* penalty = nullptr;
     const SSL_FieldCicularArc* center = nullptr;
     float displacement = 0.500f;  // default displacment
 
     for (int i = 0; i < fieldSize->field_arcs().size(); i++) {
-        if (boost::iequals(fieldSize->field_arcs().Get(i).name(), "CenterCircle")) {
+        if (boost::iequals(fieldSize->field_arcs().Get(i).name(),
+                           "CenterCircle")) {
             // Assume center circle
             center = &fieldSize->field_arcs().Get(i);
-        } else if (boost::iequals(fieldSize->field_arcs().Get(i).name(), "LeftFieldLeftPenaltyArc")) {
+        } else if (boost::iequals(fieldSize->field_arcs().Get(i).name(),
+                                  "LeftFieldLeftPenaltyArc")) {
             penalty = &fieldSize->field_arcs().Get(i);
         }
     }
 
     for (int i = 0; i < fieldSize->field_lines().size(); i++) {
-        if (boost::iequals(fieldSize->field_lines().Get(i).name(), "RightPenaltyStretch")) {
-            displacement = abs(fieldSize->field_lines().Get(i).p2().y() - fieldSize->field_lines().Get(i).p1().y());
+        if (boost::iequals(fieldSize->field_lines().Get(i).name(),
+                           "RightPenaltyStretch")) {
+            displacement = abs(fieldSize->field_lines().Get(i).p2().y() -
+                               fieldSize->field_lines().Get(i).p1().y());
         }
     }
 
     float thickness = fieldSize->field_lines().Get(0).thickness() / 1000.0f;
 
-    // The values we get are the center of the lines, we want to use the outside, so we can add this as an offset.
+    // The values we get are the center of the lines, we want to use the
+    // outside, so we can add this as an offset.
     float adj = fieldSize->field_lines().Get(0).thickness() / 1000.0f / 2.0f;
 
     float fieldBorder = currentDimensions->Border();
@@ -649,20 +655,20 @@
     if (penalty != nullptr && center != nullptr && thickness != 0) {
         // Force a resize
         // TODO fix hardcoded values here
-        setFieldDimensions(Field_Dimensions (
-                               fieldSize->field_length() / 1000.0f, fieldSize->field_width() / 1000.0f,
-                               fieldBorder,
-                               thickness,
-                               fieldSize->goal_width() / 1000.0f, fieldSize->goal_depth() / 1000.0f,
-                               0.160f,                                  // Goal Height
-                               penalty->radius() / 1000.0f + adj,       // PenaltyDist
-                               0.010f,                                  // PenaltyDiam
-                               penalty->radius() / 1000.0f + adj,       // ArcRadius
-                               center->radius() / 1000.0f + adj,        // CenterRadius
-                               (center->radius()) * 2 / 1000.0f + adj,  // CenterDiameter
-                               displacement / 1000.0f,                  // GoalFlat
-                               (fieldSize->field_length() / 1000.0f + (fieldBorder) * 2),
-                               (fieldSize->field_width() / 1000.0f + (fieldBorder) * 2)));
+        setFieldDimensions(Field_Dimensions(
+            fieldSize->field_length() / 1000.0f,
+            fieldSize->field_width() / 1000.0f, fieldBorder, thickness,
+            fieldSize->goal_width() / 1000.0f,
+            fieldSize->goal_depth() / 1000.0f,
+            0.160f,                                  // Goal Height
+            penalty->radius() / 1000.0f + adj,       // PenaltyDist
+            0.010f,                                  // PenaltyDiam
+            penalty->radius() / 1000.0f + adj,       // ArcRadius
+            center->radius() / 1000.0f + adj,        // CenterRadius
+            (center->radius()) * 2 / 1000.0f + adj,  // CenterDiameter
+            displacement / 1000.0f,                  // GoalFlat
+            (fieldSize->field_length() / 1000.0f + (fieldBorder)*2),
+            (fieldSize->field_width() / 1000.0f + (fieldBorder)*2)));
     } else {
         // TODO log errors here
     }

--- a/soccer/gameplay/plays/restarts/kick_penalty.py
+++ b/soccer/gameplay/plays/restarts/kick_penalty.py
@@ -8,19 +8,16 @@
 
 # one robot kicks the ball, the others just line up and wait
 class KickPenalty(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            lambda: self.kicker.is_done_running(),
-            'when kicker finishes.')
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
+            lambda: self.kicker.is_done_running(), 'when kicker finishes.')
 
         self.kicker = tactics.penalty.Penalty()
         self.add_subbehavior(self.kicker, 'kicker', required=True, priority=10)

--- a/soccer/gameplay/play_registry.py
+++ b/soccer/gameplay/play_registry.py
@@ -13,16 +13,13 @@
 #
 # This is a subclass of QAbstractItemModel so that we can easily attach a UI
 class PlayRegistry(QtCore.QAbstractItemModel):
-
     def __init__(self):
         super().__init__()
         self._root = PlayRegistry.Category(None, "")
 
-
     @property
     def root(self):
         return self._root
-    
 
     # the module path is a list
     # for a demo play called RunAround, module_path = ['demo', 'run_around']
@@ -52,7 +49,8 @@
             if node is not None:
                 node.enabled = True
             else:
-                logging.warn("Attempt to load non-existent play " + '/'.join(play) + " from playbook.")
+                logging.warn("Attempt to load non-existent play " + '/'.join(
+                    play) + " from playbook.")
 
         # note: this is a shitty way to do this - we should really only reload part of the model
         self.modelReset.emit()
@@ -73,14 +71,14 @@
         # note: this is a shitty way to do this - we should really only reload part of the model
         self.modelReset.emit()
 
-
     # cache and calculate the score() function for each play class
     def recalculate_scores(self):
         self.root.recalculate_scores(self)
 
     ## Get a list of all plays in the tree that are currently enabled
     def get_enabled_plays_and_scores(self):
-        return [(node.play_class, node.last_score) for node in self if node.enabled]
+        return [(node.play_class, node.last_score)
+                for node in self if node.enabled]
 
     ## Returns a list of module paths for the currently-enabled plays
     # The module path is a list or tuple giving the path the the play's python module
@@ -110,8 +108,8 @@
                     yield child
                 else:
                     yield from _recursive_iter(child)
-        return _recursive_iter(self.root)
 
+        return _recursive_iter(self.root)
 
     def __contains__(self, play_class):
         for node in self:
@@ -119,7 +117,6 @@
                 return True
         return False
 
-
     def __str__(self):
         def _cat_str(category, indent):
             desc = ""
@@ -131,11 +128,10 @@
                     desc += "    " * indent + child.name + ':' + '\n'
                     desc += _cat_str(child, indent + 1)
                 desc += '\n'
-            return desc[:-1]    # delete trailing newline
+            return desc[:-1]  # delete trailing newline
 
         return "PlayRegistry:\n-------------\n" + _cat_str(self.root, 0)
 
-
     # module_path is a list like ['demo', 'my_demo']
     # returns a Node or None if it can't find it
     def node_for_module_path(self, module_path):
@@ -152,7 +148,6 @@
 
         return None
 
-
     ## Categories correspond to filesystem directories
     class Category():
         def __init__(self, parent, name):
@@ -162,7 +157,6 @@
             self._parent = parent
             self._children = list()
 
-
         @property
         def name(self):
             return self._name
@@ -171,7 +165,6 @@
         def module_name(self):
             return self.name
 
-
         # Instructs all child nodes to recalculate their scores.
         # if a child node returns True indicating that the score value changed, we
         # emit the "dataChanged" signal with the corresponding node index
@@ -182,10 +175,10 @@
                     col = 1
                     parent = child.parent
                     index = model.createIndex(row, col, child)
-                    model.dataChanged.emit(index, index) # , [QtCore.Qt.DisplayRole]
+                    model.dataChanged.emit(index, index
+                                           )  # , [QtCore.Qt.DisplayRole]
             return False
 
-
         def __delitem__(self, name):
             for idx, child in enumerate(self.children):
                 if child.name == name:
@@ -193,31 +186,26 @@
                     return
             raise KeyError("Attempt to delete a child node that doesn't exist")
 
-
         def append_child(self, child):
             self.children.append(child)
             child.parent = self
 
-
         def __getitem__(self, name):
             for child in self.children:
                 if child.name == name:
                     return child
             return None
 
-
         def has_child_with_name(self, name):
             return self[name] != None
 
-
         @property
         def parent(self):
             return self._parent
+
         @parent.setter
         def parent(self, value):
             self._parent = value
-        
-
 
         # @children is a list
         @property
@@ -231,11 +219,7 @@
             else:
                 return 0
 
-
-
-
     class Node():
-
         def __init__(self, module_name, play_class):
             self._module_name = module_name
             self._play_class = play_class
@@ -243,10 +227,10 @@
             self._last_score = float("inf")
             self._parent = None
 
-
         @property
         def parent(self):
             return self._parent
+
         @parent.setter
         def parent(self, value):
             self._parent = value
@@ -262,18 +246,19 @@
         @property
         def play_class(self):
             return self._play_class
+
         @play_class.setter
         def play_class(self, value):
             self._play_class = value
-        
+
         @property
         def enabled(self):
             return self._enabled
+
         @enabled.setter
         def enabled(self, value):
             self._enabled = value
 
-
         # recalculates and caches the score value for the play
         # returns True if the value changed and False otherwise
         def recalculate_scores(self, model):
@@ -281,18 +266,13 @@
             self._last_score = self.play_class.score()
             return prev != self._last_score
 
-
-
         @property
         def last_score(self):
             return self._last_score
 
-
         def __str__(self):
-            return self.play_class.__name__ + " " + ("[ENABLED]" if self.enabled else "[DISABLED]")
-
-
-
+            return self.play_class.__name__ + " " + (
+                "[ENABLED]" if self.enabled else "[DISABLED]")
 
     # Note: a lot of the QAbstractModel-specific implementation is borrowed from here:
     # http://www.hardcoded.net/articles/using_qtreeview_with_qabstractitemmodel.htm
@@ -301,14 +281,12 @@
     def columnCount(self, parent):
         return 2
 
-
     def flags(self, index):
         if index.column() == 0:
             return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEditable
         else:
             return QtCore.Qt.ItemIsEnabled
 
-
     def data(self, index, role):
         if not index.isValid():
             return None
@@ -321,14 +299,14 @@
                     return str(node.play_class.score())
                 else:
                     return None
-        elif role == QtCore.Qt.CheckStateRole and isinstance(node, PlayRegistry.Node):
+        elif role == QtCore.Qt.CheckStateRole and isinstance(
+                node, PlayRegistry.Node):
             if index.column() == 0:
                 return node.enabled
             else:
                 return None
         return None
 
-
     def rowCount(self, parent):
         if not parent.isValid():
             return len(self.root.children)
@@ -338,7 +316,6 @@
         else:
             return len(node.children)
 
-
     def parent(self, index):
         if not index.isValid():
             return QtCore.QModelIndex()
@@ -352,7 +329,6 @@
                 parentRow = node.parent.row
             return self.createIndex(parentRow, index.column(), node.parent)
 
-
     def index(self, row, column, parent):
         if not parent.isValid():
             return self.createIndex(row, column, self.root.children[row])
@@ -362,7 +338,6 @@
         else:
             return QtCore.QModelIndex()
 
-
     def headerData(self, section, orientation, role):
         if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
             if section == 0:
@@ -371,14 +346,14 @@
                 return 'Score'
         return None
 
-
     # this is implemented so we can enable/disable plays from the gui
     def setData(self, index, value, role):
         if role == QtCore.Qt.CheckStateRole:
             if index.isValid():
                 playNode = index.internalPointer()
                 if not isinstance(playNode, PlayRegistry.Node):
-                    raise AssertionError("Only Play Nodes should be checkable...")
+                    raise AssertionError(
+                        "Only Play Nodes should be checkable...")
                 playNode.enabled = not playNode.enabled
                 self.dataChanged.emit(index, index)
                 return True

--- a/soccer/gameplay/behavior.py
+++ b/soccer/gameplay/behavior.py
@@ -17,7 +17,6 @@
         failed = 4
         cancelled = 5
 
-
     def __init__(self, continuous):
         super().__init__(start_state=Behavior.State.start)
         # add base states for Behavior
@@ -29,40 +28,37 @@
 
         self._is_continuous = continuous
 
-
     def add_state(self, state, parent_state=None):
         super().add_state(state, parent_state)
         #TODO: raise exception if @state doesn't have a Behavior.State ancestor
 
-
-    ## Whether or not the Behavior is running
-    # Because we use hierarchial state machines, a behavior never be in the "running", but may be in a substate of it
-    # This is a convenience method to check whether or not the play is running
+        ## Whether or not the Behavior is running
+        # Because we use hierarchial state machines, a behavior never be in the "running", but may be in a substate of it
+        # This is a convenience method to check whether or not the play is running
     def is_done_running(self):
-        for state in [Behavior.State.completed, Behavior.State.failed, Behavior.State.cancelled]:
+        for state in [Behavior.State.completed, Behavior.State.failed,
+                      Behavior.State.cancelled]:
             if self.is_in_state(state): return True
 
         return False
 
-
     ## Transitions the Behavior into a terminal state (either completed or cancelled)
     def terminate(self):
         if self.is_done_running():
-            logging.warn("Attempt to terminate behavior that's already done running")
+            logging.warn(
+                "Attempt to terminate behavior that's already done running")
         else:
             if self.is_continuous:
                 self.transition(Behavior.State.completed)
             else:
                 self.transition(Behavior.State.cancelled)
 
-
     ## returns a state in Behavior.State that represents what the behaviors is doing
     # use this instead of the @state property if you want to avoid dealing with custom subclass substates
     @property
     def behavior_state(self):
         return self.corresponding_ancestor_state(list(Behavior.State))
 
-
     ## The Behavior's termination behavior
     # noncontinuous: a behavior that accomplishes a specific task, then completes (example: shooting at the goal)
     # continuous: a behavior that continually runs until told to stop (example: zone defense)
@@ -70,19 +66,16 @@
     def is_continuous(self):
         return self._is_continuous
 
-
     def __str__(self):
         state_desc = self.state.name if self.state != None else ""
         return self.__class__.__name__ + "::" + state_desc
 
-
     ## Returns a tree of RoleRequirements keyed by subbehavior reference name
     # This is used by the dynamic role assignment system to
     # intelligently select which robot will run which behavior
     def role_requirements(self):
         raise NotImplementedError()
 
-
     ## assignments is a tree of (RoleRequirements, OurRobot) tuples
     # Same tree structure as the role_requirements() return value, but tuples instead of RoleRequirements as leaf nodes
     def assign_roles(self, assignments):

--- a/soccer/gameplay/plays/testing/test_coordinated_pass.py
+++ b/soccer/gameplay/plays/testing/test_coordinated_pass.py
@@ -11,26 +11,24 @@
 class TestCoordinatedPass(play.Play):
 
     ReceiveXCoord = 1
-    ReceiveYCoord = constants.Field.Length / 2.0 * 1.0/3.0
+    ReceiveYCoord = constants.Field.Length / 2.0 * 1.0 / 3.0
 
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         pass_bhvr = tactics.coordinated_pass.CoordinatedPass()
         self.add_subbehavior(pass_bhvr, 'pass')
 
-
-
     def reset_receive_point(self):
         pass_bhvr = self.subbehavior_with_name('pass')
-        x = TestCoordinatedPass.ReceiveXCoord if main.ball().pos.x < 0 else -TestCoordinatedPass.ReceiveXCoord
-        pass_bhvr.receive_point = robocup.Point(x, TestCoordinatedPass.ReceiveYCoord)
-
+        x = TestCoordinatedPass.ReceiveXCoord if main.ball(
+        ).pos.x < 0 else -TestCoordinatedPass.ReceiveXCoord
+        pass_bhvr.receive_point = robocup.Point(
+            x, TestCoordinatedPass.ReceiveYCoord)
 
     def execute_running(self):
         pass_bhvr = self.subbehavior_with_name('pass')
@@ -41,4 +39,3 @@
 
         if pass_bhvr.receive_point == None:
             self.reset_receive_point()
-

--- a/soccer/gameplay/plays/restarts/our_goal_kick.py
+++ b/soccer/gameplay/plays/restarts/our_goal_kick.py
@@ -20,15 +20,12 @@
     KickerPower = 1.0
     ChipperPower = 1.0
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         kicker = skills.line_kick.LineKick()
         # kicker.use_chipper = True
@@ -36,22 +33,21 @@
         kicker.chip_power = OurGoalKick.ChipperPower
         self.add_subbehavior(kicker, 'kicker', required=True, priority=6)
 
-
         center1 = skills.move.Move()
         self.add_subbehavior(center1, 'center1', required=False, priority=5)
-        
+
         center2 = skills.move.Move()
         self.add_subbehavior(center2, 'center2', required=False, priority=4)
 
-
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
-
-
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
     @classmethod
     def score(cls):
         gs = main.game_state()
-        return 0 if (gs.is_ready_state() and gs.is_our_direct() and main.ball().pos.y < 1.0) else float("inf")
+        return 0 if (gs.is_ready_state() and gs.is_our_direct() and
+                     main.ball().pos.y < 1.0) else float("inf")
 
     @classmethod
     def is_restart(cls):
@@ -61,7 +57,6 @@
     def handles_goalie(cls):
         return True
 
-
     def execute_running(self):
         kicker = self.subbehavior_with_name('kicker')
         center1 = self.subbehavior_with_name('center1')
@@ -69,10 +64,12 @@
 
         # see if we have a direct shot on their goal
         win_eval = robocup.WindowEvaluator(main.system_state())
-        win_eval.enable_chip = kicker.robot != None and kicker.robot.has_chipper()
+        win_eval.enable_chip = kicker.robot != None and kicker.robot.has_chipper(
+        )
         win_eval.min_chip_range = OurGoalKick.MinChipRange
         win_eval.max_chip_range = OurGoalKick.MaxChipRange
-        windows, best = win_eval.eval_pt_to_seg(main.ball().pos, constants.Field.TheirGoalSegment)
+        windows, best = win_eval.eval_pt_to_seg(
+            main.ball().pos, constants.Field.TheirGoalSegment)
 
         # note: the min length value is tunable
         if best != None and best.segment.length() > 0.3:

--- a/soccer/gameplay/playbook.py
+++ b/soccer/gameplay/playbook.py
@@ -1,9 +1,9 @@
-
 ## Load and save playbook files
 # A playbook is a simple text file with a '.pbk' extension that lists
 # plays to enable.  The entries are the paths to the play's python module,
 # NOT the actual play name.  See playbooks/example.pbk for an example.
 
+
 def load_from_file(playbook_file):
     plays = []
 
@@ -15,6 +15,7 @@
 
     return plays
 
+
 def save_to_file(playbook_file, list_of_plays):
     with open(playbook_file, 'w') as f:
         import re

--- a/soccer/gameplay/class_import.py
+++ b/soccer/gameplay/class_import.py
@@ -28,7 +28,8 @@
         new_module_path = module_path + [module_name]
 
         if is_pkg:
-            classes += recursive_import_classes(base_path, new_module_path, parent_class)
+            classes += recursive_import_classes(base_path, new_module_path,
+                                                parent_class)
         else:
             module = importlib.import_module('.'.join(new_module_path))
             entry = (new_module_path, find_subclasses(module, parent_class)[0])
@@ -40,7 +41,8 @@
 def find_subclasses(module, parent_class):
     classes = []
     for name, obj in inspect.getmembers(module):
-        if inspect.isclass(obj) and issubclass(obj, parent_class) and obj != parent_class:
+        if inspect.isclass(obj) and issubclass(
+                obj, parent_class) and obj != parent_class:
             # print('module: ' + str(module))
             classes.append(obj)
     return classes
@@ -53,4 +55,3 @@
     print("imports:")
     for res in results:
         print("\t" + str(res))
-

--- a/soccer/gameplay/plays/testing/test_defense.py
+++ b/soccer/gameplay/plays/testing/test_defense.py
@@ -7,18 +7,19 @@
 
 ## Runs our Defense tactic
 class TestDefense(play.Play):
+    def __init__(self):
+        super().__init__(continuous=True)
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
-	def __init__(self):
-		super().__init__(continuous=True)
-		self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
+    def on_enter_running(self):
+        b = tactics.defense.Defense()
+        self.add_subbehavior(b, name='defense', required=True)
 
-	def on_enter_running(self):
-		b = tactics.defense.Defense()
-		self.add_subbehavior(b, name='defense', required=True)
+    def on_exit_running(self):
+        self.remove_subbehavior('defense')
 
-	def on_exit_running(self):
-		self.remove_subbehavior('defense')
-
-	@classmethod
-	def handles_goalie(cls):
-		return True
+    @classmethod
+    def handles_goalie(cls):
+        return True

--- a/soccer/gameplay/plays/restarts/our_corner_kick.py
+++ b/soccer/gameplay/plays/restarts/our_corner_kick.py
@@ -14,19 +14,16 @@
     ChipperPower = 0.5
     TargetSegmentWidth = 1.5
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         self.kicker = skills.line_kick.LineKick()
         self.kicker.use_chipper = True
-        self.kicker.chip_power = OurCornerKick.ChipperPower # TODO: base this on the target dist from the bot
+        self.kicker.chip_power = OurCornerKick.ChipperPower  # TODO: base this on the target dist from the bot
         self.kicker.min_chip_range = OurCornerKick.MinChipRange
         self.kicker.max_chip_range = OurCornerKick.MaxChipRange
         self.add_subbehavior(self.kicker, 'kicker', required=True, priority=5)
@@ -36,23 +33,31 @@
         self.kicker.drive_around_dist = constants.Field.CenterRadius - constants.Robot.Radius
 
         self.center1 = skills.move.Move()
-        self.add_subbehavior(self.center1, 'center1', required=False, priority=4)
+        self.add_subbehavior(self.center1,
+                             'center1',
+                             required=False,
+                             priority=4)
 
         self.center2 = skills.move.Move()
-        self.add_subbehavior(self.center2, 'center2', required=False, priority=3)
-
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(self.center2,
+                             'center2',
+                             required=False,
+                             priority=3)
+
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
         self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            self.kicker.is_done_running,
-            'kicker is done')
+                            behavior.Behavior.State.completed,
+                            self.kicker.is_done_running, 'kicker is done')
 
     @classmethod
     def score(cls):
         gs = main.game_state()
 
-        if gs.is_ready_state() and gs.is_our_direct() and  main.ball().pos.y > ( constants.Field.Length - 1.0 ):
+        if gs.is_ready_state() and gs.is_our_direct() and main.ball().pos.y > (
+                constants.Field.Length - 1.0):
             return 0
         else:
             return float("inf")
@@ -65,12 +70,14 @@
     def handles_goalie(cls):
         return True
 
-
     def execute_running(self):
         # setup the kicker target
-        goal_x = constants.Field.GoalWidth * (1 if main.ball().pos.x < 0 else -1)
-        target = robocup.Segment(robocup.Point(goal_x, constants.Field.Length),
-            robocup.Point(goal_x, constants.Field.Length - OurCornerKick.TargetSegmentWidth))
+        goal_x = constants.Field.GoalWidth * (1
+                                              if main.ball().pos.x < 0 else -1)
+        target = robocup.Segment(
+            robocup.Point(goal_x, constants.Field.Length),
+            robocup.Point(goal_x, constants.Field.Length -
+                          OurCornerKick.TargetSegmentWidth))
         self.kicker.target = target
 
         # set centers' positions

--- a/soccer/gameplay/plays/testing/test_defense_and_kicker.py
+++ b/soccer/gameplay/plays/testing/test_defense_and_kicker.py
@@ -9,14 +9,11 @@
 
 ## Runs our Defense tactic and a pivot kicker than tries to score on our defense
 class TestDefenseAndKicker(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            "immediately")
-
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
         b = tactics.defense.Defense()

--- a/soccer/gameplay/composite_behavior.py
+++ b/soccer/gameplay/composite_behavior.py
@@ -10,58 +10,53 @@
 ## A composite behavior is one that has 0+ named subbehaviors
 # this class has methods for making it easy to work with and manage subbehaviors
 class CompositeBehavior(behavior.Behavior):
-
     def __init__(self, continuous):
         super().__init__(continuous=continuous)
 
         self._subbehavior_info = {}
 
-
     # FIXME: what if a subbehavior of @bhvr is required, but this is not?
     # FIXME: how do priorities work?
     # FIXME: how do nested priorities work?
     def add_subbehavior(self, bhvr, name, required=True, priority=100):
         if name in self._subbehavior_info:
-            raise AssertionError("There's already a subbehavior with name: '" + name + "'")
-        self._subbehavior_info[name] = {'required': required, 'priority': priority, 'behavior': bhvr}            
-
+            raise AssertionError("There's already a subbehavior with name: '" +
+                                 name + "'")
+        self._subbehavior_info[name] = {'required': required,
+                                        'priority': priority,
+                                        'behavior': bhvr}
 
     def remove_subbehavior(self, name):
         del self._subbehavior_info[name]
 
-
     def has_subbehavior_with_name(self, name):
         return name in self._subbehavior_info
 
-
     def has_subbehaviors(self):
         return len(self._subbehavior_info) > 0
 
-
     def subbehavior_with_name(self, name):
         return self._subbehavior_info[name]['behavior']
 
-
     def subbehaviors_by_name(self):
         by_name = {}
         for name in self._subbehavior_info:
             by_name[name] = self._subbehavior_info[name]['behavior']
         return by_name
 
-
     def remove_all_subbehaviors(self):
         subbehaviorNames = list(self._subbehavior_info.keys())
         for name in subbehaviorNames:
             self.remove_subbehavior(name)
 
-
     ## Returns a list of all subbehaviors
     def all_subbehaviors(self):
-        return [self._subbehavior_info[name]['behavior'] for name in self._subbehavior_info]
+        return [self._subbehavior_info[name]['behavior']
+                for name in self._subbehavior_info]
 
     def all_subbehaviors_completed(self):
-        return all([bhvr.is_done_running() for bhvr in self.all_subbehaviors()])
-
+        return all([bhvr.is_done_running() for bhvr in self.all_subbehaviors()
+                    ])
 
     ## Override StateMachine.spin() so we can call spin() on subbehaviors
     def spin(self):
@@ -74,7 +69,8 @@
             # multi-robot behaviors always get spun
             # only spin single robot behaviors when they have a robot
             should_spin = True
-            if isinstance(bhvr, single_robot_behavior.SingleRobotBehavior) and bhvr.robot == None:
+            if isinstance(bhvr, single_robot_behavior.
+                          SingleRobotBehavior) and bhvr.robot == None:
                 should_spin = False
 
             # try executing the subbehavior
@@ -86,17 +82,16 @@
                     exc = sys.exc_info()[0]
                     self.handle_subbehavior_exception(name, exc)
 
-
     ## Override point for exception handling
     # this is called whenever a subbehavior throws an exception during spin()
     # subclasses of CompositeBehavior can override this to perform custom actions, such as removing the offending subbehavior
     # the default implementation logs the exception and re-raises it
     def handle_subbehavior_exception(self, name, exception):
-        logging.error("Exception occurred when spinning subbehavior named '" + name + "': " + str(exception))
+        logging.error("Exception occurred when spinning subbehavior named '" +
+                      name + "': " + str(exception))
         traceback.print_exc()
         raise
 
-
     ## returns a tree of role_requirements
     def role_requirements(self):
         reqs = {}
@@ -110,7 +105,6 @@
             reqs[name] = r
         return reqs
 
-
     # assignments is a tree with the same structure as that returned by role_requirements()
     # the only difference is that leaf nodes are (RoleRequirements, OurRobot) tuples
     # instead of just RoleRequirements
@@ -118,7 +112,6 @@
         for name, subtree in assignments.items():
             self.subbehavior_with_name(name).assign_roles(subtree)
 
-
     def __str__(self):
         desc = super().__str__()
 

--- a/soccer/gameplay/plays/restarts/our_free_kick.py
+++ b/soccer/gameplay/plays/restarts/our_free_kick.py
@@ -9,15 +9,12 @@
 
 
 class OurFreeKick(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         # FIXME: this could also be a PivotKick
         kicker = skills.line_kick.LineKick()
@@ -27,26 +24,25 @@
         kicker.target = constants.Field.TheirGoalSegment
         self.add_subbehavior(kicker, 'kicker', required=False, priority=5)
 
-
         # add two 'centers' that just move to fixed points
         center1 = skills.move.Move(robocup.Point(0, 1.5))
         self.add_subbehavior(center1, 'center1', required=False, priority=4)
         center2 = skills.move.Move(robocup.Point(0, 1.5))
         self.add_subbehavior(center1, 'center2', required=False, priority=3)
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
-
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            lambda: kicker.is_done_running(),
-            'kicker completes')
-
-
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
+
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
+            lambda: kicker.is_done_running(), 'kicker completes')
 
     @classmethod
     def score(cls):
         gs = main.game_state()
-        return 0 if gs.is_ready_state() and gs.is_our_free_kick() else float("inf")
+        return 0 if gs.is_ready_state() and gs.is_our_free_kick() else float(
+            "inf")
 
     @classmethod
     def is_restart(cls):
@@ -55,5 +51,3 @@
     @classmethod
     def handles_goalie(cls):
         return True
-
-    
\ No newline at end of file

--- a/soccer/gameplay/plays/restarts/our_kickoff.py
+++ b/soccer/gameplay/plays/restarts/our_kickoff.py
@@ -14,7 +14,6 @@
     KickPower = 0.5
     ChipPower = 1.0
 
-
     class State(enum.Enum):
         setup = 1
         kick = 2
@@ -28,21 +27,18 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            OurKickoff.State.setup,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(OurKickoff.State.setup,
-            OurKickoff.State.kick,
-            lambda: not main.game_state().is_setup_state(),
-            "referee leaves setup")
+                            OurKickoff.State.setup, lambda: True,
+                            'immediately')
+
+        self.add_transition(OurKickoff.State.setup, OurKickoff.State.kick,
+                            lambda: not main.game_state().is_setup_state(),
+                            "referee leaves setup")
 
-        self.add_transition(OurKickoff.State.kick,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            OurKickoff.State.kick, behavior.Behavior.State.completed,
             lambda: self.has_subbehavior_with_name('kicker') and self.subbehavior_with_name('kicker').is_done_running(),
             "kicker finished")
 
-
         # TODO: verify that these values are right - I'm fuzzy on my matrix multiplication...
         idle_positions = [
             robocup.Point(0.7, constants.Field.Length / 2.0 - 0.2),
@@ -51,13 +47,15 @@
         self.centers = []
         for i, pos_i in enumerate(idle_positions):
             center_i = skills.move.Move(pos_i)
-            self.add_subbehavior(center_i, 'center' + str(i), required=False, priority=4-i)
+            self.add_subbehavior(center_i,
+                                 'center' + str(i),
+                                 required=False,
+                                 priority=4 - i)
             self.centers.append(center_i)
 
-
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
-
-
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
     @classmethod
     def score(cls):
@@ -72,9 +70,9 @@
     def handles_goalie(cls):
         return True
 
-
     def on_enter_setup(self):
-        mover = skills.move.Move(robocup.Point(0, constants.Field.Length / 2.0 - 0.30))
+        mover = skills.move.Move(robocup.Point(0, constants.Field.Length / 2.0
+                                               - 0.30))
         self.add_subbehavior(mover, 'move', required=False, priority=5)
 
     def execute_setup(self):
@@ -84,7 +82,8 @@
 
     def on_enter_kick(self):
         if self.subbehavior_with_name('move').robot is not None:
-            self._kicker_shell_id = self.subbehavior_with_name('move').robot.shell_id()
+            self._kicker_shell_id = self.subbehavior_with_name(
+                'move').robot.shell_id()
         self.remove_subbehavior('move')
         kicker = skills.line_kick.LineKick()
         kicker.target = constants.Field.TheirGoalSegment
@@ -102,9 +101,11 @@
     def role_requirements(self):
         reqs = super().role_requirements()
         if 'move' in reqs:
-            for r in role_assignment.iterate_role_requirements_tree_leaves(reqs['move']):
+            for r in role_assignment.iterate_role_requirements_tree_leaves(
+                    reqs['move']):
                 r.chipper_preference_weight = role_assignment.PreferChipper
         if 'kicker' in reqs:
-            for r in role_assignment.iterate_role_requirements_tree_leaves(reqs['kicker']):
+            for r in role_assignment.iterate_role_requirements_tree_leaves(
+                    reqs['kicker']):
                 r.previous_shell_id = self._kicker_shell_id
         return reqs

--- a/soccer/gameplay/plays/offense/basic_122.py
+++ b/soccer/gameplay/plays/offense/basic_122.py
@@ -8,6 +8,7 @@
 import constants
 import math
 
+
 class Basic122(play.Play):
 
     # how far the 2 support robots should stay away from the striker
@@ -22,8 +23,6 @@
     # multiplier used to decide when it's worth it to reassign the bot a support is marking
     MarkHysteresisCoeff = 0.9
 
-
-
     def __init__(self):
         super().__init__(continuous=False)  # FIXME: continuous?
 
@@ -34,14 +33,12 @@
         striker.aim_params['desperate_timeout'] = 2.5
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            "immediately")
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
         striker.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.start,
-            lambda: True,
-            "immediately")
+                               behavior.Behavior.State.start, lambda: True,
+                               "immediately")
         self.add_subbehavior(striker, 'striker', required=False, priority=3)
 
         support1 = skills.mark.Mark()
@@ -52,7 +49,9 @@
         support2.mark_line_thresh = 1.0
         self.add_subbehavior(support2, 'support2', required=False, priority=1)
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
     @classmethod
     def score(cls):
@@ -68,10 +67,10 @@
         support2 = self.subbehavior_with_name('support2')
         supports = [support1, support2]
 
-
         # project ball location a bit into the future
-        ball_proj = evaluation.ball.predict(main.ball().pos, main.ball().vel, t=0.75)
-
+        ball_proj = evaluation.ball.predict(main.ball().pos,
+                                            main.ball().vel,
+                                            t=0.75)
 
         # find closest opponent to striker
         closest_dist_to_striker, closest_opp_to_striker = float("inf"), None
@@ -83,7 +82,6 @@
 
         striker_engaged = striker.robot != None and closest_dist_to_striker < Basic122.SupportBackoffThresh
 
-
         # pick out which opponents our defenders should 'mark'
         # TODO: explain
         nrOppClose = 0
@@ -102,22 +100,25 @@
                 if oppDistSq < constants.Field.Length**2 / 4.0:
                     nrOppClose += 1
 
-
         # handle the case of having no good robots to mark
         if bestOpp1 == None and support1.robot != None:
             support1.mark_robot = None
-            support1.robot.add_text("No mark target", (255,255,255), "RobotText")
+            support1.robot.add_text("No mark target",
+                                    (255, 255, 255), "RobotText")
             if striker.robot != None:
-                support1.robot.add_text("Static Support", (255,255,255), "RobotText")
+                support1.robot.add_text("Static Support",
+                                        (255, 255, 255), "RobotText")
                 support_goal = striker.robot.pos
                 support_goal.x *= -1.0
                 if abs(support_goal.x) < 0.2:
                     support_goal.x = -1.0 if support_goal.x < 0 else 1.0
 
                 if ball_proj.y > constants.Field.Length / 2.0 and nrOppClose > 0:
-                    support_goal.y = max(support_goal.y * Basic122.OffenseSupportRatio, 0.3)
+                    support_goal.y = max(support_goal.y *
+                                         Basic122.OffenseSupportRatio, 0.3)
                 else:
-                    support_goal.y = max(support_goal.y * Basic122.DefenseSupportRatio, 0.3)
+                    support_goal.y = max(support_goal.y *
+                                         Basic122.DefenseSupportRatio, 0.3)
 
                 support1.robot.move_to(support_goal)
                 support1.robot.face(ball_proj)
@@ -126,18 +127,22 @@
         # TODO: make it do something useful
         if bestOpp2 == None and support2.robot != None:
             support2.mark_robot = None
-            support2.robot.add_text("No mark target", (255,255,255), "RobotText")
+            support2.robot.add_text("No mark target",
+                                    (255, 255, 255), "RobotText")
             if striker.robot != None:
-                support2.robot.add_text("Static Support", (255,255,255), "RobotText")
+                support2.robot.add_text("Static Support",
+                                        (255, 255, 255), "RobotText")
                 support_goal = striker.robot.pos
                 support_goal.x *= -1.0
                 if abs(support_goal.x) < 0.2:
                     support_goal.x = -1.0 if support_goal.x < 0 else 1.0
 
                 if ball_proj.y > constants.Field.Length / 2.0 and nrOppClose > 0:
-                    support_goal.y = max(support_goal.y * Basic122.OffenseSupportRatio, 0.3)
+                    support_goal.y = max(support_goal.y *
+                                         Basic122.OffenseSupportRatio, 0.3)
                 else:
-                    support_goal.y = max(support_goal.y * Basic122.DefenseSupportRatio, 0.3)
+                    support_goal.y = max(support_goal.y *
+                                         Basic122.DefenseSupportRatio, 0.3)
 
                 support2.robot.move_to(support_goal)
                 support2.robot.face(ball_proj)
@@ -148,23 +153,27 @@
         for i in range(2):
             support = supports[i]
             if new_bots[i] != None:
-                cur_dist_sq = (support.mark_robot.pos - ball_proj).magsq() if support.mark_robot else float("inf")
+                cur_dist_sq = (
+                    support.mark_robot.pos -
+                    ball_proj).magsq() if support.mark_robot else float("inf")
                 if new_dists[i] < cur_dist_sq * Basic122.MarkHysteresisCoeff:
                     support.mark_robot = new_bots[i]
 
-
         # if the supports are farther from the ball, they can mark further away
         if ball_proj.y > constants.Field.Length / 2.0 and nrOppClose > 0:
-            for support in supports: support.ratio = Basic122.OffenseSupportRatio
+            for support in supports:
+                support.ratio = Basic122.OffenseSupportRatio
         else:
-            for support in supports: support.ratio = Basic122.DefenseSupportRatio
-
+            for support in supports:
+                support.ratio = Basic122.DefenseSupportRatio
 
         # keep support robots away from the striker
         if striker.robot != None:
             for supp in [support1, support2]:
                 if supp.robot != None:
-                    supp.robot.set_avoid_teammate_radius(striker.robot.shell_id(), Basic122.SupportAvoidTeammateRadius)
+                    supp.robot.set_avoid_teammate_radius(
+                        striker.robot.shell_id(),
+                        Basic122.SupportAvoidTeammateRadius)
 
             # raise NotImplementedError("Make support robots avoid the shot channel")
             # FROM C++:
@@ -173,8 +182,7 @@
             # shot_obs.vertices.push_back(Geometry2d::Point(-Field_GoalWidth / 2, Field_Length));
             # shot_obs.vertices.push_back(ballProj);
 
-
-        # TODO: this would be a good place for a "keep-trying container behavior"
-        # make the kicker try again if it already kicked
+            # TODO: this would be a good place for a "keep-trying container behavior"
+            # make the kicker try again if it already kicked
         if not striker.is_in_state(behavior.Behavior.State.running):
             striker.restart()

--- a/soccer/gameplay/plays/testing/test_fullback.py
+++ b/soccer/gameplay/plays/testing/test_fullback.py
@@ -4,14 +4,17 @@
 import robocup
 import main
 
-class TestDefender(play.Play):
 
+class TestDefender(play.Play):
     def __init__(self):
         super().__init__(continuous=True)
-        self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
-        b = tactics.positions.defender.Defender(tactics.positions.defender.Defender.Side.left)
+        b = tactics.positions.defender.Defender(
+            tactics.positions.defender.Defender.Side.left)
         self.add_subbehavior(b, name='defender', required=True)
 
     def on_exit_running(self):

--- a/soccer/gameplay/plays/testing/repeated_line_up.py
+++ b/soccer/gameplay/plays/testing/repeated_line_up.py
@@ -12,13 +12,11 @@
 
     Pause = 2.0
 
-
     class State(enum.Enum):
         left = 0
         right = 1
         pause = 2
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
@@ -28,40 +26,42 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            RepeatedLineUp.State.right,
-            lambda: True,
-            'immediately')
+                            RepeatedLineUp.State.right, lambda: True,
+                            'immediately')
 
-        self.add_transition(RepeatedLineUp.State.left,
-            RepeatedLineUp.State.pause,
+        self.add_transition(
+            RepeatedLineUp.State.left, RepeatedLineUp.State.pause,
             lambda: self.subbehavior_with_name('LineUp').state == behavior.Behavior.State.completed and time.time() - self.side_start > 1,
             'made it to left')
 
-        self.add_transition(RepeatedLineUp.State.right,
-            RepeatedLineUp.State.pause,
+        self.add_transition(
+            RepeatedLineUp.State.right, RepeatedLineUp.State.pause,
             lambda: self.subbehavior_with_name('LineUp').state == behavior.Behavior.State.completed and time.time() - self.side_start > 1,
             'made it to right')
 
-        self.add_transition(RepeatedLineUp.State.pause,
-            RepeatedLineUp.State.right,
+        self.add_transition(
+            RepeatedLineUp.State.pause, RepeatedLineUp.State.right,
             lambda: (time.time() - self.pause_start_time) > RepeatedLineUp.Pause and self.prev_side == RepeatedLineUp.State.left,
             'pause over')
-        self.add_transition(RepeatedLineUp.State.pause,
-            RepeatedLineUp.State.left,
+        self.add_transition(
+            RepeatedLineUp.State.pause, RepeatedLineUp.State.left,
             lambda: (time.time() - self.pause_start_time) > RepeatedLineUp.Pause and self.prev_side == RepeatedLineUp.State.right,
             'pause over')
 
-
     def on_enter_left(self):
         self.side_start = time.time()
-        self.add_subbehavior(tactics.line_up.LineUp(self.generate_line(-1)), 'LineUp')
+        self.add_subbehavior(
+            tactics.line_up.LineUp(self.generate_line(-1)), 'LineUp')
+
     def on_exit_left(self):
         self.remove_subbehavior('LineUp')
         self.prev_side = RepeatedLineUp.State.left
 
     def on_enter_right(self):
         self.side_start = time.time()
-        self.add_subbehavior(tactics.line_up.LineUp(self.generate_line(1)), 'LineUp')
+        self.add_subbehavior(
+            tactics.line_up.LineUp(self.generate_line(1)), 'LineUp')
+
     def on_exit_right(self):
         self.remove_subbehavior('LineUp')
         self.prev_side = RepeatedLineUp.State.right
@@ -69,13 +69,14 @@
     def on_enter_pause(self):
         self.pause_start_time = time.time()
 
-
     # x_multiplier is a 1 or -1 to indicate which side of the field to be on
     # 1 is right, -1 is left
     def generate_line(self, x_multiplier):
-        x = (constants.Field.Width/2 - constants.Robot.Radius*2) * x_multiplier
+        x = (constants.Field.Width / 2 - constants.Robot.Radius *
+             2) * x_multiplier
         y_start = 1.0
         line = robocup.Segment(
-                robocup.Point(x, constants.Robot.Radius + y_start),
-                robocup.Point(x, (constants.Robot.Radius * 2.3 + 0.1)*6 + y_start))
+            robocup.Point(x, constants.Robot.Radius + y_start),
+            robocup.Point(x,
+                          (constants.Robot.Radius * 2.3 + 0.1) * 6 + y_start))
         return line

--- a/soccer/gameplay/plays/restarts/two_side_corner_kick.py
+++ b/soccer/gameplay/plays/restarts/two_side_corner_kick.py
@@ -10,6 +10,7 @@
 import tactics.coordinated_pass
 import tactics.defense
 
+
 class TwoSideCornerKick(play.Play):
     # Try to pass to the better target
     # Soccer/gameplay/evaluation/shot.py
@@ -22,75 +23,82 @@
         ## Pick best target, add coordinated pass subbehavior
         passing = 2
         ## Pivot kick (by default attacks enemy goal)
-        kicking = 3;
+        kicking = 3
 
     def __init__(self):
         super().__init__(continuous=False)
 
         self.add_state(TwoSideCornerKick.State.setup,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
         self.add_state(TwoSideCornerKick.State.passing,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
         self.add_state(TwoSideCornerKick.State.kicking,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
 
         # Add transitions
         self.add_transition(behavior.Behavior.State.start,
-            TwoSideCornerKick.State.setup,
-            lambda: True,
-            'immediately')
-        self.add_transition(TwoSideCornerKick.State.setup,
-            TwoSideCornerKick.State.passing,
+                            TwoSideCornerKick.State.setup, lambda: True,
+                            'immediately')
+        self.add_transition(
+            TwoSideCornerKick.State.setup, TwoSideCornerKick.State.passing,
             lambda: self.subbehavior_with_name('capture').is_done_running(),
             'all subbehaviors completed')
 
-        self.add_transition(TwoSideCornerKick.State.passing,
-            TwoSideCornerKick.State.kicking,
+        self.add_transition(
+            TwoSideCornerKick.State.passing, TwoSideCornerKick.State.kicking,
             lambda: self.kick_directly == True or self.all_subbehaviors_completed(),
             'all subbehaviors completed')
 
-        self.add_transition(TwoSideCornerKick.State.kicking,
-            behavior.Behavior.State.completed,
-            lambda: self.kick_directly == True,
-            'all subbehaviors completed')
+        self.add_transition(
+            TwoSideCornerKick.State.kicking, behavior.Behavior.State.completed,
+            lambda: self.kick_directly == True, 'all subbehaviors completed')
 
         self.add_transition(TwoSideCornerKick.State.kicking,
-            behavior.Behavior.State.completed,
-            lambda: self.all_subbehaviors_completed(),
-            'all subbehaviors completed')
+                            behavior.Behavior.State.completed,
+                            lambda: self.all_subbehaviors_completed(),
+                            'all subbehaviors completed')
 
         self.robot_points = [
-            robocup.Point(-constants.Field.Width / 4.0, 3 * constants.Field.Length / 4.0),
-            robocup.Point(constants.Field.Width / 4.0, 3 * constants.Field.Length / 4.0)
+            robocup.Point(-constants.Field.Width / 4.0, 3 *
+                          constants.Field.Length / 4.0),
+            robocup.Point(constants.Field.Width / 4.0, 3 *
+                          constants.Field.Length / 4.0)
         ]
         self.kick_directly = False
         self.passRobot1 = None
         self.passRobot2 = None
         self.captureRobot = None
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
     @classmethod
     def score(cls):
         gs = main.game_state()
-        if gs.is_ready_state() and gs.is_our_direct() and  main.ball().pos.y > ( constants.Field.Length - 1.0 ):
+        if gs.is_ready_state() and gs.is_our_direct() and main.ball().pos.y > (
+                constants.Field.Length - 1.0):
             return 1
         else:
             return float("inf")
 
     @classmethod
     def is_restart(cls):
-        return True;
-
+        return True
 
     def on_enter_setup(self):
         # Add subbehaviors based on information
         capture = skills.capture.Capture()
-        self.add_subbehavior(skills.move.Move(self.robot_points[0]), 'moveA', required=True)
-        self.add_subbehavior(skills.move.Move(self.robot_points[1]), 'moveB', required=True)
+        self.add_subbehavior(
+            skills.move.Move(self.robot_points[0]),
+            'moveA',
+            required=True)
+        self.add_subbehavior(
+            skills.move.Move(self.robot_points[1]),
+            'moveB',
+            required=True)
         self.add_subbehavior(capture, 'capture', required=True)
 
-
     def on_exit_setup(self):
         self.passRobot1 = self.subbehavior_with_name('moveA').robot
         self.passRobot2 = self.subbehavior_with_name('moveB').robot
@@ -98,7 +106,6 @@
         self.to_exclude = [self.passRobot1, self.passRobot2, self.captureRobot]
         self.remove_all_subbehaviors()
 
-
     def on_enter_passing(self):
         #capture = self.subbehavior_with_name('capture')
         #passRobot1 = self.subbehavior_with_name('moveA')
@@ -111,13 +118,15 @@
             win_eval.add_excluded_robot(r)
 
         _, rob_1_best_shot = win_eval.eval_pt_to_opp_goal(self.passRobot1.pos)
-        _, rob_1_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos, self.passRobot1.pos, 0.3)
+        _, rob_1_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos,
+                                                    self.passRobot1.pos, 0.3)
         rob_1_chance = 0
         if (rob_1_best_shot and rob_1_best_pass):
             rob_1_chance = rob_1_best_pass.shot_success * rob_1_best_shot.shot_success
 
         _, rob_2_best_shot = win_eval.eval_pt_to_opp_goal(self.passRobot2.pos)
-        _, rob_2_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos, self.passRobot2.pos, 0.3)
+        _, rob_2_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos,
+                                                    self.passRobot2.pos, 0.3)
         rob_2_chance = 0
         if (rob_2_best_shot and rob_2_best_pass):
             rob_2_chance = rob_2_best_pass.shot_success * rob_2_best_shot.shot_success
@@ -127,33 +136,34 @@
         direct_success = 0
         if direct_shot:
             if (self.captureRobot.pos.y < 4):
-                direct_success = direct_shot.shot_success*0.7
+                direct_success = direct_shot.shot_success * 0.7
             else:
                 direct_success = direct_shot.shot_success
 
-            if (direct_shot and direct_success > rob_1_chance and direct_success > rob_2_chance):
+            if (direct_shot and direct_success > rob_1_chance and
+                    direct_success > rob_2_chance):
                 self.kick_directly = True
-                return 
+                return
 
         if rob_1_chance > rob_2_chance:
-            self.add_subbehavior(tactics.coordinated_pass.CoordinatedPass(self.passRobot1.pos), 'pass')
+            self.add_subbehavior(
+                tactics.coordinated_pass.CoordinatedPass(self.passRobot1.pos),
+                'pass')
         else:
-            self.add_subbehavior(tactics.coordinated_pass.CoordinatedPass(self.passRobot2.pos), 'pass')
-
-
+            self.add_subbehavior(
+                tactics.coordinated_pass.CoordinatedPass(self.passRobot2.pos),
+                'pass')
 
     def on_exit_passing(self):
         self.kick_directly = False
         self.remove_all_subbehaviors()
 
-
     def on_enter_kicking(self):
         kick = skills.pivot_kick.PivotKick()
         kick.target = constants.Field.TheirGoalSegment
         kick.aim_params['desperate_timeout'] = 3
         self.add_subbehavior(kick, 'kick', required=False)
 
-
     def on_exit_kicking(self):
         self.remove_all_subbehaviors()
 

--- a/soccer/gameplay/plays/testing/test_idle.py
+++ b/soccer/gameplay/plays/testing/test_idle.py
@@ -4,14 +4,18 @@
 import robocup
 import main
 
-class TestIdle(play.Play):
 
+class TestIdle(play.Play):
     def __init__(self):
         super().__init__(continuous=True)
-        self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
-    	self.add_subbehavior(tactics.circle_near_ball.CircleNearBall(), name='circle', required=True)
+        self.add_subbehavior(tactics.circle_near_ball.CircleNearBall(),
+                             name='circle',
+                             required=True)
 
     def on_exit_running(self):
         self.remove_subbehavior('circle')

--- a/soccer/gameplay/plays/testing/test_one_touch_pass.py
+++ b/soccer/gameplay/plays/testing/test_one_touch_pass.py
@@ -9,14 +9,12 @@
 
 ## Continually runs a one_touch_pass pass tactic
 class TestOneTouchPass(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         pass_bhvr = tactics.one_touch_pass.OneTouchPass()
         self.add_subbehavior(pass_bhvr, 'pass')
@@ -26,4 +24,3 @@
 
         if pass_bhvr.is_done_running():
             pass_bhvr.restart()
-

--- a/soccer/gameplay/plays/restarts/their_kickoff.py
+++ b/soccer/gameplay/plays/restarts/their_kickoff.py
@@ -7,26 +7,25 @@
 
 
 class TheirKickoff(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
         circle_up = tactics.stopped.circle_near_ball.CircleNearBall()
         self.add_subbehavior(circle_up, 'circle_up')
 
-
     @classmethod
     def score(cls):
         gs = main.game_state()
-        return 0 if gs.is_setup_state() and gs.is_their_kickoff() else float("inf")
+        return 0 if gs.is_setup_state() and gs.is_their_kickoff() else float(
+            "inf")
 
     @classmethod
     def is_restart(cls):

--- a/soccer/gameplay/plays/testing/test_intercept.py
+++ b/soccer/gameplay/plays/testing/test_intercept.py
@@ -6,13 +6,16 @@
 
 
 class TestIntercept(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
-        self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
-    	self.add_subbehavior(skills.intercept.Intercept(), name='intercept', required=True)
+        self.add_subbehavior(skills.intercept.Intercept(),
+                             name='intercept',
+                             required=True)
 
     def on_exit_running(self):
         self.remove_subbehavior('intercept')

--- a/soccer/gameplay/plays/testing/test_pivot_kick.py
+++ b/soccer/gameplay/plays/testing/test_pivot_kick.py
@@ -10,21 +10,18 @@
 
 # this test repeatedly runs the PivotKick behavior aimed at our goal
 class TestPivotKick(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         kick = skills.pivot_kick.PivotKick()
         kick.target = constants.Field.OurGoalSegment
         kick.aim_params['desperate_timeout'] = 3
         self.add_subbehavior(kick, 'kick', required=False)
 
-
     def execute_running(self):
         kick = self.subbehavior_with_name('kick')
         if kick.is_done_running():

--- a/soccer/gameplay/plays/tuning/tune_facing.py
+++ b/soccer/gameplay/plays/tuning/tune_facing.py
@@ -10,12 +10,10 @@
 
 
 class Facer(single_robot_composite_behavior.SingleRobotCompositeBehavior):
-
     class State(enum.Enum):
         rotating = 1
         pausing = 2
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
@@ -26,39 +24,36 @@
         self.point = robocup.Point(0, constants.Field.Length / 4.0)
 
         self.add_transition(behavior.Behavior.State.start,
-            Facer.State.rotating,
-            lambda: True,
-            'immediately')
-        self.add_transition(Facer.State.rotating,
-            Facer.State.pausing,
+                            Facer.State.rotating, lambda: True, 'immediately')
+        self.add_transition(
+            Facer.State.rotating, Facer.State.pausing,
             lambda: self.subbehavior_with_name('rotate').state == behavior.Behavior.State.completed,
             'rotated to appropriate angle')
-        self.add_transition(Facer.State.pausing,
-            Facer.State.rotating,
-            lambda: self.done_pausing(),
-            'done pausing')
-
+        self.add_transition(Facer.State.pausing, Facer.State.rotating,
+                            lambda: self.done_pausing(), 'done pausing')
 
     @property
     def angle(self):
         return self._angle
+
     @angle.setter
     def angle(self, value):
         self._angle = value
-    
 
     # where the robot sits on the field as it rotates
     # Default: center of our half of the field
     @property
     def point(self):
         return self._point
+
     @point.setter
     def point(self, value):
         self._point = value
 
-
     def on_enter_rotating(self):
-        self.add_subbehavior(skills.face.Face(self.point, self.angle), 'rotate')
+        self.add_subbehavior(
+            skills.face.Face(self.point, self.angle), 'rotate')
+
     def on_exit_rotating(self):
         self.remove_subbehavior('rotate')
         self.angle += math.pi / 2
@@ -66,6 +61,7 @@
     def on_enter_pausing(self):
         self.add_subbehavior(skills.move.Move(self.point), 'hold')
         self.pause_start_time = time.time()
+
     def on_exit_pausing(self):
         self.remove_subbehavior('hold')
 
@@ -73,7 +69,6 @@
         return (time.time() - self.pause_start_time) > 1.5
 
 
-
 ## This play rotates the bot 90 degrees, pauses, and repeats
 # It's useful for tuning the angle PID controller
 class TuneFacing(play.Play):

--- a/soccer/gameplay/plays/stopped.py
+++ b/soccer/gameplay/plays/stopped.py
@@ -12,10 +12,9 @@
 ## When we get the Stopped command from the referee, we run this play.
 # See the rules to see what we're allowed to do while the game is stopped
 class Stopped(play.Play):
-
     class State(enum.Enum):
-        normal = 1   # Normal
-        center = 2   # Ball is in the center
+        normal = 1  # Normal
+        center = 2  # Ball is in the center
 
     def __init__(self):
         super().__init__(continuous=True)
@@ -24,44 +23,43 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            Stopped.State.normal,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(Stopped.State.normal,
-            Stopped.State.center,
-            lambda: self.is_in_center(),
-            'Switched into center mode')
-
-        self.add_transition(Stopped.State.center,
-            Stopped.State.normal,
-            lambda: not self.is_in_center(),
-            'Switched into normal mode')
+                            Stopped.State.normal, lambda: True, 'immediately')
 
+        self.add_transition(Stopped.State.normal, Stopped.State.center,
+                            lambda: self.is_in_center(),
+                            'Switched into center mode')
+
+        self.add_transition(Stopped.State.center, Stopped.State.normal,
+                            lambda: not self.is_in_center(),
+                            'Switched into normal mode')
 
     @classmethod
     def score(cls):
         return 0 if main.game_state().is_stopped() else float("inf")
 
-
     @classmethod
     def handles_goalie(self):
         return True
 
     def is_in_center(self):
         if main.ball().valid:
-            return robocup.Circle(constants.Field.CenterPoint, constants.Field.CenterRadius).contains_point(main.ball().pos)
+            return robocup.Circle(
+                constants.Field.CenterPoint,
+                constants.Field.CenterRadius).contains_point(main.ball().pos)
         return False
 
     def on_enter_normal(self):
         self.remove_all_subbehaviors()
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
         idle = tactics.stopped.circle_near_ball.CircleNearBall()
         self.add_subbehavior(idle, 'circle_up', required=False, priority=1)
 
     def on_enter_center(self):
         self.remove_all_subbehaviors()
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
         idle = tactics.stopped.circle_on_center.CircleOnCenter()
         self.add_subbehavior(idle, 'circle_up', required=False, priority=1)
-

--- a/soccer/gameplay/plays/testing/test_line_kick.py
+++ b/soccer/gameplay/plays/testing/test_line_kick.py
@@ -7,14 +7,12 @@
 
 
 class TestLineKick(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         kick = skills.line_kick.LineKick()
         kick.target = constants.Field.OurGoalSegment
@@ -24,4 +22,3 @@
         kick = self.subbehavior_with_name('kick')
         if kick.is_done_running():
             kick.restart()
-

--- a/firmware/robot/cpu/tools/rc_radio.py
+++ b/firmware/robot/cpu/tools/rc_radio.py
@@ -4,69 +4,79 @@
 
 device = None
 for bus in busses():
-	for dev in bus.devices:
-		if dev.idVendor == 0x3141 and dev.idProduct == 0x0004:
-			device = dev.open()
-			break
+    for dev in bus.devices:
+        if dev.idVendor == 0x3141 and dev.idProduct == 0x0004:
+            device = dev.open()
+            break
 assert device
 
 device.setConfiguration(1)
 device.claimInterface(0)
 
+
 def autoCalibrate(enabled):
-	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 4, None, enabled, 0)
+    device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 4, None, enabled, 0)
+
 
 cc1101_regs = (
-    (0x0b, 0x0c),    # FSCTRL1  - Frequency synthesizer control.
-    (0x0d, 0x21),    # FREQ2    - Frequency control word, high byte.
-    (0x0e, 0x7b),    # FREQ1    - Frequency control word, middle byte.
-    (0x0f, 0x42),    # FREQ0    - Frequency control word, low byte.
-    (0x10, 0x2d),    # MDMCFG4  - Modem configuration.
-    (0x11, 0x2f),    # MDMCFG3  - Modem configuration.
-    (0x12, 0x13),    # MDMCFG2  - Modem configuration.
-    (0x13, 0x22),    # MDMCFG1  - Modem configuration.
-    (0x14, 0xe5),    # MDMCFG0  - Modem configuration.
-    (0x0a, 0x00),    # CHANNR   - Channel number.
-    (0x15, 0x62),    # DEVIATN  - Modem deviation setting (when FSK modulation is enabled).
-    (0x21, 0xb6),    # FREND1   - Front end RX configuration.
-    (0x22, 0x10),    # FREND0   - Front end RX configuration.
-    (0x18, 0x08),    # MCSM0    - Main Radio Control State Machine configuration.
-    (0x17, 0x00),    # MCSM1    - Main Radio Control State Machine configuration.
-    (0x19, 0x5d),    # FOCCFG   - Frequency Offset Compensation Configuration.
-    (0x1a, 0x1c),    # BSCFG    - Bit synchronization Configuration.
-    (0x1b, 0xc7),    # AGCCTRL2 - AGC control.
-    (0x1c, 0x00),    # AGCCTRL1 - AGC control.
-    (0x1d, 0xb0),    # AGCCTRL0 - AGC control.
-    (0x03, 0x0f),    # FIFOTHR  - RXFIFO and TXFIFO thresholds.
-    (0x07, 0x4c),    # PKTCTRL1 - Packet automation control.
-    (0x08, 0x05),    # PKTCTRL0 - Packet automation control.
-    (0x06, 0x3e)     # PKTLEN   - Packet length.
+    (0x0b, 0x0c),  # FSCTRL1  - Frequency synthesizer control.
+    (0x0d, 0x21),  # FREQ2    - Frequency control word, high byte.
+    (0x0e, 0x7b),  # FREQ1    - Frequency control word, middle byte.
+    (0x0f, 0x42),  # FREQ0    - Frequency control word, low byte.
+    (0x10, 0x2d),  # MDMCFG4  - Modem configuration.
+    (0x11, 0x2f),  # MDMCFG3  - Modem configuration.
+    (0x12, 0x13),  # MDMCFG2  - Modem configuration.
+    (0x13, 0x22),  # MDMCFG1  - Modem configuration.
+    (0x14, 0xe5),  # MDMCFG0  - Modem configuration.
+    (0x0a, 0x00),  # CHANNR   - Channel number.
+    (0x15, 0x62
+     ),  # DEVIATN  - Modem deviation setting (when FSK modulation is enabled).
+    (0x21, 0xb6),  # FREND1   - Front end RX configuration.
+    (0x22, 0x10),  # FREND0   - Front end RX configuration.
+    (0x18, 0x08),  # MCSM0    - Main Radio Control State Machine configuration.
+    (0x17, 0x00),  # MCSM1    - Main Radio Control State Machine configuration.
+    (0x19, 0x5d),  # FOCCFG   - Frequency Offset Compensation Configuration.
+    (0x1a, 0x1c),  # BSCFG    - Bit synchronization Configuration.
+    (0x1b, 0xc7),  # AGCCTRL2 - AGC control.
+    (0x1c, 0x00),  # AGCCTRL1 - AGC control.
+    (0x1d, 0xb0),  # AGCCTRL0 - AGC control.
+    (0x03, 0x0f),  # FIFOTHR  - RXFIFO and TXFIFO thresholds.
+    (0x07, 0x4c),  # PKTCTRL1 - Packet automation control.
+    (0x08, 0x05),  # PKTCTRL0 - Packet automation control.
+    (0x06, 0x3e)  # PKTLEN   - Packet length.
 )
 
+
 def command(value):
-	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 2, None, 0, value)
+    device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 2, None, 0, value)
+
 
 def writeRegister(addr, value):
-	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 1, None, value, addr)
+    device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 1, None, value, addr)
+
 
 def configure():
-	autoCalibrate(False)
-	for (addr, value) in cc1101_regs:
-		writeRegister(addr, value)
-	autoCalibrate(True)
+    autoCalibrate(False)
+    for (addr, value) in cc1101_regs:
+        writeRegister(addr, value)
+    autoCalibrate(True)
+
 
 def channel(n):
-	writeRegister(0x0a, n)
+    writeRegister(0x0a, n)
+
 
 def send(buf):
-	device.bulkWrite(1, buf)
+    device.bulkWrite(1, buf)
+
 
 def receive():
-	try:
-		buf = device.bulkRead(2, 64, 100)
-	except USBError:
-		# Timeout
-		return None
-	return buf[:-2]
+    try:
+        buf = device.bulkRead(2, 64, 100)
+    except USBError:
+        # Timeout
+        return None
+    return buf[:-2]
+
 
 configure()

--- a/soccer/gameplay/plays/testing/debug_window_evaluator.py
+++ b/soccer/gameplay/plays/testing/debug_window_evaluator.py
@@ -6,18 +6,16 @@
 import time
 import math
 
+
 ## This isn't a real play, but it's pretty useful
 # Turn it on and we'll draw the window evaluator stuff on-screen from the ball to our goal
 class DebugWindowEvaluator(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
     def execute_running(self):
         win_eval = robocup.WindowEvaluator(main.system_state())

--- a/soccer/gameplay/plays/restarts/their_restart.py
+++ b/soccer/gameplay/plays/restarts/their_restart.py
@@ -6,30 +6,33 @@
 
 
 class TheirRestart(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False,)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False, )
 
         self.marks = []
         for i in range(3):
             mark_i = skills.mark.Mark()
             mark_i.ratio = 0.7
-            self.add_subbehavior(mark_i, 'mark' + str(i), required=False, priority=3 - i)
+            self.add_subbehavior(mark_i,
+                                 'mark' + str(i),
+                                 required=False,
+                                 priority=3 - i)
             self.marks.append(mark_i)
 
-
     @classmethod
     def score(cls):
         gs = main.game_state()
-        return 0 if gs.is_ready_state() and ( gs.is_their_free_kick() or gs.is_their_indirect() or gs.is_their_direct()) else float("inf")
+        return 0 if gs.is_ready_state() and (
+            gs.is_their_free_kick() or gs.is_their_indirect() or
+            gs.is_their_direct()) else float("inf")
 
     @classmethod
     def is_restart(cls):
@@ -39,19 +42,16 @@
     def handles_goalie(cls):
         return True
 
-
     def execute_running(self):
         # abort if we can't see the ball
         if not main.ball().valid:
             return
 
-
         ball_pos = main.ball().pos
 
-
         # the closest of their bots to the ball is their kicker
-        their_kicker = min(main.their_robots(), key=lambda opp: opp.pos.dist_to(ball_pos))
-
+        their_kicker = min(main.their_robots(),
+                           key=lambda opp: opp.pos.dist_to(ball_pos))
 
         # we build an array of (OpponentRobot, float distToClosestOfOurBots) tuples
         # we'll use these in a sec to assign our marking robots
@@ -66,9 +66,9 @@
             # if it is, we record the closest distance from one of our robots to it
             if ball_dist < 3.0:
                 # which of our robots is closest to this opponent
-                closest_self_dist = min([bot.pos.dist_to(opp.pos) for bot in main.our_robots()])
-                open_opps_and_dists.append( (opp, closest_self_dist) )
-
+                closest_self_dist = min([bot.pos.dist_to(opp.pos)
+                                         for bot in main.our_robots()])
+                open_opps_and_dists.append((opp, closest_self_dist))
 
         # Decide what each marking robot should do
         # @open_opps contains the robots we want to mark (if any)
@@ -86,14 +86,14 @@
                     # # move towards the ball and face it, but don't get within field center's radius
                     # pos = mark_i.robot.pos
                     # target = pos + (ball_pos - pos).normalized() * (ball_pos.dist_to(pos) - constants.Field.CenterRadius)
-                    
+
                     # mark_i.robot.move(target)
                     # mark_i.face(ball_pos)
 
-
-        # tell the marking robots to avoid eachother more than normal
+                    # tell the marking robots to avoid eachother more than normal
         for i, mark_i in enumerate(self.marks):
             for j, mark_j in enumerate(self.marks):
                 if i == j: continue
                 if mark_i.robot != None and mark_j.robot != None:
-                    mark_i.robot.set_avoid_teammate_radius(mark_j.robot.shell_id(), 0.5)
+                    mark_i.robot.set_avoid_teammate_radius(
+                        mark_j.robot.shell_id(), 0.5)

--- a/soccer/gameplay/plays/tuning/tune_pivot.py
+++ b/soccer/gameplay/plays/tuning/tune_pivot.py
@@ -14,13 +14,12 @@
 
         self.angle = 0
         point = robocup.Point(0, constants.Field.Length / 4.0)
-        self.face_target = point + robocup.Point(math.cos(self.angle), math.sin(self.angle))
+        self.face_target = point + robocup.Point(
+            math.cos(self.angle), math.sin(self.angle))
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
     # # where the robot sits on the field as it rotates
     # # Default: center of our half of the field
@@ -36,25 +35,21 @@
         self.robot.pivot(self.face_target)
 
 
-
 # This play rotates the bot 90 degrees, pauses, and repeats
 # It's useful for tuning the angle PID controller
 class TunePivoting(play.Play):
     def __init__(self):
         super().__init__(continuous=True)
 
-
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         rotater = Pivoter()
         self.add_subbehavior(rotater, 'rotater', required=False)
-   
-
 
     def execute_running(self):
         rotater = self.subbehavior_with_name('rotater')
         if rotater.robot != None:
-            rotater.robot.set_dribble_speed(int(constants.Robot.Dribbler.MaxPower / 3))
+            rotater.robot.set_dribble_speed(int(
+                constants.Robot.Dribbler.MaxPower / 3))

--- a/soccer/gameplay/plays/testing/test_mark.py
+++ b/soccer/gameplay/plays/testing/test_mark.py
@@ -4,19 +4,18 @@
 import robocup
 import main
 
-class TestMark(play.Play):
 
+class TestMark(play.Play):
     def __init__(self):
         super().__init__(continuous=True)
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            "immediately")
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
-    	b = skills.mark.Mark()
-    	b.mark_robot = main.their_robots()[0]
-    	self.add_subbehavior(b, name='mark', required=True)
+        b = skills.mark.Mark()
+        b.mark_robot = main.their_robots()[0]
+        self.add_subbehavior(b, name='mark', required=True)
 
     def on_exit_running(self):
         self.remove_subbehavior('mark')

--- a/soccer/gameplay/single_robot_behavior.py
+++ b/soccer/gameplay/single_robot_behavior.py
@@ -4,46 +4,47 @@
 
 
 class SingleRobotBehavior(behavior.Behavior):
-
     def __init__(self, continuous):
         super().__init__(continuous)
         self._robot = None
 
-
     def execute_running(self):
         if self.robot == None:
-            raise AssertionError("Error: execute_running() called on a single robot behavior that doesn't have a robot!")
-
+            raise AssertionError(
+                "Error: execute_running() called on a single robot behavior that doesn't have a robot!")
 
     @property
     def robot(self):
         return self._robot
+
     @robot.setter
     def robot(self, value):
         self._robot = value
 
-
     def role_requirements(self):
         reqs = role_assignment.RoleRequirements()
         if self.robot != None:
             reqs.previous_shell_id = self.robot.shell_id()
         return reqs
 
-
     # assignments is a (RoleRequirements, OurRobot) tuple
     def assign_roles(self, assignments):
         if not isinstance(assignments, tuple) or len(assignments) > 2:
-            raise AssertionError("Invalid call to assign_roles.  Expected a tuple")
+            raise AssertionError(
+                "Invalid call to assign_roles.  Expected a tuple")
         if len(assignments) == 2:
             import robocup
-            if assignments[1] != None and not isinstance(assignments[1], robocup.OurRobot):
-                raise TypeError("ERROR: attempt to assign robot to a non-robot object value: " + str(assignments[1]))
+            if assignments[1] != None and not isinstance(assignments[1],
+                                                         robocup.OurRobot):
+                raise TypeError(
+                    "ERROR: attempt to assign robot to a non-robot object value: "
+                    + str(assignments[1]))
             self.robot = assignments[1]
 
-
     def __str__(self):
         desc = super().__str__()
-        desc += "[robot=" + (str(self.robot.shell_id()) if self.robot != None else "None") + "]"
+        desc += "[robot=" + (str(self.robot.shell_id())
+                             if self.robot != None else "None") + "]"
         if self.robot != None:
             indent = '    '
             cmd_text = self.robot.get_cmd_text()[:-1]

--- a/firmware/robot/cpu/tools/sam7.py
+++ b/firmware/robot/cpu/tools/sam7.py
@@ -1,104 +1,107 @@
 import serial
 import os
 
+
 class SAM7:
-	def __init__(self, device):
-		self.f = serial.Serial(device, timeout=10)
-	
-	def __del__(self):
-		self.close()
-	
-	def close(self):
-		if self.f:
-			self.f.close()
-			self.f = None
-	
-	def expect(self, s):
-		for want in s:
-			got = self.f.read(1)
-			if got != want:
-				raise AssertionError('Expected 0x%02x, got 0x%02x' % (ord(want), ord(got)))
-
-	def commandWithLine(self, cmd):
-		self.f.write(cmd)
-		self.expect('\n\r')
-		value = self.f.readline().strip()
-		self.expect('\r>')
-		return value
-	
-	def command(self, cmd):
-		self.f.write(cmd)
-		self.expect('\n\r>')
-	
-	def version(self):
-		return self.commandWithLine('V#')
-	
-	def readWord(self, addr):
-		value = self.commandWithLine('w%x,#' % addr)
-		return int(value, 16)
-	
-	def readHalf(self, addr):
-		value = self.commandWithLine('h%x,#' % addr)
-		return int(value, 16)
-	
-	def readByte(self, addr):
-		value = self.commandWithLine('o%x,#' % addr)
-		return int(value, 16)
-	
-	def writeWord(self, addr, value):
-		self.command('W%x,%x#' % (addr, value))
-	
-	def writeHalf(self, addr, value):
-		self.command('H%x,%x#' % (addr, value))
-	
-	def writeByte(self, addr, value):
-		self.command('O%x,%x#' % (addr, value))
-	
-	def readData(self, addr, size):
-		self.f.write('R%x,%x#' % (addr, size))
-		self.expect('\n\r')
-		data = ''
-		while len(data) < size:
-			chunk = self.f.read(size - len(data))
-			data += chunk
-		self.expect('>')
-		return data
-	
-	def writeData(self, addr, data):
-		self.f.write('S%x,%x#' % (addr, len(data)))
-		self.expect('\n\r')
-		self.f.write(data)
-		assert self.f.read(1) == '>'
-	
-	def go(self, addr):
-		self.f.write('G%x#' % addr)
-		self.expect('\n\r')
-	
-	def dump(self, addr, size, filename):
-		f_out = file(filename, 'w')
-		f_out.write(self.readData(addr, size))
-		f_out.close()
-	
-	def load(self, addr, filename):
-		f_in = file(filename, 'r')
-		data = f_in.read()
-		f_in.close()
-		self.writeData(addr, data)
+    def __init__(self, device):
+        self.f = serial.Serial(device, timeout=10)
+
+    def __del__(self):
+        self.close()
+
+    def close(self):
+        if self.f:
+            self.f.close()
+            self.f = None
+
+    def expect(self, s):
+        for want in s:
+            got = self.f.read(1)
+            if got != want:
+                raise AssertionError('Expected 0x%02x, got 0x%02x' %
+                                     (ord(want), ord(got)))
+
+    def commandWithLine(self, cmd):
+        self.f.write(cmd)
+        self.expect('\n\r')
+        value = self.f.readline().strip()
+        self.expect('\r>')
+        return value
+
+    def command(self, cmd):
+        self.f.write(cmd)
+        self.expect('\n\r>')
+
+    def version(self):
+        return self.commandWithLine('V#')
+
+    def readWord(self, addr):
+        value = self.commandWithLine('w%x,#' % addr)
+        return int(value, 16)
+
+    def readHalf(self, addr):
+        value = self.commandWithLine('h%x,#' % addr)
+        return int(value, 16)
+
+    def readByte(self, addr):
+        value = self.commandWithLine('o%x,#' % addr)
+        return int(value, 16)
+
+    def writeWord(self, addr, value):
+        self.command('W%x,%x#' % (addr, value))
+
+    def writeHalf(self, addr, value):
+        self.command('H%x,%x#' % (addr, value))
+
+    def writeByte(self, addr, value):
+        self.command('O%x,%x#' % (addr, value))
+
+    def readData(self, addr, size):
+        self.f.write('R%x,%x#' % (addr, size))
+        self.expect('\n\r')
+        data = ''
+        while len(data) < size:
+            chunk = self.f.read(size - len(data))
+            data += chunk
+        self.expect('>')
+        return data
+
+    def writeData(self, addr, data):
+        self.f.write('S%x,%x#' % (addr, len(data)))
+        self.expect('\n\r')
+        self.f.write(data)
+        assert self.f.read(1) == '>'
+
+    def go(self, addr):
+        self.f.write('G%x#' % addr)
+        self.expect('\n\r')
+
+    def dump(self, addr, size, filename):
+        f_out = file(filename, 'w')
+        f_out.write(self.readData(addr, size))
+        f_out.close()
+
+    def load(self, addr, filename):
+        f_in = file(filename, 'r')
+        data = f_in.read()
+        f_in.close()
+        self.writeData(addr, data)
+
 
 FLASH = 0x100000
-RAM   = 0x200000
+RAM = 0x200000
 
 # MC_FCR values
 MC_FMR = 0xffffff60
 MC_FCR = 0xffffff64
 MC_FSR = 0xffffff68
-FCR_KEY  = 0x5a000000
+FCR_KEY = 0x5a000000
 # Flash commands
-FCR_WP   = 0x01
-FCR_SLB  = 0x02
-FCR_WPL  = 0x03
-FCR_CLB  = 0x04
-FCR_EA   = 0x08
+FCR_WP = 0x01
+FCR_SLB = 0x02
+FCR_WPL = 0x03
+FCR_CLB = 0x04
+FCR_EA = 0x08
 FCR_SGPB = 0x0b
 FCR_CGPB = 0x0d
-FCR_SSB  = 0x0f
+FCR_SSB = 0x0f

--- a/soccer/gameplay/plays/testing/line_up.py
+++ b/soccer/gameplay/plays/testing/line_up.py
@@ -6,27 +6,25 @@
 
 
 class LineUp(play.Play):
-
     def __init__(self):
         super().__init__(continuous=False)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
             lambda: self.subbehavior_with_name("LineUp").state == behavior.Behavior.State.completed,
             'all robots reach target positions')
-        self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
+        self.add_transition(
+            behavior.Behavior.State.completed, behavior.Behavior.State.running,
             lambda: self.subbehavior_with_name("LineUp").state == behavior.Behavior.State.running,
             'robots arent lined up')
 
-        x = (constants.Field.Width/2 - constants.Robot.Radius*2)
+        x = (constants.Field.Width / 2 - constants.Robot.Radius * 2)
         y_start = 0.2
         line = robocup.Segment(
-                robocup.Point(x, constants.Robot.Radius + y_start),
-                robocup.Point(x, (constants.Robot.Radius * 2 + 0.1)*6 + y_start))
+            robocup.Point(x, constants.Robot.Radius + y_start),
+            robocup.Point(x, (constants.Robot.Radius * 2 + 0.1) * 6 + y_start))
         l = tactics.line_up.LineUp(line)
         self.add_subbehavior(l, name="LineUp", required=True)

--- a/soccer/gameplay/plays/offense/two_side_attack.py
+++ b/soccer/gameplay/plays/offense/two_side_attack.py
@@ -10,6 +10,7 @@
 import tactics.coordinated_pass
 import tactics.defense
 
+
 class TwoSideAttack(play.Play):
     # Try to pass to the better target
     # Soccer/gameplay/evaluation/shot.py
@@ -22,46 +23,46 @@
         ## Pick best target, add coordinated pass subbehavior
         passing = 2
         ## Pivot kick (by default attacks enemy goal)
-        kicking = 3;
+        kicking = 3
 
     def __init__(self):
         super().__init__(continuous=False)
 
         self.add_state(TwoSideAttack.State.setup,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
         self.add_state(TwoSideAttack.State.passing,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
         self.add_state(TwoSideAttack.State.kicking,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
 
         # Add transitions
         self.add_transition(behavior.Behavior.State.start,
-            TwoSideAttack.State.setup,
-            lambda: True,
-            'immediately')
-        self.add_transition(TwoSideAttack.State.setup,
-            TwoSideAttack.State.passing,
+                            TwoSideAttack.State.setup, lambda: True,
+                            'immediately')
+        self.add_transition(
+            TwoSideAttack.State.setup, TwoSideAttack.State.passing,
             lambda: self.subbehavior_with_name('capture').is_done_running(),
             'all subbehaviors completed')
 
-        self.add_transition(TwoSideAttack.State.passing,
-            TwoSideAttack.State.kicking,
+        self.add_transition(
+            TwoSideAttack.State.passing, TwoSideAttack.State.kicking,
             lambda: self.kick_directly == True or self.temporary_behaviors_completed(),
             'all subbehaviors completed')
 
-        self.add_transition(TwoSideAttack.State.kicking,
-            behavior.Behavior.State.completed,
-            lambda: self.kick_directly == True,
-            'all subbehaviors completed')
+        self.add_transition(
+            TwoSideAttack.State.kicking, behavior.Behavior.State.completed,
+            lambda: self.kick_directly == True, 'all subbehaviors completed')
 
         self.add_transition(TwoSideAttack.State.kicking,
-            behavior.Behavior.State.completed,
-            lambda: self.temporary_behaviors_completed(),
-            'all subbehaviors completed')
+                            behavior.Behavior.State.completed,
+                            lambda: self.temporary_behaviors_completed(),
+                            'all subbehaviors completed')
 
         self.robot_points = [
-            robocup.Point(-constants.Field.Width / 4.0, 3 * constants.Field.Length / 4.0),
-            robocup.Point(constants.Field.Width / 4.0, 3 * constants.Field.Length / 4.0)
+            robocup.Point(-constants.Field.Width / 4.0, 3 *
+                          constants.Field.Length / 4.0),
+            robocup.Point(constants.Field.Width / 4.0, 3 *
+                          constants.Field.Length / 4.0)
         ]
         self.kick_directly = False
         self.passRobot1 = None
@@ -69,7 +70,9 @@
         self.captureRobot = None
 
         self.pernamentBehaviors = ['defense']
-        self.add_subbehavior(tactics.defense.Defense(), 'defense', required=False)
+        self.add_subbehavior(tactics.defense.Defense(),
+                             'defense',
+                             required=False)
 
     @classmethod
     def score(cls):
@@ -77,15 +80,19 @@
             return 9
         return float("inf")
 
-
     def on_enter_setup(self):
         # Add subbehaviors based on information
         capture = skills.capture.Capture()
-        self.add_subbehavior(skills.move.Move(self.robot_points[0]), 'moveA', required=True)
-        self.add_subbehavior(skills.move.Move(self.robot_points[1]), 'moveB', required=True)
+        self.add_subbehavior(
+            skills.move.Move(self.robot_points[0]),
+            'moveA',
+            required=True)
+        self.add_subbehavior(
+            skills.move.Move(self.robot_points[1]),
+            'moveB',
+            required=True)
         self.add_subbehavior(capture, 'capture', required=True)
 
-
     def on_exit_setup(self):
         self.passRobot1 = self.subbehavior_with_name('moveA').robot
         self.passRobot2 = self.subbehavior_with_name('moveB').robot
@@ -93,8 +100,6 @@
         self.to_exclude = [self.passRobot1, self.passRobot2, self.captureRobot]
         self.remove_temporary_subbehaviors()
 
-
-
     def on_enter_passing(self):
         # Do shot evaluation here
         win_eval = robocup.WindowEvaluator(main.system_state())
@@ -102,13 +107,15 @@
             win_eval.add_excluded_robot(r)
 
         _, rob_1_best_shot = win_eval.eval_pt_to_opp_goal(self.passRobot1.pos)
-        _, rob_1_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos, self.passRobot1.pos, 0.3)
+        _, rob_1_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos,
+                                                    self.passRobot1.pos, 0.3)
         rob_1_chance = 0
         if (rob_1_best_shot and rob_1_best_pass):
             rob_1_chance = rob_1_best_pass.shot_success * rob_1_best_shot.shot_success
 
         _, rob_2_best_shot = win_eval.eval_pt_to_opp_goal(self.passRobot2.pos)
-        _, rob_2_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos, self.passRobot2.pos, 0.3)
+        _, rob_2_best_pass = win_eval.eval_pt_to_pt(self.captureRobot.pos,
+                                                    self.passRobot2.pos, 0.3)
         rob_2_chance = 0
         if (rob_2_best_shot and rob_2_best_pass):
             rob_2_chance = rob_2_best_pass.shot_success * rob_2_best_shot.shot_success
@@ -118,19 +125,23 @@
         direct_success = 0
         if direct_shot:
             if (self.captureRobot.pos.y < 4):
-                direct_success = direct_shot.shot_success*0.7
+                direct_success = direct_shot.shot_success * 0.7
             else:
                 direct_success = direct_shot.shot_success
 
-            if (direct_shot and direct_success > rob_1_chance and direct_success > rob_2_chance):
+            if (direct_shot and direct_success > rob_1_chance and
+                    direct_success > rob_2_chance):
                 self.kick_directly = True
                 return
 
         if rob_1_chance > rob_2_chance:
-            self.add_subbehavior(tactics.coordinated_pass.CoordinatedPass(self.passRobot1.pos), 'pass')
+            self.add_subbehavior(
+                tactics.coordinated_pass.CoordinatedPass(self.passRobot1.pos),
+                'pass')
         else:
-            self.add_subbehavior(tactics.coordinated_pass.CoordinatedPass(self.passRobot2.pos), 'pass')
-
+            self.add_subbehavior(
+                tactics.coordinated_pass.CoordinatedPass(self.passRobot2.pos),
+                'pass')
 
     def remove_temporary_subbehaviors(self):
         for (key, value) in self.subbehaviors_by_name().items():
@@ -144,19 +155,16 @@
                     return False
         return True
 
-
     def on_exit_passing(self):
         self.kick_directly = False
         self.remove_temporary_subbehaviors()
 
-
     def on_enter_kicking(self):
         kick = skills.pivot_kick.PivotKick()
         kick.target = constants.Field.TheirGoalSegment
         kick.aim_params['desperate_timeout'] = 3
         self.add_subbehavior(kick, 'kick', required=False)
 
-
     def on_exit_kicking(self):
         self.remove_temporary_subbehaviors()
 

--- a/soccer/gameplay/single_robot_composite_behavior.py
+++ b/soccer/gameplay/single_robot_composite_behavior.py
@@ -8,54 +8,59 @@
 ## Behavior that applies to a single ROBOT and may have up to one subbehavior at any time
 # Most of the implementation is just checking if we have subbehaviors and calling the real method on the appropriate superclass
 # Note: The method-resolution-order in python dictates that as we have it listed below, SingleRobotBehavior methods take precedence over CompositeBehavior methods
-class SingleRobotCompositeBehavior(single_robot_behavior.SingleRobotBehavior, composite_behavior.CompositeBehavior):
+class SingleRobotCompositeBehavior(single_robot_behavior.SingleRobotBehavior,
+                                   composite_behavior.CompositeBehavior):
 
     ## we over-ride this to enforce the rule that there can't be more than one subbehavior
     def add_subbehavior(self, bhvr, name, required=True, priority=100):
         if self.has_subbehaviors():
-            raise AssertionError("Attempt to add more than one subbehavior to SingleRobotCompositeBehavior")
+            raise AssertionError(
+                "Attempt to add more than one subbehavior to SingleRobotCompositeBehavior")
         super().add_subbehavior(bhvr, name, required, priority)
         self.robot_shell_id = None
 
-
     def has_subbehaviors(self):
         return len(self.all_subbehaviors()) > 0
 
-
     def role_requirements(self):
         if self.has_subbehaviors():
             reqs = composite_behavior.CompositeBehavior.role_requirements(self)
             if self.robot != None:
-                for req in role_assignment.iterate_role_requirements_tree_leaves(reqs):
+                for req in role_assignment.iterate_role_requirements_tree_leaves(
+                        reqs):
                     req.previous_shell_id = self.robot.shell_id()
 
             return reqs
         else:
-            return single_robot_behavior.SingleRobotBehavior.role_requirements(self)
-
+            return single_robot_behavior.SingleRobotBehavior.role_requirements(
+                self)
 
     def assign_roles(self, assignments):
         oldBot = self.robot
         if self.has_subbehaviors():
-            composite_behavior.CompositeBehavior.assign_roles(self, assignments)
+            composite_behavior.CompositeBehavior.assign_roles(self,
+                                                              assignments)
 
             # extract robot from the one leaf in the tree
             # we don't know how deep the tree is, which is why we use the tree leaf iterator
-            for assignment_tuple in role_assignment.iterate_role_requirements_tree_leaves(assignments):
+            for assignment_tuple in role_assignment.iterate_role_requirements_tree_leaves(
+                    assignments):
                 self.robot = assignment_tuple[1]
         else:
-            single_robot_behavior.SingleRobotBehavior.assign_roles(self, assignments)
+            single_robot_behavior.SingleRobotBehavior.assign_roles(self,
+                                                                   assignments)
 
         # Most single robot composite behaviors assume (rightly so) that the robot they're
         # dealing with won't change. PivotKick for example runs the Capture skill, then
         # the Aim skill to do its stuff. It'd be pretty weird if the robot executing Aim
         # was different from the one that just ran Capture. Here we just restart the behavior
         # If it gets assigned a new robot.
-        if oldBot != None and self.robot != None and oldBot.shell_id() != self.robot.shell_id():
-            logging.info("SingleRobotCompositeBehavior: robot changed, restarting behavior")
+        if oldBot != None and self.robot != None and oldBot.shell_id(
+        ) != self.robot.shell_id():
+            logging.info(
+                "SingleRobotCompositeBehavior: robot changed, restarting behavior")
             self.restart()
 
-
     def __str__(self):
         if self.has_subbehaviors():
             return composite_behavior.CompositeBehavior.__str__(self)

--- a/soccer/gameplay/skills/intercept.py
+++ b/soccer/gameplay/skills/intercept.py
@@ -3,33 +3,38 @@
 import robocup
 import main
 
+
 # wraps up OurRobot.move() into a Skill so we can use it in the play system more easily
 class Intercept(single_robot_behavior.SingleRobotBehavior):
-
     def __init__(self, pos=None):
         super().__init__(continuous=True)
 
         self._shape_constraint = None
-        
+
         self.ball_line = lambda: robocup.Segment(main.ball().pos, main.ball().pos + (main.ball().vel.normalized() * 8.))
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True, 'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
     def execute_running(self):
         if self.robot != None and main.ball().valid:
             if self.shape_constraint is None:
-                self.target_pos = self.ball_line().nearest_point(self.robot.pos)
+                self.target_pos = self.ball_line().nearest_point(
+                    self.robot.pos)
             elif isinstance(self.shape_constraint, robocup.Segment):
-                self.target_pos = self.shape_constraint.segment_intersection(self.ball_line())
+                self.target_pos = self.shape_constraint.segment_intersection(
+                    self.ball_line())
                 if self.target_pos is None:
-                    self.target_pos = self.ball_line().nearest_point(self.robot.pos)
-                    self.target_pos = self.shape_constraint.nearest_point(self.target_pos)
-                main.system_state().draw_line(self.shape_constraint, (0,255,0), "Debug")
+                    self.target_pos = self.ball_line().nearest_point(
+                        self.robot.pos)
+                    self.target_pos = self.shape_constraint.nearest_point(
+                        self.target_pos)
+                main.system_state().draw_line(self.shape_constraint,
+                                              (0, 255, 0), "Debug")
             else:
-                self.target_pos = self.ball_line().nearest_point(self.robot.pos)
+                self.target_pos = self.ball_line().nearest_point(
+                    self.robot.pos)
 
             self.robot.move_to_direct(self.target_pos)
             self.robot.face(main.ball().pos)
@@ -42,9 +47,11 @@
     """
     @brief If not None, the intercepting robot will remain on this shape.
     """
+
     @property
     def shape_constraint(self):
         return self._shape_constraint
+
     @shape_constraint.setter
     def shape_constraint(self, value):
-        self._shape_constraint = value
\ No newline at end of file
+        self._shape_constraint = value

--- a/soccer/gameplay/role_assignment.py
+++ b/soccer/gameplay/role_assignment.py
@@ -4,11 +4,10 @@
 import logging
 import math
 
-
 # TODO arbitrary cost lambda property
 
-class RoleRequirements:
 
+class RoleRequirements:
     def __init__(self):
         self.destination_shape = None
         self.has_ball = False
@@ -19,7 +18,6 @@
         self.priority = 0
         self.require_kicking = False
 
-
     def __str__(self):
         props = []
         props.append("has_ball=" + str(self.has_ball))
@@ -38,27 +36,28 @@
     def __repr__(self):
         return str(self)
 
-
     @property
     def destination_shape(self):
         return self._destination_shape
+
     @destination_shape.setter
     def destination_shape(self, value):
-        if value != None and not ( isinstance(value, robocup.Point) or isinstance(value, robocup.Segment) ):
-            raise TypeError("Unexpected type for destination_shape: " + str(value))
+        if value != None and not (isinstance(value, robocup.Point) or
+                                  isinstance(value, robocup.Segment)):
+            raise TypeError("Unexpected type for destination_shape: " + str(
+                value))
         self._destination_shape = value
 
-
     @property
     def has_ball(self):
         return self._has_ball
+
     @has_ball.setter
     def has_ball(self, value):
         if value != None and not isinstance(value, bool):
             raise TypeError("Unexpected type for has_ball: " + str(value))
         self._has_ball = value
 
-
     # rather than having a 'has_chipper' property, we have a property for the weight
     # * a value of MaxWeight means that a chipper is required
     # * a value of 0 means we don't care if it has a chipper or not
@@ -67,61 +66,63 @@
     @property
     def chipper_preference_weight(self):
         return self._chipper_preference_weight
+
     @chipper_preference_weight.setter
     def chipper_preference_weight(self, value):
         self._chipper_preference_weight = value
 
-
     # if True, requires that the robot has a working ball sensor, a working kicker,
     # and isn't forbidden from touching the ball by the double touch rules
     # Default: False
     @property
     def require_kicking(self):
         return self._require_kicking
+
     @require_kicking.setter
     def require_kicking(self, value):
         self._require_kicking = value
 
-
     @property
     def required_shell_id(self):
         return self._required_shell_id
+
     @required_shell_id.setter
     def required_shell_id(self, value):
         if value != None and not isinstance(value, int):
-            raise TypeError("Unexpected type for required_shell_id: " + str(value))
+            raise TypeError("Unexpected type for required_shell_id: " + str(
+                value))
         self._required_shell_id = value
 
-
     @property
     def previous_shell_id(self):
         return self._previous_shell_id
+
     @previous_shell_id.setter
     def previous_shell_id(self, value):
         if value != None and not isinstance(value, int):
-            raise TypeError("Unexpected type for previous_shell_id: " + str(value))
+            raise TypeError("Unexpected type for previous_shell_id: " + str(
+                value))
         self._previous_shell_id = value
 
-
     # Whether or not this Role is required
     # If false, it is assigned
     @property
     def required(self):
         return self._required
+
     @required.setter
     def required(self, value):
         self._required = value
 
-
     @property
     def priority(self):
         return self._priority
+
     @priority.setter
     def priority(self, value):
         self._priority = value
 
 
-
 # given a role requirements tree (with RoleRequirements or assignment tuples as leaves),
 # yields all of the RoleRequiements objects
 def iterate_role_requirements_tree_leaves(reqs_tree):
@@ -132,10 +133,9 @@
             yield from iterate_role_requirements_tree_leaves(subtree)
 
 
-
 # This error is thrown by assign_roles() when given an impossible assignment scenario
-class ImpossibleAssignmentError(RuntimeError): pass
-
+class ImpossibleAssignmentError(RuntimeError):
+    pass
 
 # the munkres library doesn't like infinity, so we use this instead
 MaxWeight = 10000000
@@ -164,10 +164,10 @@
     if len(role_reqs) == 0:
         return {}
 
-
     # first we flatten the role_reqs tree structure into a simple list of RoleRequirements
     role_reqs_list = []
-    tree_mapping = {}   # holds key paths so we can map the flattened list back into the tree at the end
+    tree_mapping = {
+    }  # holds key paths so we can map the flattened list back into the tree at the end
 
     # The input and output to assign_roles() are in a tree form that maps to the behavior tree that we're assigning robots for
     # To do our calculations though, we need to have a flat list of RoleRequirements to match to our list of robots
@@ -180,37 +180,41 @@
                 role_reqs_list.append(subtree)
                 tree_mapping[subtree] = path_prefix + [key]
             else:
-                raise AssertionError("Unknown node type in role_reqs tree: " + str(subtree))
+                raise AssertionError("Unknown node type in role_reqs tree: " +
+                                     str(subtree))
 
     flatten_tree(role_reqs)
 
-
     required_roles = [r for r in role_reqs_list if r.required]
-    optional_roles = sorted([r for r in role_reqs_list if not r.required], reverse=True, key=lambda r: r.priority)
-
+    optional_roles = sorted(
+        [r for r in role_reqs_list if not r.required],
+        reverse=True,
+        key=lambda r: r.priority)
 
     # logs the assignment parameters and raises an ImpossibleAssignmentError
     def fail(errStr):
         botsDesc = 'Robots:\n\t' + '\n\t'.join([str(bot) for bot in robots])
-        rolesDesc = 'Roles:\n\t' + '\n\t'.join([str(role) for role in role_reqs_list])
+        rolesDesc = 'Roles:\n\t' + '\n\t'.join([str(role)
+                                                for role in role_reqs_list])
         logging.error('Failed Assignment:\n' + botsDesc + '\n' + rolesDesc)
-        raise ImpossibleAssignmentError("No assignments possible that satisfy all constraints")
-
+        raise ImpossibleAssignmentError(
+            "No assignments possible that satisfy all constraints")
 
     # make sure there's enough robots
-    unassigned_role_requirements = []   # roles that won't be assigned because there aren't enough bots
+    unassigned_role_requirements = [
+    ]  # roles that won't be assigned because there aren't enough bots
     if len(required_roles) > len(robots):
         fail("More required roles than available robots")
     elif len(role_reqs_list) > len(robots):
         # remove the lowest priority optional roles so we have as many bots as roles we're trying to fill
         overflow = len(role_reqs_list) - len(robots)
         role_reqs_list = required_roles + optional_roles[0:-overflow]
-        unassigned_role_requirements = optional_roles[len(optional_roles) - overflow:]
+        unassigned_role_requirements = optional_roles[len(optional_roles) -
+                                                      overflow:]
 
     if len(robots) == 0:
         return {}
 
-
     # build the cost matrix
     cost_matrix = []
     for robot in robots:
@@ -218,16 +222,23 @@
         for req in role_reqs_list:
             cost = 0
 
-            if req.required_shell_id != None and req.required_shell_id != robot.shell_id():
+            if req.required_shell_id != None and req.required_shell_id != robot.shell_id(
+            ):
                 cost = MaxWeight
             elif req.has_ball == True and robot.has_ball() == False:
                 cost = MaxWeight
-            elif req.require_kicking and (robot.shell_id() == evaluation.double_touch.tracker().forbidden_ball_toucher() or not robot.kicker_works() or not robot.ball_sense_works()):
+            elif req.require_kicking and (
+                    robot.shell_id() ==
+                    evaluation.double_touch.tracker().forbidden_ball_toucher()
+                    or not robot.kicker_works() or
+                    not robot.ball_sense_works()):
                 cost = MaxWeight
             else:
                 if req.destination_shape != None:
-                    cost += PositionCostMultiplier * req.destination_shape.dist_to(robot.pos)
-                if req.previous_shell_id != None and req.previous_shell_id != robot.shell_id():
+                    cost += PositionCostMultiplier * req.destination_shape.dist_to(
+                        robot.pos)
+                if req.previous_shell_id != None and req.previous_shell_id != robot.shell_id(
+                ):
                     cost += RobotChangeCost
                 if not robot.has_chipper():
                     cost += req.chipper_preference_weight
@@ -236,17 +247,16 @@
             # whole program to hang and have to be restarted.  We check for it
             # here and raise an exception if there's a NaN.
             if (math.isnan(cost)):
-                raise ArithmeticError("NaN value encountered when building role assignment cost matrix")
+                raise ArithmeticError(
+                    "NaN value encountered when building role assignment cost matrix")
 
             cost_row.append(cost)
         cost_matrix.append(cost_row)
 
-
     # solve
     solver = munkres.Munkres()
     indexes = solver.compute(cost_matrix)
 
-
     results = {}
 
     def insert_into_results(results, tree_mapping, role_reqs, robot):
@@ -259,7 +269,6 @@
             parent = parent[key]
         parent[tree_path[-1]] = (role_reqs, robot)
 
-
     # build assignments mapping
     assignments = {}
     total = 0
@@ -272,12 +281,10 @@
         # add entry to results tree
         insert_into_results(results, tree_mapping, reqs, bot)
 
-
     # insert None for each role that we didn't assign
     for reqs in unassigned_role_requirements:
         insert_into_results(results, tree_mapping, reqs, None)
 
-
     if total >= MaxWeight:
         fail("No assignments possible that satisfy all constraints")
 

--- a/soccer/gameplay/plays/testing/triangle_pass.py
+++ b/soccer/gameplay/plays/testing/triangle_pass.py
@@ -12,7 +12,6 @@
 ## A demo play written during a teaching session to demonstrate play-writing
 # Three robots form a triangle on the field and pass the ball A->B->C->A and so on.
 class TrianglePass(play.Play):
-
     class State(enum.Enum):
         ## 2 robots get on the corners of a triangle,
         # while a third fetches the ball
@@ -21,35 +20,34 @@
         ## The robots continually pass to each other
         passing = 2
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
         # register states - they're both substates of "running"
         self.add_state(TrianglePass.State.setup,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
         self.add_state(TrianglePass.State.passing,
-            behavior.Behavior.State.running)
+                       behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            TrianglePass.State.setup,
-            lambda: True,
-            'immediately')
+                            TrianglePass.State.setup, lambda: True,
+                            'immediately')
         self.add_transition(TrianglePass.State.setup,
-            TrianglePass.State.passing,
-            lambda: self.all_subbehaviors_completed(),
-            'all subbehaviors completed')
+                            TrianglePass.State.passing,
+                            lambda: self.all_subbehaviors_completed(),
+                            'all subbehaviors completed')
 
         self.triangle_points = [
-            robocup.Point(0, constants.Field.Length/2.0),
-            robocup.Point(constants.Field.Width/4, constants.Field.Length/4),
-            robocup.Point(-constants.Field.Width/4, constants.Field.Length/4),
+            robocup.Point(0, constants.Field.Length / 2.0),
+            robocup.Point(constants.Field.Width / 4, constants.Field.Length /
+                          4),
+            robocup.Point(-constants.Field.Width / 4, constants.Field.Length /
+                          4),
         ]
 
-
     def on_enter_setup(self):
         closestPt = min(self.triangle_points,
-            key=lambda pt: pt.dist_to(main.ball().pos))
+                        key=lambda pt: pt.dist_to(main.ball().pos))
 
         otherPts = list(self.triangle_points)
         otherPts.remove(closestPt)
@@ -61,7 +59,6 @@
     def on_exit_setup(self):
         self.remove_all_subbehaviors()
 
-
     def execute_passing(self):
         # If we had a pass in progress before and it finished, remove it
         if self.has_subbehaviors():
@@ -72,13 +69,14 @@
         if not self.has_subbehaviors():
             # pick pass from and to points
             kickFrom = min(self.triangle_points,
-                            key=lambda pt: pt.dist_to(main.ball().pos))
+                           key=lambda pt: pt.dist_to(main.ball().pos))
             kickFromIdx = self.triangle_points.index(kickFrom)
             kickToIdx = (kickFromIdx + 1) % len(self.triangle_points)
             kickToPt = self.triangle_points[kickToIdx]
 
             # add the pass subbehavior
-            self.add_subbehavior(tactics.coordinated_pass.CoordinatedPass(kickToPt), 'pass')
+            self.add_subbehavior(
+                tactics.coordinated_pass.CoordinatedPass(kickToPt), 'pass')
 
     def on_exit_passing(self):
         self.remove_all_subbehaviors()

--- a/soccer/gameplay/skills/angle_receive.py
+++ b/soccer/gameplay/skills/angle_receive.py
@@ -17,7 +17,6 @@
 # It will move to the 'completed' state if it catches the ball, otherwise it will go to 'failed'.
 # Kick is a single_robot_behavior, so no need to import both
 class AngleReceive(skills.pass_receive.PassReceive):
-
     def __init__(self):
         super().__init__()
         self._target_point = None
@@ -29,6 +28,7 @@
     @property
     def target_point(self):
         return self._target_point
+
     @target_point.setter
     def target_point(self, value):
         self._target_point = value
@@ -39,7 +39,7 @@
     # First finds the rejection, which is the X component of the ball's velocity in the reference
     # frame of the robot, with the mouth facing the y axis. Then we calculate the angle required to
     # offset this rejection angle (if possible).
-    def adjust_angle(self, target_angle, ball_angle = None, ball_speed = None):
+    def adjust_angle(self, target_angle, ball_angle=None, ball_speed=None):
         ball = main.ball()
 
         if ball_angle == None:
@@ -52,7 +52,8 @@
         rejection = math.sin(angle_diff) * ball_speed
 
         # The min/max is to bound the value by -1 and 1.
-        adjust = math.asin(min(1, max(-1, rejection / constants.Robot.MaxKickSpeed)))
+        adjust = math.asin(min(1, max(-1, rejection /
+                                      constants.Robot.MaxKickSpeed)))
         return adjust + target_angle
 
     # calculates:
@@ -66,64 +67,73 @@
         if self.receive_point == None or self.robot == None or self.target_point == None:
             return
 
-
         ball = main.ball()
 
         if self.ball_kicked:
             # when the ball's in motion, the line is based on the ball's velocity
-            self._pass_line = robocup.Line(ball.pos, ball.pos + ball.vel*10)
+            self._pass_line = robocup.Line(ball.pos, ball.pos + ball.vel * 10)
 
             # After kicking, apply angle calculations
-            target_angle_rad = self.adjust_angle((self.target_point - self.robot.pos).angle())
+            target_angle_rad = self.adjust_angle((self.target_point -
+                                                  self.robot.pos).angle())
             # Removes angle adjustment
             # target_angle_rad = (self.target_point - self.robot.pos).angle()
 
-            self._kick_line = robocup.Line(self.robot.pos, robocup.Point(self.robot.pos.x + math.cos(self.robot.angle) * 10, self.robot.pos.y + math.sin(self.robot.angle) * 10))
+            self._kick_line = robocup.Line(self.robot.pos, robocup.Point(
+                self.robot.pos.x + math.cos(self.robot.angle) * 10,
+                self.robot.pos.y + math.sin(self.robot.angle) * 10))
         else:
             # if the ball hasn't been kicked yet, we assume it's going to go through the receive point
             self._pass_line = robocup.Line(ball.pos, self.receive_point)
             # Assume ball is kicked at max speed and is coming from the ball point to the location of our robot. Then average this with the target angle.
-            target_angle_rad = self.adjust_angle((self.target_point - self.robot.pos).angle(), (self.robot.pos - main.ball().pos).angle(), constants.Robot.MaxKickSpeed)
+            target_angle_rad = self.adjust_angle(
+                (self.target_point - self.robot.pos).angle(),
+                (self.robot.pos - main.ball().pos).angle(),
+                constants.Robot.MaxKickSpeed)
             # TODO make this faster by caching the .angle() part
-            target_angle_rad = (target_angle_rad + (self.target_point - self.robot.pos).angle()) / 2
+            target_angle_rad = (
+                target_angle_rad +
+                (self.target_point - self.robot.pos).angle()) / 2
 
-            self._kick_line = robocup.Line(self.receive_point, self.target_point)
+            self._kick_line = robocup.Line(self.receive_point,
+                                           self.target_point)
 
-        self._angle_facing =  target_angle_rad
+        self._angle_facing = target_angle_rad
         angle_rad = self.robot.angle
         self._angle_error = target_angle_rad - angle_rad
 
         if self.ball_kicked:
-            receive_before_adjust = self._pass_line.nearest_point(self.robot.pos)
+            receive_before_adjust = self._pass_line.nearest_point(
+                self.robot.pos)
         else:
             receive_before_adjust = self.receive_point
 
         # Make the receive point be the mouth, rather than the center of the robot.
         # Assumes mouth of robot is at the edge.
         self._target_pos = receive_before_adjust - robocup.Point(
-                constants.Robot.Radius * math.cos(self.robot.angle),
-                constants.Robot.Radius * math.sin(self.robot.angle))
+            constants.Robot.Radius * math.cos(self.robot.angle),
+            constants.Robot.Radius * math.sin(self.robot.angle))
 
         # Code to provide slipback when receiving the ball
         # pass_line_dir = (self._pass_line.get_pt(1) - self._pass_line.get_pt(0)).normalized()
         # self._target_pos = actual_receive_point + pass_line_dir * constants.Robot.Radius
 
-
         # vector pointing down the pass line toward the kicker
-        pass_dir = (self._pass_line.get_pt(0) - self._pass_line.get_pt(1)).normalized()
+        pass_dir = (
+            self._pass_line.get_pt(0) - self._pass_line.get_pt(1)).normalized()
 
         pos_error = self._target_pos - self.robot.pos
         self._x_error = self._target_pos.x - self.robot.pos.x
         self._y_error = self._target_pos.y - self.robot.pos.y
 
-
     def execute_running(self):
         super().execute_running()
 
-        self.robot.face(self.robot.pos
-                + robocup.Point(math.cos(self._angle_facing), math.sin(self._angle_facing)))
+        self.robot.face(self.robot.pos + robocup.Point(
+            math.cos(self._angle_facing), math.sin(self._angle_facing)))
         if self._kick_line != None:
-            main.system_state().draw_line(self._kick_line, constants.Colors.Red, "Shot")
+            main.system_state().draw_line(self._kick_line,
+                                          constants.Colors.Red, "Shot")
 
     def execute_receiving(self):
         super().execute_receiving()
@@ -132,4 +142,5 @@
         self.robot.kick(self.kick_power)
 
         if self.target_point != None:
-            main.system_state().draw_circle(self.target_point, 0.03, constants.Colors.Blue, "Target")
+            main.system_state().draw_circle(self.target_point, 0.03,
+                                            constants.Colors.Blue, "Target")

--- a/soccer/gameplay/plays/tuning/test_jittery_motion.py
+++ b/soccer/gameplay/plays/tuning/test_jittery_motion.py
@@ -5,8 +5,6 @@
 import constants
 import math
 
-
-
 # this play tests the effect of sending motion commands to the bot that jitter
 #
 #     ^
@@ -23,20 +21,16 @@
 
 
 class Jitterer(single_robot_behavior.SingleRobotBehavior):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
     def on_exit_start(self):
         self.iter_count = 0
 
-
     def execute_running(self):
         self.iter_count += 1
 
@@ -46,7 +40,7 @@
             if self.iter_count % 2 == 0:
                 vel = robocup.Point.direction(math.pi / 4.0) * speed
             else:
-                vel = robocup.Point.direction(math.pi * 3.0/4.0) * speed
+                vel = robocup.Point.direction(math.pi * 3.0 / 4.0) * speed
         else:
             vel = robocup(0, speed)
 
@@ -54,14 +48,12 @@
 
 
 class TestJitteryMotion(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
         j = Jitterer()
         self.add_subbehavior(j, 'jitterer', required=False)

--- a/soccer/gameplay/skills/_kick.py
+++ b/soccer/gameplay/skills/_kick.py
@@ -4,9 +4,9 @@
 import main
 import role_assignment
 
+
 ## this is the abstract superclass for PivotKick and LineKick
 class _Kick(single_robot_behavior.SingleRobotBehavior):
-
     def __init__(self):
         super().__init__(continuous=False)
 
@@ -20,32 +20,30 @@
         self.target = constants.Field.TheirGoalSegment
 
         # cached calculated values
-        self._aim_target_point = None # this is what our calculations on the given target boil down to
+        self._aim_target_point = None  # this is what our calculations on the given target boil down to
 
         self.shot_obstacle_ignoring_robots = []
 
-
     ## if True, uses the window evaluator to choose the best place to aim at target_segment
     # Default: True
     @property
     def use_windowing(self):
         return self._use_windowing
+
     @use_windowing.setter
     def use_windowing(self, value):
         self._use_windowing = value
 
-
     ## these params are passed to the window evaluator using setattr()
     # Default: {}
     @property
     def win_eval_params(self):
         return self._win_eval_params
+
     @win_eval_params.setter
     def win_eval_params(self, value):
         self._win_eval_params = value
 
-
-
     ## The thing we're trying to kick at
     # can be a Segment or a Point
     # setting this property automatically recalculates the target_aim_point
@@ -53,32 +51,31 @@
     @property
     def target(self):
         return self._target
+
     @target.setter
     def target(self, value):
         self._target = value
         self.recalculate_aim_target_point()
 
-
     ## A list of robots that the shot obstacle doesn't apply to
     # Note: the shot obstacle already doesn't apply to the kicker, you don't have to specify that here
     # Default: []
     @property
     def shot_obstacle_ignoring_robots(self):
         return self._shot_obstacle_ignoring_robots
+
     @shot_obstacle_ignoring_robots.setter
     def shot_obstacle_ignoring_robots(self, value):
         if value == None:
             value = []
         self._shot_obstacle_ignoring_robots = value
 
-
     ## We calculate the point we're ACTUALLY going to aim at based on the target Segment/Point and other parameters
     # This is that point
     @property
     def aim_target_point(self):
         return self._aim_target_point
 
-
     ## we're aiming at a particular point on our target segment, what is this point?
     def recalculate_aim_target_point(self):
         if self.robot != None:
@@ -90,8 +87,10 @@
                     win_eval = robocup.WindowEvaluator(main.system_state())
                     for key, value in self.win_eval_params.items():
                         setattr(win_eval, key, value)
-                    win_eval.chip_enabled = self.robot.has_chipper() and self.use_chipper
-                    windows, best = win_eval.eval_pt_to_seg(main.ball().pos, self.target)
+                    win_eval.chip_enabled = self.robot.has_chipper(
+                    ) and self.use_chipper
+                    windows, best = win_eval.eval_pt_to_seg(main.ball().pos,
+                                                            self.target)
                     if best != None:
                         self._aim_target_point = best.segment.center()
                     else:
@@ -99,8 +98,8 @@
                 else:
                     self._aim_target_point = self.target.center()
             else:
-                raise AssertionError("Expected Point or Segment, found: " + str(self.target))
-
+                raise AssertionError("Expected Point or Segment, found: " +
+                                     str(self.target))
 
     ## Allows for different kicker/chipper settings, such as for
     # passing with lower power.
@@ -108,38 +107,40 @@
     @property
     def kick_power(self):
         return self._kick_power
+
     @kick_power.setter
     def kick_power(self, value):
         self._kick_power = value
+
     @property
     def chip_power(self):
         return self._chip_power
+
     @chip_power.setter
     def chip_power(self, value):
         self._chip_power = value
 
-
     ## If false, uses straight kicker, if true, uses chipper (if available)
     # Default: False
     @property
     def use_chipper(self):
         return self._use_chipper
+
     @use_chipper.setter
     def use_chipper(self, value):
         self._use_chipper = value
 
-
     ## If set to False, will get all ready to go, but won't kick/chip just yet
     # Can be used to synchronize between behaviors
     # Default: True
     @property
     def enable_kick(self):
         return self._enable_kick
+
     @enable_kick.setter
     def enable_kick(self, value):
         self._enable_kick = value
 
-
     ## creates a polygon obstacle from the ball to the target
     # this obstacle applies to all robots except the kicker and anything specified in the excluded_robots parameter
     # NOTE: this method is not called by _kick, it's up to subclasses/superbehaviors to call it
@@ -170,6 +171,5 @@
                 if bot not in excluded_robots + [self.robot]:
                     bot.add_local_obstacle(obs)
 
-
     def execute_running(self):
         self.add_shot_obstacle(self.shot_obstacle_ignoring_robots)

--- a/soccer/gameplay/skills/move_direct.py
+++ b/soccer/gameplay/skills/move_direct.py
@@ -4,7 +4,6 @@
 
 ## Behavior that moves a robot to a specified location, circumventing the path planner.
 class MoveDirect(single_robot_behavior.SingleRobotBehavior):
-
     def __init__(self, pos=None):
         super().__init__(continuous=False)
 
@@ -12,43 +11,40 @@
         self.pos = pos
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True, 'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
             lambda: self.pos != None and (self.robot.pos - self.pos).mag() < self.threshold,
             'target pos reached')
-        self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
-            lambda:  self.pos != None and (self.robot.pos - self.pos).mag() > self.threshold,
+        self.add_transition(
+            behavior.Behavior.State.completed, behavior.Behavior.State.running,
+            lambda: self.pos != None and (self.robot.pos - self.pos).mag() > self.threshold,
             'away from target')
 
-
     ## the position to move to (a robocup.Point object)
     @property
     def pos(self):
         return self._pos
+
     @pos.setter
     def pos(self, value):
         self._pos = value
 
-
     ## how close (in meters) the robot has to be to the target position for it be complete
     @property
     def threshold(self):
         return self._threshold
+
     @threshold.setter
     def threshold(self, value):
         self._threshold = value
 
-
-
     def execute_running(self):
         if self.pos != None:
             self.robot.move_to_direct(self.pos)
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         reqs.destination_shape = self.pos

--- a/soccer/gameplay/root_play.py
+++ b/soccer/gameplay/root_play.py
@@ -13,20 +13,19 @@
 ## The RootPlay is basically the python-side of the c++ GameplayModule
 # it coordinates the selection of the 'actual' play and handles the goalie behavior
 class RootPlay(Play, QtCore.QObject):
-
     def __init__(self):
         QtCore.QObject.__init__(self)
         Play.__init__(self, continuous=True)
         self._play = None
         self._goalie_id = None
-        self.add_transition(Behavior.State.start, Behavior.State.running, lambda: True, 'immediately')
+        self.add_transition(Behavior.State.start, Behavior.State.running,
+                            lambda: True, 'immediately')
 
         # if a play fails for some reason, we can temporarily blacklist it, which removes it from play
         # selection for the next iteration, then enables it again
         self.temporarily_blacklisted_play_class = None
         self._currently_restarting = False
 
-
     play_changed = QtCore.pyqtSignal("QString")
 
     def execute_running(self):
@@ -48,29 +47,44 @@
             self.play = None
         else:
             # (play_class, score value) tuples
-            enabled_plays_and_scores = [p for p in main.play_registry().get_enabled_plays_and_scores()]
+            enabled_plays_and_scores = [
+                p for p in main.play_registry().get_enabled_plays_and_scores()
+            ]
 
             # only let restart play run once
-            enabled_plays_and_scores = [p for p in enabled_plays_and_scores if not p[0].is_restart() or ( p[0].is_restart() and self._currently_restarting)]
+            enabled_plays_and_scores = [
+                p
+                for p in enabled_plays_and_scores
+                if not p[0].is_restart() or (p[0].is_restart() and
+                                             self._currently_restarting)
+            ]
 
             # handle temporary blacklisting
             # we remove the blacklisted play class from selection for this iteration, then unblacklist it
-            enabled_plays_and_scores = [p for p in enabled_plays_and_scores if p[0] != self.temporarily_blacklisted_play_class]
+            enabled_plays_and_scores = [
+                p
+                for p in enabled_plays_and_scores
+                if p[0] != self.temporarily_blacklisted_play_class
+            ]
             self.temporarily_blacklisted_play_class = None
 
             # see if we need to kill current play or if it's done running
             if self.play != None:
-                if self.play.__class__ not in map(lambda tup: tup[0], enabled_plays_and_scores):
-                    logging.info("Current play '" + self.play.__class__.__name__ + "' no longer enabled, aborting")
+                if self.play.__class__ not in map(lambda tup: tup[0],
+                                                  enabled_plays_and_scores):
+                    logging.info("Current play '" + self.play.__class__.
+                                 __name__ + "' no longer enabled, aborting")
                     self.play.terminate()
                     self.play = None
                 elif self.play.is_done_running():
-                    logging.info("Current play '" + self.play.__class__.__name__ + "' finished running")
+                    logging.info("Current play '" + self.play.__class__.
+                                 __name__ + "' finished running")
                     if self.play.is_restart:
                         self._currently_restarting = False
                     self.play = None
                 elif self.play.__class__.score() == float("inf"):
-                    logging.info("Current play '" + self.play.__class__.__name__ + "' no longer applicable, ending")
+                    logging.info("Current play '" + self.play.__class__.
+                                 __name__ + "' no longer applicable, ending")
                     self.play.terminate()
                     self.play = None
 
@@ -81,61 +95,64 @@
                 try:
                     if len(enabled_plays_and_scores) > 0:
                         # select the play with the smallest value for score()
-                        play_class_and_score = min(enabled_plays_and_scores, key=lambda tup: tup[1])
+                        play_class_and_score = min(enabled_plays_and_scores,
+                                                   key=lambda tup: tup[1])
 
                         # run the play with the lowest score, as long as it isn't inf
                         if play_class_and_score[1] != float("inf"):
                             play_class = play_class_and_score[0]
-                            self.play = play_class() # instantiate it
+                            self.play = play_class()  # instantiate it
                     else:
                         # there's no available plays to run
                         pass
                 except Exception as e:
-                    logging.error("Exception occurred during play selection: " + str(e))
+                    logging.error("Exception occurred during play selection: "
+                                  + str(e))
                     traceback.print_exc()
                 if self.play != None:
-                    logging.info("Chose new play: '" + self.play.__class__.__name__ + "'")
-
+                    logging.info("Chose new play: '" +
+                                 self.play.__class__.__name__ + "'")
 
         # Role Assignment
         ################################################################################
         try:
-            assignments = role_assignment.assign_roles(self.robots, self.role_requirements())
+            assignments = role_assignment.assign_roles(
+                self.robots, self.role_requirements())
         except role_assignment.ImpossibleAssignmentError as e:
-            logging.error("Unable to satisfy role assignment constraints.  Dropping and temp. blacklisting current play...")
+            logging.error(
+                "Unable to satisfy role assignment constraints.  Dropping and temp. blacklisting current play...")
             self.drop_current_play(temporarily_blacklist=True)
         else:
             self.assign_roles(assignments)
 
-
-
     def handle_subbehavior_exception(self, name, exception):
         if name == 'goalie':
-            logging.error("Goalie encountered an exception: " + str(exception) + ".  Reloading goalie behavior")
+            logging.error("Goalie encountered an exception: " + str(exception)
+                          + ".  Reloading goalie behavior")
             traceback.print_exc()
             self.drop_goalie_behavior()
         else:
-            logging.error("Play '" + self.play.__class__.__name__ + "' encountered an exception: " + str(exception) + ".  Dropping and temp. blacklisting current play...")
+            logging.error("Play '" + self.play.__class__.__name__ +
+                          "' encountered an exception: " + str(exception) +
+                          ".  Dropping and temp. blacklisting current play...")
             traceback.print_exc()
             self.drop_current_play(temporarily_blacklist=True)
 
-
     # this is used to force a reselection of a play
     def drop_current_play(self, temporarily_blacklist=False):
         self.temporarily_blacklisted_play_class = self.play.__class__
         self.play = None
 
-
     # this is called when the goalie behavior must be reloaded (for example when the goalie.py file is modified)
     def drop_goalie_behavior(self):
         if self.has_subbehavior_with_name('goalie'):
             self.remove_subbehavior('goalie')
         self.setup_goalie_if_needed()
 
-
     @property
     def play(self):
         return self._play
+
     @play.setter
     def play(self, value):
         # trash old play
@@ -156,21 +173,21 @@
         self.setup_goalie_if_needed()
 
         # change notification so ui can update if necessary
-        self.play_changed.emit(self.play.__class__.__name__ if self._play != None else "(No Play)")
-
+        self.play_changed.emit(self.play.__class__.__name__ if self._play !=
+                               None else "(No Play)")
 
     ## the c++ GameplayModule reaches through the language portal and sets this
     # note that in c++, a value of -1 indicates no assigned goalie, in python we represent the same thing with None
     @property
     def goalie_id(self):
         return self._goalie_id
+
     @goalie_id.setter
     def goalie_id(self, value):
         self._goalie_id = None if value == -1 else value
         self.setup_goalie_if_needed()
         logging.info("goalie_id set to: " + str(self._goalie_id))
 
-
     def setup_goalie_if_needed(self):
         if self.goalie_id == None:
             if self.has_subbehavior_with_name('goalie'):
@@ -187,14 +204,13 @@
             if goalie != None:
                 goalie.shell_id = self.goalie_id
 
-
     @property
     def robots(self):
         return self._robots
+
     @robots.setter
     def robots(self, robots):
         self._robots = robots if robots != None else []
 
-
     def __str__(self):
         return '\n'.join([str(bhvr) for bhvr in self.all_subbehaviors()])

--- a/soccer/gameplay/tactics/stopped/circle_on_center.py
+++ b/soccer/gameplay/tactics/stopped/circle_on_center.py
@@ -10,43 +10,44 @@
 
 ## Robots position themselves along a portion of the circle centered at the ball
 class CircleOnCenter(composite_behavior.CompositeBehavior):
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
         self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            lambda: self.all_subbehaviors_completed(),
-            'all robots reach target positions')
+                            behavior.Behavior.State.completed,
+                            lambda: self.all_subbehaviors_completed(),
+                            'all robots reach target positions')
         self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
-            lambda: not self.all_subbehaviors_completed(),
-            "robots aren't lined up")
+                            behavior.Behavior.State.running,
+                            lambda: not self.all_subbehaviors_completed(),
+                            "robots aren't lined up")
 
         # Define circle to circle up on
         radius = constants.Field.CenterRadius + constants.Robot.Radius + 0.01
 
-        perRobot = (2 * constants.Robot.Radius* 1.25) / radius
+        perRobot = (2 * constants.Robot.Radius * 1.25) / radius
 
         ball_pos = robocup.Point(0, constants.Field.Length / 2)
 
-        dirvec = (robocup.Point(0,0) - ball_pos).normalized() * radius
+        dirvec = (robocup.Point(0, 0) - ball_pos).normalized() * radius
 
         for i in range(6):
             pt = ball_pos + dirvec
-            self.add_subbehavior(skills.move.Move(pt), name="robot" + str(i), required=False, priority=6 - i)
-            dirvec.rotate(robocup.Point(0,0), perRobot)
-
+            self.add_subbehavior(
+                skills.move.Move(pt),
+                name="robot" + str(i),
+                required=False,
+                priority=6 - i)
+            dirvec.rotate(robocup.Point(0, 0), perRobot)
 
     def goto_center(self):
         num_robots = 0
         for b in self.all_subbehaviors():
             if b.robot is not None:
-                num_robots+=1
+                num_robots += 1
 
         radius = constants.Field.CenterRadius + constants.Robot.Radius + 0.01
 
@@ -54,13 +55,13 @@
 
         ball_pos = robocup.Point(0, constants.Field.Length / 2)
 
-        dirvec = (robocup.Point(0,0) - ball_pos).normalized() * radius
-        dirvec.rotate(robocup.Point(0,0), -perRobot * ((num_robots - 1) / 2))
+        dirvec = (robocup.Point(0, 0) - ball_pos).normalized() * radius
+        dirvec.rotate(robocup.Point(0, 0), -perRobot * ((num_robots - 1) / 2))
 
         for i in range(6):
             pt = ball_pos + dirvec
             self.subbehavior_with_name("robot" + str(i)).pos = pt
-            dirvec.rotate(robocup.Point(0,0), perRobot)
+            dirvec.rotate(robocup.Point(0, 0), perRobot)
 
         # set robot attributes
         for b in self.all_subbehaviors():
@@ -69,8 +70,6 @@
                 b.robot.face(main.ball().pos)
                 b.robot.avoid_all_teammates(True)
 
-
-
     def execute_completed(self):
         self.goto_center()
 

--- a/soccer/gameplay/tactics/coordinated_pass.py
+++ b/soccer/gameplay/tactics/coordinated_pass.py
@@ -25,12 +25,10 @@
 
     KickPower = 0.6
 
-
     class State(enum.Enum):
-        preparing = 1   # the kicker is aiming and the receiver is getting ready
-        kicking = 2     # waiting for the kicker to kick
-        receiving = 3   # the kicker has kicked and the receiver is trying to get the ball
-
+        preparing = 1  # the kicker is aiming and the receiver is getting ready
+        kicking = 2  # waiting for the kicker to kick
+        receiving = 3  # the kicker has kicked and the receiver is trying to get the ball
 
     ## Skillreceiver is a class that will handle the receiving robot. See pass_receive and angle_receive.
     # Using this, you can change what the receiving robot does (rather than just receiving the ball, it can pass or shoot it).
@@ -48,39 +46,36 @@
         for state in CoordinatedPass.State:
             self.add_state(state, behavior.Behavior.State.running)
 
-
         self.add_transition(behavior.Behavior.State.start,
-            CoordinatedPass.State.preparing,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(CoordinatedPass.State.preparing,
-            CoordinatedPass.State.kicking,
-            lambda: (self.subbehavior_with_name('kicker').state == skills.pivot_kick.PivotKick.State.aimed
-                and self.subbehavior_with_name('receiver').state == self.skillreceiver.State.aligned),
+                            CoordinatedPass.State.preparing, lambda: True,
+                            'immediately')
+
+        self.add_transition(
+            CoordinatedPass.State.preparing, CoordinatedPass.State.kicking,
+            lambda: (self.subbehavior_with_name('kicker').state == skills.pivot_kick.PivotKick.State.aimed and self.subbehavior_with_name('receiver').state == self.skillreceiver.State.aligned),
             'kicker and receiver ready')
 
-        self.add_transition(CoordinatedPass.State.kicking,
-            CoordinatedPass.State.receiving,
+        self.add_transition(
+            CoordinatedPass.State.kicking, CoordinatedPass.State.receiving,
             lambda: self.subbehavior_with_name('kicker').state == behavior.Behavior.State.completed,
             'kicker kicked')
 
-        self.add_transition(CoordinatedPass.State.receiving,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            CoordinatedPass.State.receiving, behavior.Behavior.State.completed,
             lambda: self.subbehavior_with_name('receiver').state == behavior.Behavior.State.completed,
             'pass received!')
 
-        self.add_transition(CoordinatedPass.State.receiving,
-            behavior.Behavior.State.failed,
+        self.add_transition(
+            CoordinatedPass.State.receiving, behavior.Behavior.State.failed,
             lambda: self.subbehavior_with_name('receiver').state == behavior.Behavior.State.failed,
             'pass failed :(')
 
-
     # set the location where the receiving bot should camp out and wait for the ball
     # Default: None
     @property
     def receive_point(self):
         return self._receive_point
+
     @receive_point.setter
     def receive_point(self, value):
         self._receive_point = value
@@ -89,9 +84,8 @@
         if self.has_subbehavior_with_name('kicker'):
             self.subbehavior_with_name('kicker').target = self.receive_point
         if self.has_subbehavior_with_name('receiver'):
-            self.subbehavior_with_name('receiver').receive_point = self.receive_point
-
-
+            self.subbehavior_with_name(
+                'receiver').receive_point = self.receive_point
 
     def on_enter_running(self):
         receiver = self.skillreceiver
@@ -99,15 +93,12 @@
         receiver.receive_point = self.receive_point
         self.add_subbehavior(receiver, 'receiver', required=True)
 
-
     def on_exit_running(self):
         self.remove_subbehavior('receiver')
 
-
     def on_enter_kicking(self):
         self.subbehavior_with_name('kicker').enable_kick = True
 
-
     def on_enter_preparing(self):
         kicker = skills.pivot_kick.PivotKick()
         kicker.target = self.receive_point
@@ -118,7 +109,7 @@
         if (kickpower > 1.0):
             kickpower = 1.0
         kicker.kick_power = kickpower
-        kicker.enable_kick = False # we'll re-enable kick once both bots are ready
+        kicker.enable_kick = False  # we'll re-enable kick once both bots are ready
 
         # we use tighter error thresholds because passing is hard
         kicker.aim_params['error_threshold'] = 0.2
@@ -131,7 +122,6 @@
         self._last_unsteady_time = None
         self._has_renegotiated_receive_point = False
 
-
     def execute_running(self):
         # The shot obstacle doesn't apply to the receiver
         if self.has_subbehavior_with_name('kicker'):
@@ -154,36 +144,32 @@
             toReturn.extend([kicker.robot])
         return toReturn
 
-
     def execute_preparing(self):
         kicker = self.subbehavior_with_name('kicker')
 
         # receive point renegotiation
         # if the kicker sits there aiming close to target and gets stuck,
         # we set the receive point to the point the kicker is currently aiming at
-        if kicker.current_shot_point() != None and not self._has_renegotiated_receive_point:
-            if (not kicker.is_steady()
-                and kicker.state == skills.pivot_kick.PivotKick.State.aiming):
+        if kicker.current_shot_point(
+        ) != None and not self._has_renegotiated_receive_point:
+            if (not kicker.is_steady() and
+                    kicker.state == skills.pivot_kick.PivotKick.State.aiming):
                 self._last_unsteady_time = time.time()
 
-            if (self._last_unsteady_time != None
-                and time.time() - self._last_unsteady_time > 0.75
-                and kicker.current_shot_point().dist_to(self.receive_point) < 0.1):
+            if (self._last_unsteady_time != None and
+                    time.time() - self._last_unsteady_time > 0.75 and
+                    kicker.current_shot_point().dist_to(self.receive_point) <
+                    0.1):
                 # renegotiate receive_point
                 logging.info("Pass renegotiated RCV PT")
                 self.receive_point = kicker.current_shot_point()
                 self._has_renegotiated_receive_point = True
 
-
     def on_enter_receiving(self):
         # once the ball's been kicked, the kicker can go relax or do another job
         self.subbehavior_with_name('receiver').ball_kicked = True
         self.remove_subbehavior('kicker')
 
-        
-
-
-
     def __str__(self):
         desc = super().__str__()
         desc += "\n    rcv_pt=" + str(self.receive_point)

--- a/soccer/gameplay/tests/test_constants.py
+++ b/soccer/gameplay/tests/test_constants.py
@@ -10,5 +10,6 @@
 
         out_zone = robocup.Point(0, constants.Field.Length / 2.0)
 
-        self.assertTrue(constants.Field.OurGoalZoneShape.contains_point(in_zone))
+        self.assertTrue(constants.Field.OurGoalZoneShape.contains_point(
+            in_zone))
         # self.assertFalse(constants.Field.OurGoalZoneShape.contains_point(out_zone))

--- a/soccer/gameplay/skills/line_kick.py
+++ b/soccer/gameplay/skills/line_kick.py
@@ -18,18 +18,16 @@
     EscapeChargeThresh = 0.1
     DefaultSetupBallAvoid = 0.15
     AccelBias = 0.2
-    FacingThresh = 10   # angle in degrees
+    FacingThresh = 10  # angle in degrees
     MaxChargeSpeed = 1.5
     BallProjectTime = 0.4
     DoneStateThresh = 0.11
     ClosenessThreshold = constants.Robot.Radius + 0.04
 
-
     class State(enum.Enum):
         setup = 1
         charge = 2
 
-
     def __init__(self):
         super().__init__()
 
@@ -42,78 +40,81 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            LineKick.State.setup,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(LineKick.State.setup,
-            LineKick.State.charge,
-            lambda: ( not self.robot_is_between_ball_and_target() ) and self._target_line.dist_to(self.robot.pos) < self.ChargeThresh and not self.robot.just_kicked(),
+                            LineKick.State.setup, lambda: True, 'immediately')
+
+        self.add_transition(
+            LineKick.State.setup, LineKick.State.charge,
+            lambda: (not self.robot_is_between_ball_and_target()) and self._target_line.dist_to(self.robot.pos) < self.ChargeThresh and not self.robot.just_kicked(),
             "robot on line")
 
-        self.add_transition(LineKick.State.charge,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            LineKick.State.charge, behavior.Behavior.State.completed,
             lambda: self.robot is not None and self._got_close and self.robot.just_kicked(),
             "robot kicked")
 
-        self.add_transition(LineKick.State.charge,
-            LineKick.State.setup,
+        self.add_transition(
+            LineKick.State.charge, LineKick.State.setup,
             lambda: self.robot_is_between_ball_and_target() or self._target_line.dist_to(self.robot.pos) > self.ChargeThresh,
             "robot between ball and target")
 
-
     ## We use the path planner to move to a point this distance away from the
     # ball and on the opposite side of where we're aiming
     @property
     def drive_around_dist(self):
         return self._drive_around_dist
+
     @drive_around_dist.setter
     def drive_around_dist(self, value):
         self._drive_around_dist = value
 
-
     ## The avoid ball radius for while we're getting to the setup point
     @property
     def setup_ball_avoid(self):
         return self._setup_ball_avoid
+
     @setup_ball_avoid.setter
     def setup_ball_avoid(self, value):
         self._setup_ball_avoid = value
 
-
-
     def robot_is_between_ball_and_target(self):
         return self.robot is not None and \
             self.robot.pos.dist_to(self.aim_target_point) < main.ball().pos.dist_to(self.aim_target_point)
 
-
     def recalculate(self):
-        self._target_line = robocup.Line(main.ball().pos, self.aim_target_point)
+        self._target_line = robocup.Line(main.ball().pos,
+                                         self.aim_target_point)
         # FIXME: errors?
 
-
     def on_exit_start(self):
         super().recalculate_aim_target_point()
 
-
     def execute_running(self):
         self.recalculate()
         super().execute_running()
 
-
     def execute_setup(self):
-        move_goal = main.ball().pos - self._target_line.delta().normalized() * (self.drive_around_dist + constants.Robot.Radius)
+        move_goal = main.ball().pos - self._target_line.delta().normalized(
+        ) * (self.drive_around_dist + constants.Robot.Radius)
 
-        left_field_edge = robocup.Segment(robocup.Point(-constants.Field.Width / 2.0 - constants.Robot.Radius, 0),
-            robocup.Point(-constants.Field.Width / 2.0 - constants.Robot.Radius, constants.Field.Length))
-        right_field_edge = robocup.Segment(robocup.Point(constants.Field.Width / 2.0 + constants.Robot.Radius, 0),
-            robocup.Point(constants.Field.Width / 2.0 + constants.Robot.Radius, constants.Field.Length))
+        left_field_edge = robocup.Segment(
+            robocup.Point(
+                -constants.Field.Width / 2.0 - constants.Robot.Radius, 0),
+            robocup.Point(-constants.Field.Width / 2.0 -
+                          constants.Robot.Radius, constants.Field.Length))
+        right_field_edge = robocup.Segment(
+            robocup.Point(constants.Field.Width / 2.0 + constants.Robot.Radius,
+                          0),
+            robocup.Point(constants.Field.Width / 2.0 + constants.Robot.Radius,
+                          constants.Field.Length))
 
         # handle the case when the ball is near the field's edge
         field_edge_thresh = 0.3
-        behind_line = robocup.Segment(main.ball().pos - self._target_line.delta().normalized() * self.drive_around_dist,
+        behind_line = robocup.Segment(
+            main.ball().pos - self._target_line.delta().normalized() *
+            self.drive_around_dist,
             main.ball().pos - self._target_line.delta().normalized())
-        main.system_state().draw_line(behind_line, constants.Colors.Blue, "LineKick")
+        main.system_state().draw_line(behind_line, constants.Colors.Blue,
+                                      "LineKick")
         for edge in [left_field_edge, right_field_edge]:
             if edge.near_point(main.ball().pos, field_edge_thresh):
                 intersection = behind_line.line_intersection(edge)
@@ -122,23 +123,29 @@
 
         self.robot.set_avoid_ball_radius(self.setup_ball_avoid)
         self.robot.move_to(move_goal)
-        self.robot.face(self.robot.pos + (self.aim_target_point - main.ball().pos))
+        self.robot.face(self.robot.pos + (self.aim_target_point - main.ball(
+        ).pos))
         self.robot.unkick()
 
-
     def execute_charge(self):
-        main.system_state().draw_line(robocup.Line(self.robot.pos, self.aim_target_point), constants.Colors.White, "LineKick")
-        main.system_state().draw_line(robocup.Line(main.ball().pos, self.aim_target_point), constants.Colors.White, "LineKick")
+        main.system_state().draw_line(
+            robocup.Line(self.robot.pos, self.aim_target_point),
+            constants.Colors.White, "LineKick")
+        main.system_state().draw_line(
+            robocup.Line(main.ball().pos, self.aim_target_point),
+            constants.Colors.White, "LineKick")
 
         # drive directly into the ball
         ball2target = (self.aim_target_point - main.ball().pos).normalized()
         robot2ball = (main.ball().pos - self.robot.pos).normalized()
-        speed = min(self.robot.vel.mag() + LineKick.AccelBias, self.MaxChargeSpeed)
+        speed = min(self.robot.vel.mag() + LineKick.AccelBias,
+                    self.MaxChargeSpeed)
         self.robot.set_world_vel(robot2ball.normalized() * speed)
 
         self.robot.face(self.aim_target_point)
 
-        if main.ball().pos.dist_to(self.robot.pos) < LineKick.ClosenessThreshold:
+        if main.ball().pos.dist_to(
+                self.robot.pos) < LineKick.ClosenessThreshold:
             self._got_close = True
 
         if self._got_close:
@@ -147,7 +154,6 @@
             else:
                 self.robot.kick(self.kick_power)
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         # try to be near the ball

--- a/soccer/gameplay/skills/aim.py
+++ b/soccer/gameplay/skills/aim.py
@@ -15,40 +15,33 @@
 # the 'aimed' state, which is a substate of running.  It may change back from 'aimed' to
 # 'aiming' if it's parameters change or due to external conditions.
 class Aim(single_robot_behavior.SingleRobotBehavior):
-
     class State(enum.Enum):
         aiming = 1
         aimed = 2
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
         self.add_state(Aim.State.aiming, behavior.Behavior.State.running)
         self.add_state(Aim.State.aimed, behavior.Behavior.State.running)
 
-        self.add_transition(behavior.Behavior.State.start,
-            Aim.State.aiming,
-            lambda: True,
-            'immediately')
+        self.add_transition(behavior.Behavior.State.start, Aim.State.aiming,
+                            lambda: True, 'immediately')
 
         for state in Aim.State:
-            self.add_transition(state,
-                behavior.Behavior.State.failed,
-                lambda: self.fumbled(),
-                'fumble')
+            self.add_transition(state, behavior.Behavior.State.failed,
+                                lambda: self.fumbled(), 'fumble')
 
-        self.add_transition(Aim.State.aiming,
-            Aim.State.aimed,
+        self.add_transition(
+            Aim.State.aiming, Aim.State.aimed,
             lambda: ((self.is_aimed() and self.is_steady()) and not self.fumbled()) or self.is_desperate(),
             'error < threshold and not rotating too fast or desperate')
 
-        self.add_transition(Aim.State.aimed,
-            Aim.State.aiming,
+        self.add_transition(
+            Aim.State.aimed, Aim.State.aiming,
             lambda: (not self.is_aimed() or not self.is_steady()) and not self.is_desperate(),
             'error > threshold or rotating too fast')
 
-
         self.target_point = constants.Field.TheirGoalSegment.center()
         self.error_threshold = 0.06
         self.max_steady_ang_vel = 4
@@ -59,7 +52,7 @@
 
         # several different methods rely on these values, which are expensive to calculate
         # we recalculate in execute_running() and cache them in these ivars
-        self._shot_point = None # the point on the target line we'd hit if we shot now
+        self._shot_point = None  # the point on the target line we'd hit if we shot now
         self._error = float("inf")
 
         self._last_unsteady_time = time.time()
@@ -68,27 +61,26 @@
         self._start_time = 0
         self.desperate_timeout = float("inf")
 
-
     # The target Point that we're aiming at
     # Default: the center of the opponent's goal segment
     @property
     def target_point(self):
         return self._target_point
+
     @target_point.setter
     def target_point(self, value):
         self._target_point = value
 
-
     # error threshold is the max distance that we can be off to the side of the target
     # and be considered to have a good aim at it
     # Default: 0.05m
     @property
     def error_threshold(self):
         return self._error_threshold
+
     @error_threshold.setter
     def error_threshold(self, value):
         self._error_threshold = value
-    
 
     # We don't want to take a shot while we're rotating quickly, we want to be steady
     # This is the max angular velocity (degrees / sec) the robot can have and still be considered to be steady
@@ -96,70 +88,69 @@
     @property
     def max_steady_ang_vel(self):
         return self._max_steady_ang_vel
+
     @max_steady_ang_vel.setter
     def max_steady_ang_vel(self, value):
         self._max_steady_ang_vel = value
-    
 
     # Default: full power
     @property
     def dribbler_speed(self):
         return self._dribbler_speed
+
     @dribbler_speed.setter
     def dribbler_speed(self, value):
         self._dribbler_speed = int(value)
 
-
     # After this amount of time has elapsed, it will go into 'aimed' mode regardless of error thresholds,
     # Default: float("inf")
     @property
     def desperate_timeout(self):
         return self._desperate_timeout
+
     @desperate_timeout.setter
     def desperate_timeout(self, value):
         self._desperate_timeout = value
 
-
     # we have to be going less than max_steady_angle_vel for this amount of time to be considered steady
     @property
     def min_steady_duration(self):
         return self._min_steady_duration
+
     @min_steady_duration.setter
     def min_steady_duration(self, value):
         self._min_steady_duration = value
 
-
     # returns True if we're aimed at our target within our error thresholds and we're not rotating too fast
     def is_aimed(self):
         return self._error < self.error_threshold
 
-
     def is_steady(self):
-        return time.time() - self._last_unsteady_time > self.min_steady_duration
-
+        return time.time(
+        ) - self._last_unsteady_time > self.min_steady_duration
 
     def fumbled(self):
-        return not self.robot.has_ball() and time.time() - self.last_ball_time > 0.3
-
+        return not self.robot.has_ball() and time.time(
+        ) - self.last_ball_time > 0.3
 
     def current_shot_point(self):
         return self._shot_point
 
-
     # we're aiming at a particular point on our target segment, what is this point?
     def recalculate(self):
         if abs(self.robot.angle_vel) > self.max_steady_ang_vel:
             self._last_unsteady_time = time.time()
 
-
         # find the point we're actually aiming at that's on the line going through target_point
         # and perpendicular to the line from the ball to target_point
         if self.target_point == None:
             self._shot_point = None
         else:
             ball2target = self.target_point - main.ball().pos
-            target_line = robocup.Line(self.target_point, self.target_point + ball2target.perp_ccw()) # line perpendicular to aim_line that passes through the target
-            
+            target_line = robocup.Line(
+                self.target_point, self.target_point + ball2target.perp_ccw()
+            )  # line perpendicular to aim_line that passes through the target
+
             # ideally the angle we're aiming at would be the angle of the robot, but the bot doesn't kick straight
             # it tends to kick in the direction of the side of the mouth that the ball is in
             # we draw a line from the center of the bot through the ball and a line along the angle the bot is facing
@@ -170,8 +161,9 @@
             # if we detect this big of an error, we just default to using bot_angle_rad
             if abs(ball_angle_rad - bot_angle_rad) > math.pi / 3.0:
                 ball_angle_rad = bot_angle_rad
-            ball_angle_bias = 0.4   # NOTE: THIS IS TUNABLE
-            aim_angle = ball_angle_rad*ball_angle_bias + (1.0 - ball_angle_bias)*bot_angle_rad
+            ball_angle_bias = 0.4  # NOTE: THIS IS TUNABLE
+            aim_angle = ball_angle_rad * ball_angle_bias + (
+                1.0 - ball_angle_bias) * bot_angle_rad
 
             # the line we're aiming down
             angle_dir = robocup.Point.direction(aim_angle)
@@ -180,9 +172,10 @@
             # we need to change our face target a bit to account for the difference between bot angle and aim angle
             face_angle_offset = bot_angle_rad - aim_angle
             target_angle_rad = (self.target_point - self.robot.pos).angle()
-            face_dir_offset = robocup.Point.direction(target_angle_rad + face_angle_offset)
+            face_dir_offset = robocup.Point.direction(target_angle_rad +
+                                                      face_angle_offset)
             self._face_target = self.robot.pos + face_dir_offset
-            
+
             # self._shot_poitn is the point along target_line that we'll hit if we shoot now
             # We check to make sure we're not facing backwards from where we want to be or else
             # the line intersection will return us a point 180 degrees off from our aim angle
@@ -193,20 +186,20 @@
 
         # error
         if self.target_point != None and self._shot_point != None:
-            self._error = (self.target_point - self._shot_point).mag() if self._shot_point != None else float("inf") # distance in meters off that we'll be if we shoot right now
+            self._error = (
+                self.target_point -
+                self._shot_point).mag() if self._shot_point != None else float(
+                    "inf"
+                )  # distance in meters off that we'll be if we shoot right now
         else:
             self._error = float("inf")
 
-
     def on_exit_start(self):
         self._start_time = time.time()
 
-
     def is_desperate(self):
         return time.time() - self._start_time > self.desperate_timeout
 
-
-
     def execute_running(self):
         # make sure teammates don't bump into us
         self.robot.shield_from_teammates(constants.Robot.Radius * 2.0)
@@ -223,14 +216,17 @@
 
         # draw current shot line
         if self._shot_point != None:
-            color = constants.Colors.Green if self.is_aimed() else constants.Colors.Red
-            main.system_state().draw_line(robocup.Line(self.robot.pos, self._shot_point), color, "Aim")
-            main.system_state().draw_circle(self._shot_point, 0.02, color, "Aim")
+            color = constants.Colors.Green if self.is_aimed(
+            ) else constants.Colors.Red
+            main.system_state().draw_line(
+                robocup.Line(self.robot.pos, self._shot_point), color, "Aim")
+            main.system_state().draw_circle(self._shot_point, 0.02, color,
+                                            "Aim")
 
         # draw where we're supposed to be aiming
         if self.target_point != None:
-            main.system_state().draw_circle(self.target_point, 0.02, constants.Colors.Blue, "Aim")
-
+            main.system_state().draw_circle(self.target_point, 0.02,
+                                            constants.Colors.Blue, "Aim")
 
     def __str__(self):
         desc = super().__str__()
@@ -239,7 +235,6 @@
         desc += "\n    steady=" + str(self.is_steady())
         return desc
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         reqs.require_kicking = True

--- a/soccer/gameplay/skills/pass_receive.py
+++ b/soccer/gameplay/skills/pass_receive.py
@@ -9,12 +9,14 @@
 import role_assignment
 import skills
 
+
 ## PassReceive accepts a receive_point as a parameter and gets setup there to catch the ball
 # It transitions to the 'aligned' state once it's there within its error thresholds and is steady
 # Set its 'ball_kicked' property to True to tell it to dynamically update its position based on where
 # the ball is moving and attempt to catch it.
 # It will move to the 'completed' state if it catches the ball, otherwise it will go to 'failed'.
-class PassReceive(single_robot_composite_behavior.SingleRobotCompositeBehavior):
+class PassReceive(
+        single_robot_composite_behavior.SingleRobotCompositeBehavior):
 
     ## max difference between where we should be facing and where we are facing (in radians)
     FaceAngleErrorThreshold = 8 * constants.DegreesToRadians
@@ -29,7 +31,7 @@
 
     ## we have to be going slower than this to be considered 'steady'
     SteadyMaxVel = 0.04
-    SteadyMaxAngleVel = 3   # degrees / second
+    SteadyMaxAngleVel = 3  # degrees / second
 
     MarginAngle = math.pi / 18
     StabilizationFrames = 3
@@ -45,7 +47,6 @@
         ## the ball's been kicked and we're adjusting based on where the ball's moving
         receiving = 3
 
-
     def __init__(self):
         super().__init__(continuous=False)
 
@@ -58,81 +59,72 @@
         self.stable_frame = 0
         self.kicked_time = 0
 
-
         for state in PassReceive.State:
             self.add_state(state, behavior.Behavior.State.running)
 
-
         self.add_transition(behavior.Behavior.State.start,
-            PassReceive.State.aligning,
-            lambda: True,
-            'immediately')
+                            PassReceive.State.aligning, lambda: True,
+                            'immediately')
 
-        self.add_transition(PassReceive.State.aligning,
-            PassReceive.State.aligned,
+        self.add_transition(
+            PassReceive.State.aligning, PassReceive.State.aligned,
             lambda: self.errors_below_thresholds() and self.is_steady() and not self.ball_kicked,
             'steady and in position to receive')
 
-        self.add_transition(PassReceive.State.aligned,
-            PassReceive.State.aligning,
+        self.add_transition(
+            PassReceive.State.aligned, PassReceive.State.aligning,
             lambda: (not self.errors_below_thresholds() or not self.is_steady()) and not self.ball_kicked,
             'not in receive position')
 
         for state in [PassReceive.State.aligning, PassReceive.State.aligned]:
-            self.add_transition(state,
-                PassReceive.State.receiving,
-                lambda: self.ball_kicked,
-                'ball kicked')
+            self.add_transition(state, PassReceive.State.receiving,
+                                lambda: self.ball_kicked, 'ball kicked')
 
         self.add_transition(PassReceive.State.receiving,
-            behavior.Behavior.State.completed,
-            lambda: self.robot.has_ball(),
-            'ball received!')
+                            behavior.Behavior.State.completed,
+                            lambda: self.robot.has_ball(), 'ball received!')
 
-        self.add_transition(PassReceive.State.receiving,
-            behavior.Behavior.State.failed,
+        self.add_transition(
+            PassReceive.State.receiving, behavior.Behavior.State.failed,
             lambda: self.check_failure() or time.time() - self.kicked_time > PassReceive.DesperateTimeout,
             'ball missed :(')
 
-
-
     ## set this to True to let the receiver know that the pass has started and the ball's in motion
     # Default: False
     @property
     def ball_kicked(self):
         return self._ball_kicked
+
     @ball_kicked.setter
     def ball_kicked(self, value):
         self._ball_kicked = value
         if value:
             self._ball_kick_time = time.time()
 
-
     ## The point that the receiver should expect the ball to hit it's mouth
     # Default: None
     @property
     def receive_point(self):
         return self._receive_point
+
     @receive_point.setter
     def receive_point(self, value):
         self._receive_point = value
         self.recalculate()
 
-
     ## returns True if we're facing the right direction and in the right position and steady
     def errors_below_thresholds(self):
         if self.receive_point == None:
             return False
 
-        return (abs(self._angle_error) < PassReceive.FaceAngleErrorThreshold
-            and abs(self._x_error) < PassReceive.PositionXErrorThreshold
-            and abs(self._y_error) < PassReceive.PositionYErrorThreshold)
-
+        return (
+            abs(self._angle_error) < PassReceive.FaceAngleErrorThreshold and
+            abs(self._x_error) < PassReceive.PositionXErrorThreshold and
+            abs(self._y_error) < PassReceive.PositionYErrorThreshold)
 
     def is_steady(self):
-        return (self.robot.vel.mag() < PassReceive.SteadyMaxVel
-            and abs(self.robot.angle_vel) < PassReceive.SteadyMaxAngleVel)
-
+        return (self.robot.vel.mag() < PassReceive.SteadyMaxVel and
+                abs(self.robot.angle_vel) < PassReceive.SteadyMaxAngleVel)
 
     # calculates:
     # self._pass_line - the line from the ball along where we think we're going
@@ -145,12 +137,11 @@
         if self.receive_point == None or self.robot == None:
             return
 
-
         ball = main.ball()
 
         if self.ball_kicked:
             # when the ball's in motion, the line is based on the ball's velocity
-            self._pass_line = robocup.Line(ball.pos, ball.pos + ball.vel*10)
+            self._pass_line = robocup.Line(ball.pos, ball.pos + ball.vel * 10)
         else:
             # if the ball hasn't been kicked yet, we assume it's going to go through the receive point
             self._pass_line = robocup.Line(ball.pos, self.receive_point)
@@ -159,30 +150,28 @@
         angle_rad = self.robot.angle
         self._angle_error = target_angle_rad - angle_rad
 
-
         if self.ball_kicked:
-            actual_receive_point = self._pass_line.nearest_point(self.robot.pos)
+            actual_receive_point = self._pass_line.nearest_point(
+                self.robot.pos)
         else:
             actual_receive_point = self.receive_point
 
-        pass_line_dir = (self._pass_line.get_pt(1) - self._pass_line.get_pt(0)).normalized()
+        pass_line_dir = (
+            self._pass_line.get_pt(1) - self._pass_line.get_pt(0)).normalized()
         self._target_pos = actual_receive_point + pass_line_dir * constants.Robot.Radius
 
-
         # vector pointing down the pass line toward the kicker
-        pass_dir = (self._pass_line.get_pt(0) - self._pass_line.get_pt(1)).normalized()
+        pass_dir = (
+            self._pass_line.get_pt(0) - self._pass_line.get_pt(1)).normalized()
 
         pos_error = self._target_pos - self.robot.pos
         self._x_error = pos_error.dot(pass_dir.perp_ccw())
         self._y_error = pos_error.dot(pass_dir)
 
-
-
     def on_exit_start(self):
         # reset
         self.ball_kicked = False
 
-
     def execute_running(self):
         # make sure teammates don't bump into us
         self.robot.shield_from_teammates(constants.Robot.Radius * 2.0)
@@ -191,10 +180,10 @@
         self.robot.face(main.ball().pos)
 
         if self._pass_line != None:
-            main.system_state().draw_line(self._pass_line, constants.Colors.Blue, "Pass")
-            main.system_state().draw_circle(self._target_pos, 0.03, constants.Colors.Blue, "Pass")
-
-
+            main.system_state().draw_line(self._pass_line,
+                                          constants.Colors.Blue, "Pass")
+            main.system_state().draw_circle(self._target_pos, 0.03,
+                                            constants.Colors.Blue, "Pass")
 
     def execute_aligning(self):
         if self._target_pos != None:
@@ -202,7 +191,8 @@
 
     def reset_correct_location(self):
         # Extrapolate center of robot location from kick velocity
-        self.kicked_from = main.ball().pos #- (main.ball().vel / main.ball().vel.mag()) * constants.Robot.Radius * 4
+        self.kicked_from = main.ball(
+        ).pos  #- (main.ball().vel / main.ball().vel.mag()) * constants.Robot.Radius * 4
         self.kicked_vel = main.ball().vel
 
     def on_enter_receiving(self):
@@ -231,11 +221,11 @@
         pass_distance = pass_segment.mag() + 0.5
         pass_dir = pass_segment.normalized()
 
-        left_kick =  robocup.Point(-offset, -offset)
-        right_kick =  robocup.Point(offset, -offset)
+        left_kick = robocup.Point(-offset, -offset)
+        right_kick = robocup.Point(offset, -offset)
 
         # Create a channel on the left/right of the mouth of the kicker to a bit behind the receiver
-        left_recieve = left_kick + straight_line * pass_distance;
+        left_recieve = left_kick + straight_line * pass_distance
         right_recieve = right_kick + straight_line * pass_distance
 
         # Widen the channel to allow for catching the ball.
@@ -245,11 +235,11 @@
         origin = robocup.Point(0, 0)
 
         passDirRadians = pass_dir.angle()
-        left_kick.rotate(origin, passDirRadians - math.pi/2)
-        right_kick.rotate(origin, passDirRadians - math.pi/2)
+        left_kick.rotate(origin, passDirRadians - math.pi / 2)
+        right_kick.rotate(origin, passDirRadians - math.pi / 2)
 
-        left_recieve.rotate(origin, passDirRadians - math.pi/2)
-        right_recieve.rotate(origin, passDirRadians - math.pi/2)
+        left_recieve.rotate(origin, passDirRadians - math.pi / 2)
+        right_recieve.rotate(origin, passDirRadians - math.pi / 2)
 
         # Add points that create the good_area to a polygon
         good_area = robocup.Polygon()
@@ -259,10 +249,10 @@
         good_area.add_vertex(self.kicked_from + right_recieve)
         good_area.add_vertex(self.kicked_from + left_recieve)
 
-        main.system_state().draw_raw_polygon(good_area, constants.Colors.Green, "Good Pass Area")
+        main.system_state().draw_raw_polygon(good_area, constants.Colors.Green,
+                                             "Good Pass Area")
         return not good_area.contains_point(main.ball().pos)
 
-
     def execute_receiving(self):
         # Freeze ball position and velocity once Stabilizationframes is up.
         if self.stable_frame <= PassReceive.StabilizationFrames:
@@ -286,7 +276,6 @@
                 req.destination_shape = self.receive_point
         return reqs
 
-
     def __str__(self):
         desc = super().__str__()
         if self.receive_point != None and self.robot != None:

--- a/soccer/gameplay/tactics/line_up.py
+++ b/soccer/gameplay/tactics/line_up.py
@@ -9,8 +9,10 @@
 
     y_start = 1.0  # sometimes we have issues if we're right in the corner, so we move it up a bit
     DefaultLine = robocup.Segment(
-        robocup.Point(-constants.Field.Width/2 + constants.Robot.Radius, constants.Robot.Radius + y_start),
-        robocup.Point(-constants.Field.Width/2 + constants.Robot.Radius, (constants.Robot.Radius * 2 + 0.1 + y_start)*6))
+        robocup.Point(-constants.Field.Width / 2 + constants.Robot.Radius,
+                      constants.Robot.Radius + y_start),
+        robocup.Point(-constants.Field.Width / 2 + constants.Robot.Radius,
+                      (constants.Robot.Radius * 2 + 0.1 + y_start) * 6))
 
     def __init__(self, line=None):
         super().__init__(continuous=False)
@@ -18,37 +20,39 @@
         self.line = line if line != None else LineUp.DefaultLine
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
         self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            lambda: self.all_subbehaviors_completed(),
-            'all robots reach target positions')
+                            behavior.Behavior.State.completed,
+                            lambda: self.all_subbehaviors_completed(),
+                            'all robots reach target positions')
         self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
-            lambda: not self.all_subbehaviors_completed(),
-            'robots arent lined up')
-
+                            behavior.Behavior.State.running,
+                            lambda: not self.all_subbehaviors_completed(),
+                            'robots arent lined up')
 
     def execute_running(self):
         for i in range(6):
-            pt = self._line.get_pt(0) + ( self.diff * float(i) )
+            pt = self._line.get_pt(0) + (self.diff * float(i))
             self.subbehavior_with_name("robot" + str(i)).pos = pt
 
     @property
     def line(self):
         return self._line
+
     @line.setter
     def line(self, value):
         self._line = value
-        self.diff = (self._line.get_pt(1) - self._line.get_pt(0)).normalized() * ( self._line.length() / 6.0)
+        self.diff = (
+            self._line.get_pt(1) - self._line.get_pt(0)).normalized() * (
+                self._line.length() / 6.0)
 
         # add subbehaviors for all robots, instructing them to line up
         self.remove_all_subbehaviors()
         for i in range(6):
-            pt = self._line.get_pt(0) + ( self.diff * float(i)  )
-            self.add_subbehavior(skills.move.Move(pt),
+            pt = self._line.get_pt(0) + (self.diff * float(i))
+            self.add_subbehavior(
+                skills.move.Move(pt),
                 name="robot" + str(i),
                 required=False,
                 priority=6 - i)

--- a/soccer/gameplay/skills/bump.py
+++ b/soccer/gameplay/skills/bump.py
@@ -11,19 +11,17 @@
 class Bump(single_robot_behavior.SingleRobotBehavior):
 
     # tuneable constants
-    DriveAroundDist = 0.35                          # how far away from the ball we should stay in the lineup state
-    LineupBallAvoidRadius = 0.043                   # ball avoid radius
+    DriveAroundDist = 0.35  # how far away from the ball we should stay in the lineup state
+    LineupBallAvoidRadius = 0.043  # ball avoid radius
     FacingThresh = 10 * constants.DegreesToRadians  # angle in radians that we must be less than away from the ball
-    AccelBias = 0.1                                 # how much to add to our desired speed
-    EscapeChargeThresh = 0.1                        # if we're off by this much, we go back to the lineup state
-    LineupToChargeThresh = 0.05                     # how close we have to be to our target line to enter the charge state
-
+    AccelBias = 0.1  # how much to add to our desired speed
+    EscapeChargeThresh = 0.1  # if we're off by this much, we go back to the lineup state
+    LineupToChargeThresh = 0.05  # how close we have to be to our target line to enter the charge state
 
     class State(enum.Enum):
         lineup = 1
         charge = 2
 
-
     def __init__(self):
         super().__init__(continuous=False)
 
@@ -32,82 +30,80 @@
         self.add_state(Bump.State.lineup, behavior.Behavior.State.running)
         self.add_state(Bump.State.charge, behavior.Behavior.State.running)
 
-        self.add_transition(behavior.Behavior.State.start,
-            Bump.State.lineup,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(Bump.State.lineup,
-            Bump.State.charge,
-            lambda: self.target_line().dist_to(self.robot.pos) <= Bump.LineupToChargeThresh
-                and self.target_line().delta().dot(self.robot.pos - main.ball().pos) <= -constants.Robot.Radius
-                and not self.facing_err_above_threshold(),
+        self.add_transition(behavior.Behavior.State.start, Bump.State.lineup,
+                            lambda: True, 'immediately')
+
+        self.add_transition(
+            Bump.State.lineup, Bump.State.charge,
+            lambda: self.target_line().dist_to(self.robot.pos) <= Bump.LineupToChargeThresh and self.target_line().delta().dot(self.robot.pos - main.ball().pos) <= -constants.Robot.Radius and not self.facing_err_above_threshold(),
             'lined up')
 
         # FIXME: this condition was never setup in the C++ one...
-        self.add_transition(Bump.State.charge,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            Bump.State.charge, behavior.Behavior.State.completed,
             lambda: (main.ball().pos - self.robot.pos).mag() < (constants.Robot.Radius + constants.Ball.Radius + 0.03),
             'ball has been bumped')
 
-        self.add_transition(Bump.State.charge,
-            Bump.State.lineup,
+        self.add_transition(
+            Bump.State.charge, Bump.State.lineup,
             lambda: robocup.Line(self.robot.pos, self.target).dist_to(main.ball().pos) > Bump.EscapeChargeThresh,
             'bad ball placement')
 
-
     ## the Point we're trying to bump the ball towards
     @property
     def target(self):
         return self._target
+
     @target.setter
     def target(self, value):
         self._target = value
 
-
     def facing_err_above_threshold(self):
-        dirVec = robocup.Point(math.cos(self.robot.angle),
-            math.sin(self.robot.angle))
+        dirVec = robocup.Point(
+            math.cos(self.robot.angle), math.sin(self.robot.angle))
         facing_thresh = math.cos(Bump.FacingThresh)
-        facing_err = dirVec.dot( (self.target - main.ball().pos).normalized() )
+        facing_err = dirVec.dot((self.target - main.ball().pos).normalized())
         # NOTE: yes, the comparator is backwards, that's the way it was in the c++ one...
         # TODO: remove the above note and clarify what's going on
         return facing_err < facing_thresh
 
-
     # line from ball to target
     def target_line(self):
         return robocup.Line(main.ball().pos, self.target)
 
-
     def execute_lineup(self):
         target_line = self.target_line()
         target_dir = target_line.delta().normalized()
-        behind_line = robocup.Segment(main.ball().pos - target_dir * (Bump.DriveAroundDist + constants.Robot.Radius),
+        behind_line = robocup.Segment(
+            main.ball().pos - target_dir *
+            (Bump.DriveAroundDist + constants.Robot.Radius),
             main.ball().pos - target_dir * 5.0)
-        if target_line.delta().dot(self.robot.pos - main.ball().pos) > -constants.Robot.Radius:
+        if target_line.delta().dot(self.robot.pos - main.ball(
+        ).pos) > -constants.Robot.Radius:
             # we're very close to or in front of the ball
             self.robot.set_avoid_ball_radius(Bump.LineupBallAvoidRadius)
-            self.robot.move_to(main.ball().pos - target_dir * (Bump.DriveAroundDist + constants.Robot.Radius))
+            self.robot.move_to(main.ball().pos - target_dir * (
+                Bump.DriveAroundDist + constants.Robot.Radius))
         else:
             self.robot.set_avoid_ball_radius(Bump.LineupBallAvoidRadius)
             self.robot.move_to(behind_line.nearest_point(self.robot.pos))
-            main.system_state().draw_line(behind_line, constants.Colors.Black, "Bump")
+            main.system_state().draw_line(behind_line, constants.Colors.Black,
+                                          "Bump")
 
         delta_facing = self.target - main.ball().pos
         self.robot.face(self.robot.pos + delta_facing)
 
-
     def execute_charge(self):
-        main.system_state().draw_line(robocup.Line(self.robot.pos, self.target),
-            constants.Colors.White,
+        main.system_state().draw_line(
+            robocup.Line(self.robot.pos, self.target), constants.Colors.White,
             "bump")
-        main.system_state().draw_line(robocup.Line(main.ball().pos, self.target),
-            constants.Colors.White,
+        main.system_state().draw_line(
+            robocup.Line(main.ball().pos, self.target), constants.Colors.White,
             "bump")
 
         ball2target = (self.target - main.ball().pos).normalized()
-        drive_dir = (main.ball().pos - ball2target * constants.Robot.Radius) - self.robot.pos
+        drive_dir = (main.ball().pos - ball2target *
+                     constants.Robot.Radius) - self.robot.pos
 
         # we want to drive toward the ball without using the path planner
         # we do this by setting the speed directly

--- a/soccer/gameplay/tactics/positions/defender.py
+++ b/soccer/gameplay/tactics/positions/defender.py
@@ -9,255 +9,271 @@
 
 ## The Defender behavior positions a robot on a certain area of the field and defends it
 class Defender(single_robot_behavior.SingleRobotBehavior):
+    class State(Enum):
+        ## gets between a particular opponent and the goal.  stays closer to the goal
+        marking = 1
+
+        ## chilling out in a zone waiting to mark an opponent.  doesn't do this much
+        area_marking = 2
+
+    ## The area of the field this robot should block
+    class Side(Enum):
+        left = 1
+        center = 2
+        right = 3
+
+    def __init__(self, side=Side.center):
+        super().__init__(continuous=True)
+        self._block_robot = None
+        self._area = None
+        self._side = side
+        self._opponent_avoid_threshold = 2.0
+        self._defend_goal_radius = 0.9
+        self._win_eval = robocup.WindowEvaluator(main.system_state())
+
+        self._area = robocup.Rect(
+            robocup.Point(-constants.Field.Width / 2.0,
+                          constants.Field.Length),
+            robocup.Point(constants.Field.Width / 2.0, 0))
+        if self._side is Defender.Side.right:
+            self._area.get_pt(0).x = 0
+        if self._side is Defender.Side.left:
+            self._area.get_pt(1).x = 0
+
+        self.add_state(Defender.State.marking, behavior.Behavior.State.running)
+        self.add_state(Defender.State.area_marking,
+                       behavior.Behavior.State.running)
+
+        self.add_transition(behavior.Behavior.State.start,
+                            Defender.State.marking, lambda: True,
+                            "immediately")
+        self.add_transition(
+            Defender.State.marking, Defender.State.area_marking,
+            lambda: not self._area.contains_point(main.ball().pos) and self.block_robot is None,
+            "if ball not in area and no robot to block")
+        self.add_transition(
+            Defender.State.area_marking, Defender.State.marking,
+            lambda: self._area.contains_point(main.ball().pos) or self.find_robot_to_block() is not None,
+            "if ball or opponent enters my area")
+
+    def execute_marking(self):
+        #main.system_state().draw_line(robocup.Line(self._area.get_pt(0), self._area.get_pt(1)), (127,0,255), "Defender")
+        self.block_robot = self.find_robot_to_block()
+        if self.block_robot is not None:
+            # self.robot.add_text("Blocking Robot " + str(self.block_robot.shell_id()), (255,255,255), "RobotText")
+            pass
+        if self.robot.pos.near_point(
+                robocup.Point(0, 0), self._opponent_avoid_threshold):
+            self.robot.set_avoid_opponents(False)
+        else:
+            self.robot.set_avoid_opponents(True)
+
+        target = None
+        if self.block_robot is None:
+            target = main.ball().pos + main.ball().vel * 0.3
+        else:
+            target = self.block_robot.pos + self.block_robot.vel * 0.3
+
+        goal_line = robocup.Segment(
+            robocup.Point(-constants.Field.GoalWidth / 2.0, 0),
+            robocup.Point(constants.Field.GoalWidth / 2.0, 0))
+
+        self._win_eval.excluded_robots = [self.robot]
+
+        # TODO defenders should register themselves with some static list on init
+        # TODO make this happen in python-land
+        # for (Defender *f :  otherDefenders)
+        # {
+        # 	if (f->robot)
+        # 	{
+        # 		_winEval.exclude.push_back(f->robot->pos);
+        # 	}
+        # }
+
+        windows = self._win_eval.eval_pt_to_seg(target, goal_line)[0]
+
+        best = None
+        goalie = main.our_robot_with_id(main.root_play().goalie_id)
+
+        if goalie is not None and self.side is not Defender.Side.center:
+            for window in windows:
+                if best is None:
+                    best = window
+                elif self.side is Defender.Side.left and window.segment.center.x < goalie.pos.x and window.segment.length > best.segment.length:
+                    best = window
+                elif self.side is Defender.Side.right and window.segment.center.x > goalie.pos.x and window.segment.length > best.segment.length:
+                    best = window
+        else:
+            best_dist = 0
+            for window in windows:
+                seg = robocup.Segment(window.segment.center(), main.ball().pos)
+                new_dist = seg.dist_to(self.robot.pos)
+                if best is None or new_dist < best_dist:
+                    best = window
+                    best_dist = new_dist
+
+        shoot_seg = None
+        if best is not None:
+            if self.block_robot is not None:
+                dirvec = robocup.Point.direction(self.block_robot.angle *
+                                                 (math.pi / 180.0))
+                shoot_seg = robocup.Segment(
+                    self.block_robot.pos, self.block_robot.pos + dirvec * 7.0)
+            else:
+                shoot_seg = robocup.Segment(main.ball().pos, main.ball().pos +
+                                            main.ball().vel.normalized() * 7.0)
+
+        need_task = False
+        if best is not None:
+            winseg = best.segment
+            if main.ball().vel.magsq() > 0.03 and winseg.segment_intersection(
+                    shoot_seg) != None:
+                self.robot.move_to(shoot_seg.nearest_point(self.robot.pos))
+                self.robot.face_none()
+            else:
+                winsize = winseg.length()
+
+                if winsize < constants.Ball.Radius:
+                    need_task = True
+                else:
+                    arc = robocup.Circle(
+                        robocup.Point(0, 0), self._defend_goal_radius)
+                    shot = robocup.Line(winseg.center(), target)
+                    dest = [robocup.Point(0, 0), robocup.Point(0, 0)]
+
+                    intersected, dest[0], dest[1] = shot.intersects_circle(arc)
+
+                    if intersected:
+                        self.robot.move_to(dest[0] if dest[0].y > 0 else dest[
+                            1])
+                        if self.block_robot is not None:
+                            self.robot.face(self.block_robot.pos)
+                        else:
+                            self.robot.face(main.ball().pos)
+                    else:
+                        need_task = True
+        if need_task:
+            self.robot.face(main.ball().pos)
+
+        backVec = robocup.Point(1, 0)
+        backPos = robocup.Point(-constants.Field.Width / 2, 0)
+        shotVec = robocup.Point(main.ball().pos - self.robot.pos)
+        backVecRot = robocup.Point(backVec.perp_ccw())
+        facing_back_line = (backVecRot.dot(shotVec) < 0)
+        if not facing_back_line and self.robot.has_ball():
+            if self.robot.has_chipper():
+                self.robot.chip(1)
+            else:
+                self.robot.kick(1)
 
-	class State(Enum):
-		## gets between a particular opponent and the goal.  stays closer to the goal
-		marking = 1
-
-		## chilling out in a zone waiting to mark an opponent.  doesn't do this much
-		area_marking = 2
-
-
-	## The area of the field this robot should block
-	class Side(Enum):
-		left = 1
-		center = 2
-		right = 3
-
-
-	def __init__(self, side=Side.center):
-		super().__init__(continuous=True)
-		self._block_robot = None
-		self._area = None
-		self._side = side
-		self._opponent_avoid_threshold = 2.0
-		self._defend_goal_radius = 0.9
-		self._win_eval = robocup.WindowEvaluator(main.system_state())
-
-		self._area = robocup.Rect(robocup.Point(-constants.Field.Width/2.0, constants.Field.Length),
-			robocup.Point(constants.Field.Width/2.0, 0))
-		if self._side is Defender.Side.right:
-			self._area.get_pt(0).x = 0
-		if self._side is Defender.Side.left:
-			self._area.get_pt(1).x = 0
-
-		self.add_state(Defender.State.marking, behavior.Behavior.State.running)
-		self.add_state(Defender.State.area_marking, behavior.Behavior.State.running)
-
-		self.add_transition(behavior.Behavior.State.start,
-			Defender.State.marking,
-			lambda: True,
-			"immediately")
-		self.add_transition(Defender.State.marking,
-			Defender.State.area_marking,
-			lambda: not self._area.contains_point(main.ball().pos) and self.block_robot is None,
-			"if ball not in area and no robot to block")
-		self.add_transition(Defender.State.area_marking, 
-			Defender.State.marking,
-			lambda: self._area.contains_point(main.ball().pos) or self.find_robot_to_block() is not None,
-			"if ball or opponent enters my area")
-
-	def execute_marking(self):
-		#main.system_state().draw_line(robocup.Line(self._area.get_pt(0), self._area.get_pt(1)), (127,0,255), "Defender")
-		self.block_robot = self.find_robot_to_block()
-		if self.block_robot is not None:
-			# self.robot.add_text("Blocking Robot " + str(self.block_robot.shell_id()), (255,255,255), "RobotText")
-			pass
-		if self.robot.pos.near_point(robocup.Point(0,0), self._opponent_avoid_threshold):
-			self.robot.set_avoid_opponents(False)
-		else:
-			self.robot.set_avoid_opponents(True)
-
-		target = None
-		if self.block_robot is None:
-			target = main.ball().pos + main.ball().vel*0.3
-		else:
-			target = self.block_robot.pos + self.block_robot.vel*0.3
-
-		goal_line = robocup.Segment(robocup.Point(-constants.Field.GoalWidth/2.0,0),
-			robocup.Point(constants.Field.GoalWidth/2.0,0))
-
-		self._win_eval.excluded_robots = [self.robot]
-
-		# TODO defenders should register themselves with some static list on init
-		# TODO make this happen in python-land
-		# for (Defender *f :  otherDefenders)
-		# {
-		# 	if (f->robot)
-		# 	{
-		# 		_winEval.exclude.push_back(f->robot->pos);
-		# 	}
-		# }
-
-		windows = self._win_eval.eval_pt_to_seg(target, goal_line)[0]
-
-		best = None
-		goalie = main.our_robot_with_id(main.root_play().goalie_id)
-
-		if goalie is not None and self.side is not Defender.Side.center:
-			for window in windows:
-				if best is None:
-					best = window
-				elif self.side is Defender.Side.left and window.segment.center.x < goalie.pos.x and window.segment.length > best.segment.length:
-					best = window
-				elif self.side is Defender.Side.right and window.segment.center.x > goalie.pos.x and window.segment.length > best.segment.length:
-					best = window
-		else:
-			best_dist = 0
-			for window in windows:
-				seg = robocup.Segment(window.segment.center(), main.ball().pos)
-				new_dist = seg.dist_to(self.robot.pos)
-				if best is None or new_dist < best_dist:
-					best = window
-					best_dist = new_dist
-
-		shoot_seg = None
-		if best is not None:
-			if self.block_robot is not None:
-				dirvec = robocup.Point.direction(self.block_robot.angle * (math.pi/180.0))
-				shoot_seg = robocup.Segment(self.block_robot.pos,
-					self.block_robot.pos + dirvec*7.0)
-			else:
-				shoot_seg = robocup.Segment(main.ball().pos, main.ball().pos + main.ball().vel.normalized() * 7.0)
-
-		need_task = False
-		if best is not None:
-			winseg = best.segment
-			if main.ball().vel.magsq() > 0.03 and winseg.segment_intersection(shoot_seg) != None:
-				self.robot.move_to(shoot_seg.nearest_point(self.robot.pos))
-				self.robot.face_none()
-			else:
-				winsize = winseg.length()
-
-				if winsize < constants.Ball.Radius:
-					need_task = True
-				else:
-					arc = robocup.Circle(robocup.Point(0,0), self._defend_goal_radius)
-					shot = robocup.Line(winseg.center(), target)
-					dest = [robocup.Point(0,0), robocup.Point(0,0)]
-
-					intersected, dest[0], dest[1] = shot.intersects_circle(arc)
-
-					if intersected:
-						self.robot.move_to(dest[0] if dest[0].y > 0 else dest[1])
-						if self.block_robot is not None:
-							self.robot.face(self.block_robot.pos)
-						else:
-							self.robot.face(main.ball().pos)
-					else:
-						need_task = True
-		if need_task:
-			self.robot.face(main.ball().pos)
-
-
-		backVec = robocup.Point(1,0)
-		backPos = robocup.Point(-constants.Field.Width / 2, 0)
-		shotVec = robocup.Point(main.ball().pos - self.robot.pos)
-		backVecRot = robocup.Point(backVec.perp_ccw())
-		facing_back_line = ( backVecRot.dot(shotVec) < 0 )
-		if not facing_back_line and self.robot.has_ball():
-			if self.robot.has_chipper():
-				self.robot.chip(1)
-			else:
-				self.robot.kick(1)
-
-	"""
+    """
 	TODO comment
 	"""
-	def execute_area_marking(self):
-		if self.robot.pos.near_point(robocup.Point(0,0), self._opponent_avoid_threshold):
-			self.robot.set_avoid_opponents(False)
-		else:
-			self.robot.set_avoid_opponents(True)
-		goal_target = robocup.Point(0, -constants.Field.GoalDepth/2.0)
-		goal_line = robocup.Segment(robocup.Point(-constants.Field.GoalWidth/2.0,0),
-			robocup.Point(constants.Field.GoalWidth/2.0,0))
-
-		if self.side is Defender.Side.left:
-			goal_line.get_pt(1).x = 0
-			goal_line.get_pt(1).y = 0
-		if self.side is Defender.Side.right:
-			goal_line.get_pt(0).x = 0
-			goal_line.get_pt(0).y = 0
-
-		for robot in main.system_state().their_robots:
-			self._win_eval.excluded_robots.append(robot)
-
-		if main.root_play().goalie_id is not None:
-			self._win_eval.excluded_robots.append(main.our_robot_with_id(main.root_play().goalie_id))
-
-		# TODO (cpp line 186)
-		# windows = self._win_eval.
-		windows = []
-
-		best = None
-		angle = 0.0
-		for window in windows:
-			if best is None:
-				best = window
-				angle = window.a0 - window.a1
-			elif window.a0 - window.a1 > angle:
-				best = window
-				angle = window.a0 - window.a1
-
-		shootline = robocup.Segment(robocup.Point(0,0), robocup.Point(0,0))
-		if best is not None:
-			angle = (best.a0 + best.a1)/2.0
-			shootline = robocup.Segment(self._win_eval.origin(), robocup.Point.direction(angle * (math.pi / 180.0))) # FIXME :no origin. 
-			main.system_state().draw_line(shootline, (255,0,0), "Defender")
-
-		need_task = False
-		if best is not None:
-			winseg = best.segment
-			arc = robocup.Circle(robocup.Point(0,0), self._defend_goal_radius)
-			shot = robocup.Line(shootline.get_pt(0), shootline.get_pt(1))
-			dest = [robocup.Point(0,0), robocup.Point(0,0)]
-			intersected, dest[0], dest[1] = shot.intersects_circle(arc)
-			if intersected:
-				self.robot.move_to(dest[0] if dest[0].y > 0 else dest[1])
-			else:
-				need_task = True
-		if need_task:
-			self.robot.face(main.ball().pos)
-
-		if main.ball().pos.y < constants.Field.Length / 2.0:
-			self.robot.set_dribble_speed(255)
-
-		backVec = robocup.Point(1,0)
-		backPos = robocup.Point(-constants.Field.Width / 2, 0)
-		shotVec = robocup.Point(main.ball().pos - self.robot.pos)
-		backVecRot = robocup.Point(backVec.perp_ccw())
-		facing_back_line = ( backVecRot.dot(shotVec) < 0 )
-		if not facing_back_line and self.robot.has_ball():
-			if self.robot.has_chipper():
-				self.robot.chip(1)
-			else:
-				self.robot.kick(1)
-
-	def find_robot_to_block(self):
-		target = None
-		for robot in main.system_state().their_robots:
-			if robot.visible and self._area.contains_point(robot.pos):
-				if target is None or target.pos.dist_to(main.ball().pos) > robot.pos.dist_to(main.ball().pos):
-					target = robot
-		return target
-
-	@property 
-	def block_robot(self):
-		return self._block_robot
-	@block_robot.setter
-	def block_robot(self, value):
-		self._block_robot = value
-
-	@property 
-	def side(self):
-		return self._side
-	@side.setter
-	def side(self, value):
-		self._side = value
-		self._area = robocup.Rect(robocup.Point(-constants.Field.Width/2.0, constants.Field.Length),
-			robocup.Point(constants.Field.Width/2.0, 0))
-		if self._side is Defender.Side.right:
-			self._area.get_pt(0).x = 0
-		if self._side is Defender.Side.left:
-			self._area.get_pt(1).x = 0
+
+    def execute_area_marking(self):
+        if self.robot.pos.near_point(
+                robocup.Point(0, 0), self._opponent_avoid_threshold):
+            self.robot.set_avoid_opponents(False)
+        else:
+            self.robot.set_avoid_opponents(True)
+        goal_target = robocup.Point(0, -constants.Field.GoalDepth / 2.0)
+        goal_line = robocup.Segment(
+            robocup.Point(-constants.Field.GoalWidth / 2.0, 0),
+            robocup.Point(constants.Field.GoalWidth / 2.0, 0))
+
+        if self.side is Defender.Side.left:
+            goal_line.get_pt(1).x = 0
+            goal_line.get_pt(1).y = 0
+        if self.side is Defender.Side.right:
+            goal_line.get_pt(0).x = 0
+            goal_line.get_pt(0).y = 0
+
+        for robot in main.system_state().their_robots:
+            self._win_eval.excluded_robots.append(robot)
+
+        if main.root_play().goalie_id is not None:
+            self._win_eval.excluded_robots.append(main.our_robot_with_id(
+                main.root_play().goalie_id))
+
+        # TODO (cpp line 186)
+        # windows = self._win_eval.
+        windows = []
+
+        best = None
+        angle = 0.0
+        for window in windows:
+            if best is None:
+                best = window
+                angle = window.a0 - window.a1
+            elif window.a0 - window.a1 > angle:
+                best = window
+                angle = window.a0 - window.a1
+
+        shootline = robocup.Segment(robocup.Point(0, 0), robocup.Point(0, 0))
+        if best is not None:
+            angle = (best.a0 + best.a1) / 2.0
+            shootline = robocup.Segment(
+                self._win_eval.origin(), robocup.Point.direction(angle * (
+                    math.pi / 180.0)))  # FIXME :no origin.
+            main.system_state().draw_line(shootline, (255, 0, 0), "Defender")
+
+        need_task = False
+        if best is not None:
+            winseg = best.segment
+            arc = robocup.Circle(robocup.Point(0, 0), self._defend_goal_radius)
+            shot = robocup.Line(shootline.get_pt(0), shootline.get_pt(1))
+            dest = [robocup.Point(0, 0), robocup.Point(0, 0)]
+            intersected, dest[0], dest[1] = shot.intersects_circle(arc)
+            if intersected:
+                self.robot.move_to(dest[0] if dest[0].y > 0 else dest[1])
+            else:
+                need_task = True
+        if need_task:
+            self.robot.face(main.ball().pos)
+
+        if main.ball().pos.y < constants.Field.Length / 2.0:
+            self.robot.set_dribble_speed(255)
+
+        backVec = robocup.Point(1, 0)
+        backPos = robocup.Point(-constants.Field.Width / 2, 0)
+        shotVec = robocup.Point(main.ball().pos - self.robot.pos)
+        backVecRot = robocup.Point(backVec.perp_ccw())
+        facing_back_line = (backVecRot.dot(shotVec) < 0)
+        if not facing_back_line and self.robot.has_ball():
+            if self.robot.has_chipper():
+                self.robot.chip(1)
+            else:
+                self.robot.kick(1)
+
+    def find_robot_to_block(self):
+        target = None
+        for robot in main.system_state().their_robots:
+            if robot.visible and self._area.contains_point(robot.pos):
+                if target is None or target.pos.dist_to(main.ball(
+                ).pos) > robot.pos.dist_to(main.ball().pos):
+                    target = robot
+        return target
+
+    @property
+    def block_robot(self):
+        return self._block_robot
+
+    @block_robot.setter
+    def block_robot(self, value):
+        self._block_robot = value
+
+    @property
+    def side(self):
+        return self._side
+
+    @side.setter
+    def side(self, value):
+        self._side = value
+        self._area = robocup.Rect(
+            robocup.Point(-constants.Field.Width / 2.0,
+                          constants.Field.Length),
+            robocup.Point(constants.Field.Width / 2.0, 0))
+        if self._side is Defender.Side.right:
+            self._area.get_pt(0).x = 0
+        if self._side is Defender.Side.left:
+            self._area.get_pt(1).x = 0

--- a/soccer/gameplay/skills/mark.py
+++ b/soccer/gameplay/skills/mark.py
@@ -6,59 +6,69 @@
 
 
 class Mark(single_robot_behavior.SingleRobotBehavior):
-
-	def __init__(self):
-		super().__init__(continuous=True)
-		self._ratio = 0.9
-		self._mark_line_thresh = 0.9
-		self._mark_robot = None
-
-		self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
-
-	def execute_running(self):
-		if self.mark_robot is None or not main.ball().valid or not self.mark_robot.visible:
-			return
-
-		ball_pos = main.ball().pos
-		pos = self.robot.pos
-		mark_pos = self.mark_robot.pos
-
-		mark_line_dir = (ball_pos - mark_pos).normalized()
-		ball_mark_line = robocup.Segment(ball_pos - mark_line_dir * constants.Ball.Radius, mark_pos + mark_line_dir * 2.0 * constants.Robot.Radius)
-
-		main.system_state().draw_line(ball_mark_line, (0,0,255), "Mark")
-
-		mark_line_dist = ball_mark_line.dist_to(pos)
-		target_point = None
-		if mark_line_dist > self.mark_line_thresh:
-			target_point = ball_mark_line.nearest_point(pos)
-		else:
-			target_point = ball_pos + (mark_pos - ball_pos).normalized() * self.ratio * ball_mark_line.length()
-
-		main.system_state().draw_circle(self._mark_robot.pos, constants.Robot.Radius * 1.2, (0, 127, 255), "Mark")
-
-		self.robot.approach_opponent(self.mark_robot.shell_id(), True)
-		self.robot.move_to(target_point)
-		self.robot.face(ball_pos)
-
-
-	@property
-	def ratio(self):
-		return self._ratio
-	@ratio.setter
-	def ratio(self, value):
-		self._ratio = min(max(value, 0.0), 1.0)
-
-	@property
-	def mark_line_thresh(self):
-		return self._mark_line_thresh
-	@mark_line_thresh.setter
-	def mark_line_thresh(self, value):
-		self._mark_line_thresh = value
-
-	@property
-	def mark_robot(self):
-		return self._mark_robot
-	@mark_robot.setter
-	def mark_robot(self, value):
-		self._mark_robot = value
\ No newline at end of file
+    def __init__(self):
+        super().__init__(continuous=True)
+        self._ratio = 0.9
+        self._mark_line_thresh = 0.9
+        self._mark_robot = None
+
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
+
+    def execute_running(self):
+        if self.mark_robot is None or not main.ball(
+        ).valid or not self.mark_robot.visible:
+            return
+
+        ball_pos = main.ball().pos
+        pos = self.robot.pos
+        mark_pos = self.mark_robot.pos
+
+        mark_line_dir = (ball_pos - mark_pos).normalized()
+        ball_mark_line = robocup.Segment(
+            ball_pos - mark_line_dir * constants.Ball.Radius,
+            mark_pos + mark_line_dir * 2.0 * constants.Robot.Radius)
+
+        main.system_state().draw_line(ball_mark_line, (0, 0, 255), "Mark")
+
+        mark_line_dist = ball_mark_line.dist_to(pos)
+        target_point = None
+        if mark_line_dist > self.mark_line_thresh:
+            target_point = ball_mark_line.nearest_point(pos)
+        else:
+            target_point = ball_pos + (
+                mark_pos -
+                ball_pos).normalized() * self.ratio * ball_mark_line.length()
+
+        main.system_state().draw_circle(self._mark_robot.pos,
+                                        constants.Robot.Radius * 1.2,
+                                        (0, 127, 255), "Mark")
+
+        self.robot.approach_opponent(self.mark_robot.shell_id(), True)
+        self.robot.move_to(target_point)
+        self.robot.face(ball_pos)
+
+    @property
+    def ratio(self):
+        return self._ratio
+
+    @ratio.setter
+    def ratio(self, value):
+        self._ratio = min(max(value, 0.0), 1.0)
+
+    @property
+    def mark_line_thresh(self):
+        return self._mark_line_thresh
+
+    @mark_line_thresh.setter
+    def mark_line_thresh(self, value):
+        self._mark_line_thresh = value
+
+    @property
+    def mark_robot(self):
+        return self._mark_robot
+
+    @mark_robot.setter
+    def mark_robot(self, value):
+        self._mark_robot = value

--- a/soccer/gameplay/tests/test_fsm.py
+++ b/soccer/gameplay/tests/test_fsm.py
@@ -4,7 +4,6 @@
 
 
 class MyFsm(fsm.StateMachine):
-
     class State(enum.Enum):
         start = 1
         running = 2
@@ -13,7 +12,6 @@
     class SubState(enum.Enum):
         running_substate = 1
 
-
     def __init__(self):
         super().__init__(start_state=MyFsm.State.start)
         self.add_state(MyFsm.State.start)
@@ -21,30 +19,49 @@
         self.add_state(MyFsm.State.done)
         self.add_state(MyFsm.SubState.running_substate, MyFsm.State.running)
 
-        self.add_transition(MyFsm.State.start,
-            MyFsm.SubState.running_substate,
-            lambda: True,
-            'immediately')
-        self.add_transition(MyFsm.SubState.running_substate,
-            MyFsm.State.done,
-            lambda: True,
-            'immediately')
+        self.add_transition(MyFsm.State.start, MyFsm.SubState.running_substate,
+                            lambda: True, 'immediately')
+        self.add_transition(MyFsm.SubState.running_substate, MyFsm.State.done,
+                            lambda: True, 'immediately')
 
         self._log = []
 
     # log all fsm method calls
-    def on_enter_start(self): self._log.append("on_enter_start")
-    def on_enter_running(self): self._log.append("on_enter_running")
-    def on_enter_done(self): self._log.append("on_enter_done")
-    def on_enter_running_substate(self): self._log.append("on_enter_running_substate")
-    def on_exit_start(self): self._log.append("on_exit_start")
-    def on_exit_running(self): self._log.append("on_exit_running")
-    def on_exit_done(self): self._log.append("on_exit_done")
-    def on_exit_running_substate(self): self._log.append("on_exit_running_substate")
-    def execute_start(self): self._log.append("execute_start")
-    def execute_running(self): self._log.append("execute_running")
-    def execute_done(self): self._log.append("execute_done")
-    def execute_running_substate(self): self._log.append("execute_running_substate")
+    def on_enter_start(self):
+        self._log.append("on_enter_start")
+
+    def on_enter_running(self):
+        self._log.append("on_enter_running")
+
+    def on_enter_done(self):
+        self._log.append("on_enter_done")
+
+    def on_enter_running_substate(self):
+        self._log.append("on_enter_running_substate")
+
+    def on_exit_start(self):
+        self._log.append("on_exit_start")
+
+    def on_exit_running(self):
+        self._log.append("on_exit_running")
+
+    def on_exit_done(self):
+        self._log.append("on_exit_done")
+
+    def on_exit_running_substate(self):
+        self._log.append("on_exit_running_substate")
+
+    def execute_start(self):
+        self._log.append("execute_start")
+
+    def execute_running(self):
+        self._log.append("execute_running")
+
+    def execute_done(self):
+        self._log.append("execute_done")
+
+    def execute_running_substate(self):
+        self._log.append("execute_running_substate")
 
 
 class TestFsm(unittest.TestCase):
@@ -57,25 +74,19 @@
             fsm.spin()
 
         expected_log = [
-            "on_enter_start",
-            "execute_start",
-            "on_exit_start",
-            "on_enter_running",
-            "on_enter_running_substate",
-            "execute_running",
-            "execute_running_substate",
-            "on_exit_running",
-            "on_exit_running_substate",
-            "on_enter_done",
-            "execute_done"
+            "on_enter_start", "execute_start", "on_exit_start",
+            "on_enter_running", "on_enter_running_substate", "execute_running",
+            "execute_running_substate", "on_exit_running",
+            "on_exit_running_substate", "on_enter_done", "execute_done"
         ]
 
         self.assertEqual(expected_log, fsm._log)
 
-
     def test_ancestor_chain(self):
         """see if the ancestors_of_state() method works"""
 
         fsm = MyFsm()
         self.assertEqual(fsm.ancestors_of_state(MyFsm.State.done), [])
-        self.assertEqual(fsm.ancestors_of_state(MyFsm.SubState.running_substate), [MyFsm.State.running])
+        self.assertEqual(
+            fsm.ancestors_of_state(MyFsm.SubState.running_substate),
+            [MyFsm.State.running])

--- a/soccer/gameplay/timed_behavior.py
+++ b/soccer/gameplay/timed_behavior.py
@@ -6,15 +6,12 @@
 ## TimedBehavior wraps a subbehavior and allows us to easily place a time limit on it.
 # After the specified amount of time has elapsed, the wrapped behavior is cancelled.
 class TimedBehavior(Behavior):
-
-
     class State(Enum):
 
         ## Having a separate timed_out state rather than just using the "failed" state from Behavior
         # allows us to differentiate between timing out and the enclosed behavior failing
         timed_out = 1
 
-
     def __init__(self, behavior, time_limit):
         super().__init__(continuous=False)
 
@@ -27,51 +24,41 @@
         self._time_limit = time_limit
         self._start_time = None
 
-        self.add_transition(Behavior.State.start, Behavior.State.running, lambda: True, 'immediately')
-        self.add_transition(Behavior.State.running, TimedBehavior.State.timed_out,
-            lambda:
-                time.time() - self.start_time > self.time_limit,
-            'time runs out'
-            )
-        self.add_transition(Behavior.State.running, Behavior.State.completed,
-            lambda:
-                self.behavior.is_in_state(Behavior.State.completed),
-            'subbehavior completed'
-            )
-
+        self.add_transition(Behavior.State.start, Behavior.State.running,
+                            lambda: True, 'immediately')
+        self.add_transition(
+            Behavior.State.running, TimedBehavior.State.timed_out,
+            lambda: time.time() - self.start_time > self.time_limit,
+            'time runs out')
+        self.add_transition(
+            Behavior.State.running, Behavior.State.completed,
+            lambda: self.behavior.is_in_state(Behavior.State.completed),
+            'subbehavior completed')
 
     def on_enter_timed_out(self):
         self.behavior.terminate()
 
-
     def execute_start(self):
         self._start_time = time.time()
 
-
     def execute_running(self):
         self.behavior.run()
 
-
     def on_enter_cancelled(self):
         if not self.behavior.is_done_running():
             self.behavior.terminate()
 
-
     @property
     def start_time(self):
         return self._start_time
 
-
     @property
     def time_limit(self):
         return self._time_limit
 
-
     @property
     def behavior(self):
         return self._behavior
 
-
     def __str__(self):
         return super().__str__() + "\n\t" + str(self.behavior)
-

--- a/soccer/gameplay/ui/main.py
+++ b/soccer/gameplay/ui/main.py
@@ -12,9 +12,10 @@
 
     return win
 
-
 # sets up the PlayConfigTab in the main soccer gui
 _has_setup_ui = False
+
+
 def setup():
     global _has_setup_ui
 
@@ -23,7 +24,8 @@
         return
 
     win = getMainWindow()
-    if win == None: raise AssertionError("Unable to get a reference to the main window")
+    if win == None:
+        raise AssertionError("Unable to get a reference to the main window")
 
     pcTab = win.findChild(QtWidgets.QTreeView, 'plays')
 

--- a/soccer/gameplay/tests/test_role_assignment.py
+++ b/soccer/gameplay/tests/test_role_assignment.py
@@ -32,7 +32,6 @@
         self.assertEqual(assignments['role1'][1], bot1)
         self.assertEqual(assignments['role2'][1], bot2)
 
-
     def test_not_enough_bots(self):
         """If there's not enough robots to do an assignment, it should raise an error"""
 
@@ -49,6 +48,4 @@
 
         req_tree = {'role1': req1, 'role2': req2}
         self.assertRaises(role_assignment.ImpossibleAssignmentError,
-            role_assignment.assign_roles,
-            [bot1],
-            req_tree)
+                          role_assignment.assign_roles, [bot1], req_tree)

--- a/soccer/gameplay/plays/testing/stress_test.py
+++ b/soccer/gameplay/plays/testing/stress_test.py
@@ -9,38 +9,40 @@
 # Makes a robot continually run laps
 # note: only really works with one robot on the field at a time
 class StressTest(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
 
-        self.points = [robocup.Point(constants.Field.Width * 1.0/3.0, constants.Field.Length / 6.0),
-            robocup.Point(-constants.Field.Width * 1.0/3.0, constants.Field.Length * 2.0/6.0),
-            robocup.Point(constants.Field.Width * 1.0/3.0, constants.Field.Length * 2.0/6.0),
-            robocup.Point(-constants.Field.Width * 1.0/3.0, constants.Field.Length / 6.0)
-        ]
+        self.points = [robocup.Point(constants.Field.Width * 1.0 / 3.0,
+                                     constants.Field.Length / 6.0),
+                       robocup.Point(-constants.Field.Width * 1.0 / 3.0,
+                                     constants.Field.Length * 2.0 / 6.0),
+                       robocup.Point(constants.Field.Width * 1.0 / 3.0,
+                                     constants.Field.Length * 2.0 / 6.0),
+                       robocup.Point(-constants.Field.Width * 1.0 / 3.0,
+                                     constants.Field.Length / 6.0)]
         self.index = 0
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
     def on_enter_running(self):
         m = skills.move.Move()
         self.add_subbehavior(m, 'move', required=True)
+
     def on_exit_running(self):
         self.remove_subbehavior('move')
 
-
     def execute_running(self):
         # draw laps
         # indices = list(range(len(self.points))) + [0]
         # for i in range(len(indices)):
-        main.system_state().draw_line(robocup.Line(self.points[0], self.points[1]), (255,0,0), "StressTest")
+        main.system_state().draw_line(
+            robocup.Line(self.points[0], self.points[1]),
+            (255, 0, 0), "StressTest")
 
         m = self.subbehavior_with_name('move')
         if m.state == behavior.Behavior.State.completed:
             # increment index
             self.index = (self.index + 1) % len(self.points)
-        m.pos = self.points[self.index]
\ No newline at end of file
+        m.pos = self.points[self.index]

--- a/soccer/gameplay/tactics/one_touch_pass.py
+++ b/soccer/gameplay/tactics/one_touch_pass.py
@@ -9,6 +9,7 @@
 import evaluation.touchpass_positioning
 import enum
 
+
 ## A tactic that causes a robot to pass to another one,
 # who scores on the goal as fast as possible.
 #
@@ -16,7 +17,7 @@
 class OneTouchPass(composite_behavior.CompositeBehavior):
 
     tpass = evaluation.touchpass_positioning
-    receivePointChangeThreshold = 0.15 # 15%
+    receivePointChangeThreshold = 0.15  # 15%
 
     class State(enum.Enum):
         passing = 1
@@ -31,28 +32,29 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-                OneTouchPass.State.passing,
-                lambda: True,
-                'immediately')
-
-        self.add_transition(OneTouchPass.State.passing,
-                behavior.Behavior.State.completed,
-                lambda: self.subbehavior_with_name('pass').state == behavior.Behavior.State.completed,
-                'Touchpass completed.')
-
+                            OneTouchPass.State.passing, lambda: True,
+                            'immediately')
 
-        self.add_transition(OneTouchPass.State.passing,
-                behavior.Behavior.State.failed,
-                lambda: self.subbehavior_with_name('pass').state == behavior.Behavior.State.failed,
-                'Touchpass failed!')
+        self.add_transition(
+            OneTouchPass.State.passing, behavior.Behavior.State.completed,
+            lambda: self.subbehavior_with_name('pass').state == behavior.Behavior.State.completed,
+            'Touchpass completed.')
+
+        self.add_transition(
+            OneTouchPass.State.passing, behavior.Behavior.State.failed,
+            lambda: self.subbehavior_with_name('pass').state == behavior.Behavior.State.failed,
+            'Touchpass failed!')
 
     def reset_receive_point(self):
         angle_receive = skills.angle_receive.AngleReceive()
 
         pass_bhvr = self.subbehavior_with_name('pass')
-        receive_pt, target_point, probability = OneTouchPass.tpass.eval_best_receive_point(main.ball().pos, None, pass_bhvr.get_robots())
+        receive_pt, target_point, probability = OneTouchPass.tpass.eval_best_receive_point(
+            main.ball().pos, None, pass_bhvr.get_robots())
         # only change if increase of beyond the threshold.
-        if self.force_reevauation == True or pass_bhvr.receive_point == None or pass_bhvr.target_point == None or probability > OneTouchPass.tpass.eval_single_point(main.ball().pos, pass_bhvr.receive_point, pass_bhvr.get_robots()) + OneTouchPass.receivePointChangeThreshold:
+        if self.force_reevauation == True or pass_bhvr.receive_point == None or pass_bhvr.target_point == None or probability > OneTouchPass.tpass.eval_single_point(
+                main.ball().pos, pass_bhvr.receive_point, pass_bhvr.get_robots(
+                )) + OneTouchPass.receivePointChangeThreshold:
             pass_bhvr.receive_point = receive_pt
             angle_receive.target_point = target_point
             self.force_reevauation = False
@@ -68,11 +70,11 @@
     def execute_passing(self):
         pass_bhvr = self.subbehavior_with_name('pass')
         self.tpass_iterations = self.tpass_iterations + 1
-        if not pass_bhvr.state == tactics.coordinated_pass.CoordinatedPass.State.receiving and self.tpass_iterations > 50 or main.ball().pos.y < pass_bhvr.receive_point.y:
+        if not pass_bhvr.state == tactics.coordinated_pass.CoordinatedPass.State.receiving and self.tpass_iterations > 50 or main.ball(
+        ).pos.y < pass_bhvr.receive_point.y:
             self.force_reevauation = True
             self.reset_receive_point()
             self.tpass_iterations = 0
 
     def on_exit_passing(self):
         self.remove_subbehavior('pass')
-

--- a/soccer/gameplay/plays/testing/test_bump.py
+++ b/soccer/gameplay/plays/testing/test_bump.py
@@ -6,10 +6,11 @@
 
 
 class TestBump(play.Play):
-
     def __init__(self):
         super().__init__(continuous=True)
-        self.add_transition(behavior.Behavior.State.start, behavior.Behavior.State.running, lambda: True, "immediately")
+        self.add_transition(behavior.Behavior.State.start,
+                            behavior.Behavior.State.running, lambda: True,
+                            "immediately")
 
     def on_enter_running(self):
         b = skills.bump.Bump()

--- a/soccer/gameplay/skills/move.py
+++ b/soccer/gameplay/skills/move.py
@@ -5,7 +5,6 @@
 ## Behavior that moves a robot to a specified location
 # wraps up OurRobot.move() into a Skill so we can use it in the play system more easily
 class Move(single_robot_behavior.SingleRobotBehavior):
-
     def __init__(self, pos=None):
         super().__init__(continuous=False)
 
@@ -13,43 +12,40 @@
         self.pos = pos
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True, 'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
 
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
             lambda: self.pos != None and (self.robot.pos - self.pos).mag() < self.threshold,
             'target pos reached')
-        self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
-            lambda:  self.pos != None and (self.robot.pos - self.pos).mag() > self.threshold,
+        self.add_transition(
+            behavior.Behavior.State.completed, behavior.Behavior.State.running,
+            lambda: self.pos != None and (self.robot.pos - self.pos).mag() > self.threshold,
             'away from target')
 
-
     ## the position to move to (a robocup.Point object)
     @property
     def pos(self):
         return self._pos
+
     @pos.setter
     def pos(self, value):
         self._pos = value
 
-
     ## how close (in meters) the robot has to be to the target position for it be complete
     @property
     def threshold(self):
         return self._threshold
+
     @threshold.setter
     def threshold(self, value):
         self._threshold = value
 
-
-
     def execute_running(self):
         if self.pos != None:
             self.robot.move_to(self.pos)
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         reqs.destination_shape = self.pos

--- a/soccer/gameplay/skills/capture.py
+++ b/soccer/gameplay/skills/capture.py
@@ -7,6 +7,7 @@
 import role_assignment
 import robocup
 
+
 class Capture(single_robot_behavior.SingleRobotBehavior):
 
     # tunable config values
@@ -18,41 +19,38 @@
 
     InFrontOfBallCosOfAngleThreshold = 0.95
 
-
     class State(Enum):
         course_approach = 1
         fine_approach = 2
 
-
     def __init__(self):
         super().__init__(continuous=False)
 
-        self.add_state(Capture.State.course_approach, behavior.Behavior.State.running)
-        self.add_state(Capture.State.fine_approach, behavior.Behavior.State.running)
+        self.add_state(Capture.State.course_approach,
+                       behavior.Behavior.State.running)
+        self.add_state(Capture.State.fine_approach,
+                       behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            Capture.State.course_approach,
-            lambda: True,
-            'immediately')
+                            Capture.State.course_approach, lambda: True,
+                            'immediately')
 
-        self.add_transition(Capture.State.course_approach,
-            Capture.State.fine_approach,
+        self.add_transition(
+            Capture.State.course_approach, Capture.State.fine_approach,
             lambda: (self.bot_in_front_of_ball() or self.bot_near_ball(Capture.CourseApproachDist)) and main.ball().valid,
             'dist to ball < threshold')
 
         self.add_transition(Capture.State.fine_approach,
-            behavior.Behavior.State.completed,
-            lambda: self.robot.has_ball(),
-            'has ball')
+                            behavior.Behavior.State.completed,
+                            lambda: self.robot.has_ball(), 'has ball')
 
-        self.add_transition(Capture.State.fine_approach,
-            Capture.State.course_approach,
+        self.add_transition(
+            Capture.State.fine_approach, Capture.State.course_approach,
             lambda: not (self.bot_in_front_of_ball() or self.bot_near_ball(Capture.CourseApproachDist)) and (not self.bot_near_ball(Capture.CourseApproachDist * 1.5) or not main.ball().pos),
             'ball went into goal')
 
         self.lastApproachTarget = None
 
-
     def bot_to_ball(self):
         return main.ball().pos - self.robot.pos
 
@@ -64,16 +62,15 @@
         return (ball2bot.normalized().dot(main.ball().vel) > Capture.InFrontOfBallCosOfAngleThreshold) and \
                 ((ball2bot).mag() < (evaluation.ball.predict_stop(main.ball().pos, main.ball().vel) - main.ball().pos).mag())
 
-
     # normalized vector pointing from the ball to the point the robot should get to in course_aproach
     def approach_vector(self):
-        if main.ball().vel.mag() > 0.25 and self.robot.pos.dist_to(main.ball().pos) > 0.2:
+        if main.ball().vel.mag() > 0.25 and self.robot.pos.dist_to(main.ball(
+        ).pos) > 0.2:
             # ball's moving, get on the side it's moving towards
             return main.ball().vel.normalized()
         else:
             return (self.robot.pos - main.ball().pos).normalized()
 
-
     def find_intercept_point(self):
         approach_vec = self.approach_vector()
 
@@ -82,22 +79,18 @@
         for i in range(50):
             dist = i * 0.05
             pos = main.ball().pos + approach_vec * dist
-            ball_time = evaluation.ball.rev_predict(main.ball().vel, dist) # how long will it take the ball to get there
-            robotDist = (pos - self.robot.pos).mag()*0.6
-            bot_time = robocup.get_trapezoidal_time(
-                robotDist,
-                robotDist,
-                2.2,
-                1,
-                self.robot.vel.mag(),
-                0)
+            ball_time = evaluation.ball.rev_predict(
+                main.ball().vel, dist
+            )  # how long will it take the ball to get there
+            robotDist = (pos - self.robot.pos).mag() * 0.6
+            bot_time = robocup.get_trapezoidal_time(robotDist, robotDist, 2.2,
+                                                    1, self.robot.vel.mag(), 0)
 
             if bot_time < ball_time:
                 break
 
         return pos
 
-
     def execute_running(self):
         # make sure teammates don't bump into us
         self.robot.shield_from_teammates(constants.Robot.Radius * 2.0)
@@ -111,16 +104,17 @@
         pos = self.find_intercept_point()
         self.robot.face(main.ball().pos)
 
-        if (self.lastApproachTarget != None and (pos - self.lastApproachTarget).mag()<0.1):
+        if (self.lastApproachTarget != None and
+            (pos - self.lastApproachTarget).mag() < 0.1):
             self.robot.move_to(self.lastApproachTarget)
         else:
-            main.system_state().draw_circle(pos, constants.Ball.Radius, constants.Colors.White, "Capture")
+            main.system_state().draw_circle(pos, constants.Ball.Radius,
+                                            constants.Colors.White, "Capture")
             self.robot.move_to(pos)
             self.lastApproachTarget = pos
 
     def on_exit_course_approach(self):
-       self.lastApproachTarget == None
-
+        self.lastApproachTarget == None
 
     def execute_fine_approach(self):
         self.robot.disable_avoid_ball()
@@ -130,12 +124,13 @@
         # TODO(ashaw596): explain this math a bit
         bot2ball = (main.ball().pos - self.robot.pos).normalized()
         multiplier = 1.5
-        aproach = self.bot_to_ball()*multiplier + bot2ball * Capture.FineApproachSpeed/4 + main.ball().vel
+        aproach = self.bot_to_ball(
+        ) * multiplier + bot2ball * Capture.FineApproachSpeed / 4 + main.ball(
+        ).vel
         if (aproach.mag() > 1):
-            aproach = aproach.normalized()*1
+            aproach = aproach.normalized() * 1
         self.robot.set_world_vel(aproach)
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         reqs.require_kicking = True

--- a/soccer/gameplay/tactics/penalty.py
+++ b/soccer/gameplay/tactics/penalty.py
@@ -8,16 +8,15 @@
 import constants
 import skills.pivot_kick
 
+
 ## This class is currently not used for anything
 # This was ported from our old C++ gameplay system and served a purpose then, but is unused now
 class Penalty(single_robot_composite_behavior.SingleRobotCompositeBehavior):
-
     class State(enum.Enum):
         waiting = 1
         setup = 2
         ready = 3
 
-
     def __init__(self):
         super().__init__(continuous=False)
 
@@ -25,42 +24,38 @@
             self.add_state(substate, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            Penalty.State.waiting,
-            lambda: True,
-            'immediately')
-
-        self.add_transition(Penalty.State.waiting,
-            Penalty.State.setup,
-            lambda: main.game_state().is_setup_state(),
-            'ref says time to setup')
+                            Penalty.State.waiting, lambda: True, 'immediately')
+
+        self.add_transition(Penalty.State.waiting, Penalty.State.setup,
+                            lambda: main.game_state().is_setup_state(),
+                            'ref says time to setup')
 
         for state in [Penalty.State.waiting, Penalty.State.setup]:
-            self.add_transition(state,
-                Penalty.State.ready,
-                lambda: main.game_state().is_ready_state(),
-                'ref says ready')
+            self.add_transition(state, Penalty.State.ready,
+                                lambda: main.game_state().is_ready_state(),
+                                'ref says ready')
 
-        self.add_transition(Penalty.State.ready,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            Penalty.State.ready, behavior.Behavior.State.completed,
             lambda: self.subbehavior_with_name('kick').state == behavior.Behavior.State.completed,
             'done kicking')
 
-
     def execute_waiting(self):
         self.robot.face(main.ball().pos)
 
-
     def execute_setup(self):
-        penalty_mark = robocup.Point(0, constants.Field.Length - constants.Field.PenaltyDist)
+        penalty_mark = robocup.Point(
+            0, constants.Field.Length - constants.Field.PenaltyDist)
         backoff = 0.5
         if main.ball().pos.near_point(penalty_mark, 0.5):
-            self.robot.move_to(main.ball().pos + (main.ball().pos - robocup.Point(0, constants.Field.Length).normalized()) * backoff)
+            self.robot.move_to(main.ball().pos + (main.ball(
+            ).pos - robocup.Point(0, constants.Field.Length).normalized()) *
+                               backoff)
         else:
             self.robot.move_to(penalty_mark - robocup.Point(0, backoff))
 
         self.robot.face(main.ball().pos)
 
-
     def on_enter_ready(self):
         kick = skills.pivot_kick.PivotKick()
         self.add_subbehavior(kick, 'kick', required=True, priority=100)
@@ -71,7 +66,6 @@
     def on_exit_ready(self):
         self.remove_subbehavior('kick')
 
-
     ## prefer to get assigned robot closest to ball
     def role_requirements(self):
         reqs = super().role_requirements()

--- a/soccer/gameplay/skills/pivot_kick.py
+++ b/soccer/gameplay/skills/pivot_kick.py
@@ -12,15 +12,14 @@
 
 # PivotKick drives up to the ball and captures it, then aims at a specified target and kicks/chips
 # Note: PivotKick recalculates aim_target_point from the target at every iteration
-class PivotKick(single_robot_composite_behavior.SingleRobotCompositeBehavior, skills._kick._Kick):
-
+class PivotKick(single_robot_composite_behavior.SingleRobotCompositeBehavior,
+                skills._kick._Kick):
     class State(Enum):
         capturing = 1
         aiming = 2
         aimed = 3
         kicking = 4
 
-
     def __init__(self):
         super().__init__()
 
@@ -28,75 +27,69 @@
             self.add_state(state, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            PivotKick.State.capturing,
-            lambda: True,
-            'immediately')
-        self.add_transition(PivotKick.State.capturing,
-            PivotKick.State.aiming,
+                            PivotKick.State.capturing, lambda: True,
+                            'immediately')
+        self.add_transition(
+            PivotKick.State.capturing, PivotKick.State.aiming,
             lambda: self.subbehavior_with_name('capture').state == behavior.Behavior.State.completed,
             'has ball')
 
-        self.add_transition(PivotKick.State.aiming,
-            PivotKick.State.aimed,
+        self.add_transition(
+            PivotKick.State.aiming, PivotKick.State.aimed,
             lambda: self.subbehavior_with_name('aim').state == skills.aim.Aim.State.aimed,
             'aim error < threshold')
 
-        self.add_transition(PivotKick.State.aimed,
-            PivotKick.State.aiming,
+        self.add_transition(
+            PivotKick.State.aimed, PivotKick.State.aiming,
             lambda: self.subbehavior_with_name('aim').state == skills.aim.Aim.State.aiming and not self.enable_kick,
             'aim error > threshold')
-        
-        self.add_transition(PivotKick.State.aimed,
-            PivotKick.State.kicking,
-            lambda: self.enable_kick,
-            'kick enabled')
+
+        self.add_transition(PivotKick.State.aimed, PivotKick.State.kicking,
+                            lambda: self.enable_kick, 'kick enabled')
 
         self.add_transition(PivotKick.State.kicking,
-            behavior.Behavior.State.completed,
-            lambda: self.robot.just_kicked(),
-            'kick complete')
+                            behavior.Behavior.State.completed,
+                            lambda: self.robot.just_kicked(), 'kick complete')
 
-        self.add_transition(PivotKick.State.aiming,
-            PivotKick.State.capturing,
+        self.add_transition(
+            PivotKick.State.aiming, PivotKick.State.capturing,
             lambda: self.subbehavior_with_name('aim').state == behavior.Behavior.State.failed,
             'fumble')
-        self.add_transition(PivotKick.State.aimed,
-            PivotKick.State.capturing,
+        self.add_transition(
+            PivotKick.State.aimed, PivotKick.State.capturing,
             lambda: self.subbehavior_with_name('aim').state == behavior.Behavior.State.failed,
             'fumble')
-        self.add_transition(PivotKick.State.kicking,
-            PivotKick.State.capturing,
+        self.add_transition(
+            PivotKick.State.kicking, PivotKick.State.capturing,
             lambda: self.subbehavior_with_name('aim').state == behavior.Behavior.State.failed and not self.robot.just_kicked(),
             'fumble')
 
-
         # default parameters
         self.dribbler_power = constants.Robot.Dribbler.MaxPower
         self.aim_params = {'desperate_timeout': float("inf")}
-        
 
-    # The speed to drive the dribbler at during aiming
-    # If high, adds lift to kick
-    # Default: full power
-    # FIXME: defaulting to full power probably isn't the best - the C++ version sais full power in the header then actually used 50.  maybe use half speed?
+        # The speed to drive the dribbler at during aiming
+        # If high, adds lift to kick
+        # Default: full power
+        # FIXME: defaulting to full power probably isn't the best - the C++ version sais full power in the header then actually used 50.  maybe use half speed?
     @property
     def dribbler_power(self):
         return self._dribbler_power
+
     @dribbler_power.setter
     def dribbler_power(self, value):
         self._dribbler_power = int(value)
 
-
     # if you want to set custom error thresholds, etc to be used during aiming,
     # set this to a dictionary with the appropriate keys and values
     # default: {'desperate_timeout': float("inf")}
     @property
     def aim_params(self):
         return self._aim_params
+
     @aim_params.setter
     def aim_params(self, value):
         self._aim_params = value
-    
 
     # The point near the target point that we're currently aimed at, whether we want to be or not
     # If we kicked right now, the ball would pass through this point
@@ -106,19 +99,16 @@
         else:
             return None
 
-
     def is_steady(self):
         if self.has_subbehavior_with_name('aim'):
             return self.subbehavior_with_name('aim').is_steady()
         else:
             return None
-    
 
     def remove_aim_behavior(self):
         if self.has_subbehavior_with_name('aim'):
             self.remove_subbehavior('aim')
 
-
     def on_enter_capturing(self):
         self.remove_aim_behavior()
         self.robot.unkick()
@@ -129,7 +119,6 @@
     def on_exit_capturing(self):
         self.remove_subbehavior('capture')
 
-
     def set_aim_params(self):
         aim = self.subbehavior_with_name('aim')
         aim.target_point = self.aim_target_point
@@ -137,12 +126,10 @@
         for key, value in self.aim_params.items():
             setattr(aim, key, value)
 
-
     def execute_running(self):
         self.recalculate_aim_target_point()
         super().execute_running()
 
-
     def on_enter_aiming(self):
         if not self.has_subbehavior_with_name('aim'):
             aim = skills.aim.Aim()
@@ -154,14 +141,15 @@
 
         if isinstance(self.target, robocup.Segment):
             for i in range(2):
-                main.system_state().draw_line(robocup.Line(main.ball().pos, self.target.get_pt(i)), constants.Colors.Blue, "PivotKick")
+                main.system_state().draw_line(
+                    robocup.Line(main.ball().pos, self.target.get_pt(i)),
+                    constants.Colors.Blue, "PivotKick")
 
     def on_exit_aiming(self):
         # we don't remove the 'aim' subbehavior here because if we're going to the
         # kicking state, we want to keep it around
         pass
 
-
     def execute_kicking(self):
         self.set_aim_params()
         if self.use_chipper and self.robot.has_chipper():
@@ -169,12 +157,9 @@
         else:
             self.robot.kick(self.kick_power)
 
-
     def on_exit_running(self):
         self.remove_aim_behavior()
 
-
-
     def role_requirements(self):
         reqs = super().role_requirements()
 
@@ -186,4 +171,4 @@
                 r.chipper_preference_weight = role_assignment.PreferChipper
             r.require_kicking = True
 
-        return reqs
\ No newline at end of file
+        return reqs

--- a/soccer/gameplay/tactics/positions/goalie.py
+++ b/soccer/gameplay/tactics/positions/goalie.py
@@ -10,11 +10,13 @@
 import math
 import evaluation
 
+
 class Goalie(single_robot_composite_behavior.SingleRobotCompositeBehavior):
 
     MaxX = constants.Field.GoalWidth / 2.0
-    RobotSegment = robocup.Segment(robocup.Point(-MaxX, constants.Robot.Radius),
-                                    robocup.Point(MaxX, constants.Robot.Radius))
+    RobotSegment = robocup.Segment(
+        robocup.Point(-MaxX, constants.Robot.Radius),
+        robocup.Point(MaxX, constants.Robot.Radius))
     OpponentFacingThreshold = math.pi / 8.0
 
     class State(enum.Enum):
@@ -37,95 +39,84 @@
         for substate in Goalie.State:
             self.add_state(substate, behavior.Behavior.State.running)
 
-        self.add_transition(behavior.Behavior.State.start,
-            Goalie.State.chill,
-            lambda: True,
-            "immediately")
-
-        self.add_transition(Goalie.State.chill,
-            Goalie.State.defend,
-            lambda: main.ball().valid,
-            "ball is valid")
+        self.add_transition(behavior.Behavior.State.start, Goalie.State.chill,
+                            lambda: True, "immediately")
+
+        self.add_transition(Goalie.State.chill, Goalie.State.defend,
+                            lambda: main.ball().valid, "ball is valid")
 
         non_chill_states = [s for s in Goalie.State if s != Goalie.State.chill]
 
         # if ball is invalid, chill
         for state in non_chill_states:
-            self.add_transition(state,
-                Goalie.State.chill,
-                lambda: not main.ball().valid,
-                "ball is invalid")
+            self.add_transition(state, Goalie.State.chill,
+                                lambda: not main.ball().valid,
+                                "ball is invalid")
 
         for state in non_chill_states:
-            self.add_transition(state,
-                Goalie.State.setup_penalty,
-                lambda: main.game_state().is_their_penalty() and
-                        main.game_state().is_setup_state(),
+            self.add_transition(
+                state, Goalie.State.setup_penalty,
+                lambda: main.game_state().is_their_penalty() and main.game_state().is_setup_state(),
                 "setting up for opponent penalty")
 
-        for state in [s2 for s2 in non_chill_states if s2 != Goalie.State.intercept]:
-            self.add_transition(state,
-                Goalie.State.intercept,
-                lambda: evaluation.ball.is_moving_towards_our_goal() and
-                        not self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
+        for state in [s2
+                      for s2 in non_chill_states
+                      if s2 != Goalie.State.intercept]:
+            self.add_transition(
+                state, Goalie.State.intercept,
+                lambda: evaluation.ball.is_moving_towards_our_goal() and not self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
                 "ball coming towards our goal")
 
-        for state in [s2 for s2 in non_chill_states if s2 != Goalie.State.clear]:
-            self.add_transition(state,
-                Goalie.State.clear,
-                lambda: evaluation.ball.is_in_our_goalie_zone() and
-                        not main.game_state().is_their_penalty() and
-                        not evaluation.ball.is_moving_towards_our_goal() and
-                        evaluation.ball.opponent_with_ball() is None,
+        for state in [s2 for s2 in non_chill_states
+                      if s2 != Goalie.State.clear]:
+            self.add_transition(
+                state, Goalie.State.clear,
+                lambda: evaluation.ball.is_in_our_goalie_zone() and not main.game_state().is_their_penalty() and not evaluation.ball.is_moving_towards_our_goal() and evaluation.ball.opponent_with_ball() is None,
                 "ball in our goalie box, but not headed toward goal")
 
-        for state in [s2 for s2 in non_chill_states if s2 != Goalie.State.defend]:
-            self.add_transition(state,
-                Goalie.State.defend,
-                lambda: not evaluation.ball.is_in_our_goalie_zone() and
-                        not evaluation.ball.is_moving_towards_our_goal() and
-                        not main.game_state().is_their_penalty() and
-                        not self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
+        for state in [s2 for s2 in non_chill_states
+                      if s2 != Goalie.State.defend]:
+            self.add_transition(
+                state, Goalie.State.defend,
+                lambda: not evaluation.ball.is_in_our_goalie_zone() and not evaluation.ball.is_moving_towards_our_goal() and not main.game_state().is_their_penalty() and not self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
                 'not much going on')
 
-        for state in [s2 for s2 in non_chill_states if s2 != Goalie.State.block]:
-            self.add_transition(state,
-                Goalie.State.block,
-                lambda: not evaluation.ball.is_in_our_goalie_zone() and
-                        not evaluation.ball.is_moving_towards_our_goal() and
-                        self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
+        for state in [s2 for s2 in non_chill_states
+                      if s2 != Goalie.State.block]:
+            self.add_transition(
+                state, Goalie.State.block,
+                lambda: not evaluation.ball.is_in_our_goalie_zone() and not evaluation.ball.is_moving_towards_our_goal() and self.robot_is_facing_our_goal(evaluation.ball.opponent_with_ball()),
                 "opponents have possession")
 
-
     def robot_is_facing_our_goal(self, robot):
         if robot is None:
             return False
-        goal_robot = robot.pos - robocup.Point(0,0)
+        goal_robot = robot.pos - robocup.Point(0, 0)
         angle = goal_robot.normalized().angle() - math.pi
         robot_angle = robot.angle * math.pi / 180.
-        self.robot.add_text(str(angle - robot_angle), (255,255,255), "OurRobot")
+        self.robot.add_text(
+            str(angle - robot_angle), (255, 255, 255), "OurRobot")
         if abs(angle - robot_angle) < self.OpponentFacingThreshold:
             return True
         else:
             return False
 
-
     # note that execute_running() gets called BEFORE any of the execute_SUBSTATE methods gets called
     def execute_running(self):
         if self.robot != None:
             self.robot.face(main.ball().pos)
 
-
     def execute_chill(self):
         if self.robot != None:
             self.robot.move_to(robocup.Point(0, constants.Robot.Radius))
 
-
     def execute_setup_penalty(self):
         pt = robocup.Point(0, constants.Field.PenaltyDist)
-        penalty_kicker = min(main.their_robots(), key=lambda r: (r.pos - pt).mag())
+        penalty_kicker = min(main.their_robots(),
+                             key=lambda r: (r.pos - pt).mag())
         angle_rad = penalty_kicker.angle
-        shot_line = robocup.Line(penalty_kicker.pos, penalty_kicker.pos + robocup.Point.direction(angle_rad))
+        shot_line = robocup.Line(penalty_kicker.pos, penalty_kicker.pos +
+                                 robocup.Point.direction(angle_rad))
 
         dest = shot_line.line_intersection(Goalie.RobotSegment)
         if dest == None:
@@ -135,7 +126,6 @@
             dest.x = min(Goalie.MaxX - constants.Robot.Radius, dest.x)
         self.robot.move_to(dest)
 
-
     def on_enter_clear(self):
         # FIXME: what we really want is a less-precise LineKick
         #           this will require a Capture behavior that doesn't wait for the ball to stop
@@ -153,25 +143,25 @@
         kick.chip_power = 1.0
         kick.use_chipper = True
 
-        kick.target = robocup.Segment(robocup.Point(-constants.Field.Width/2, constants.Field.Length),
-            robocup.Point(constants.Field.Width/2, constants.Field.Length))
+        kick.target = robocup.Segment(
+            robocup.Point(-constants.Field.Width / 2, constants.Field.Length),
+            robocup.Point(constants.Field.Width / 2, constants.Field.Length))
 
         # FIXME: if the goalie has a fault, resort to bump
 
         self.add_subbehavior(kick, 'kick-clear', required=True)
 
-
     def on_exit_clear(self):
         self.remove_subbehavior('kick-clear')
 
-
     def on_enter_intercept(self):
         i = skills.intercept.Intercept()
         self.add_subbehavior(i, 'intercept', required=True)
 
     def execute_intercept(self):
-        ball_path = robocup.Segment(main.ball().pos,
-                            main.ball().pos + main.ball().vel.normalized()*10.0)
+        ball_path = robocup.Segment(
+            main.ball().pos,
+            main.ball().pos + main.ball().vel.normalized() * 10.0)
         dest = ball_path.nearest_point(self.robot.pos)
         self.robot.move_to(dest)
 
@@ -186,22 +176,24 @@
             best = winEval.eval_pt_to_our_goal(main.ball().pos)[1]
             if best is not None:
                 shot_line = robocup.Line(opposing_kicker.pos, main.ball().pos)
-                block_line = robocup.Line(robocup.Point(best.segment.get_pt(0).x - constants.Robot.Radius, constants.Robot.Radius),
-                                    robocup.Point(best.segment.get_pt(1).x + constants.Robot.Radius, constants.Robot.Radius))
-                main.system_state().draw_line(block_line, (255,0,0), "Debug")
+                block_line = robocup.Line(
+                    robocup.Point(
+                        best.segment.get_pt(0).x - constants.Robot.Radius,
+                        constants.Robot.Radius), robocup.Point(
+                            best.segment.get_pt(1).x + constants.Robot.Radius,
+                            constants.Robot.Radius))
+                main.system_state().draw_line(block_line, (255, 0, 0), "Debug")
                 dest = block_line.line_intersection(shot_line)
                 dest.x = min(Goalie.MaxX, dest.x)
                 dest.x = max(-Goalie.MaxX, dest.x)
                 self.robot.move_to(dest)
                 return
-        self.robot.move_to(robocup.Point(0,constants.Robot.Radius))
-
+        self.robot.move_to(robocup.Point(0, constants.Robot.Radius))
 
     def execute_defend(self):
         dest_x = main.ball().pos.x / constants.Field.Width * Goalie.MaxX
         self.robot.move_to(robocup.Point(dest_x, constants.Robot.Radius))
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
 
@@ -210,10 +202,10 @@
 
         return reqs
 
-
     @property
     def shell_id(self):
         return self._shell_id
+
     @shell_id.setter
     def shell_id(self, value):
         self._shell_id = value

--- a/soccer/gameplay/plays/testing/test_capture.py
+++ b/soccer/gameplay/plays/testing/test_capture.py
@@ -9,7 +9,6 @@
 
 # this test repeatedly runs the capture behavior
 class TestCapture(play.Play):
-
     class State(enum.Enum):
         setup = 1
         capturing = 2
@@ -19,48 +18,50 @@
 
         self.shell_id = None
 
-        self.add_state(TestCapture.State.setup, behavior.Behavior.State.running)
-        self.add_state(TestCapture.State.capturing, behavior.Behavior.State.running)
+        self.add_state(TestCapture.State.setup,
+                       behavior.Behavior.State.running)
+        self.add_state(TestCapture.State.capturing,
+                       behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            TestCapture.State.setup,
-            lambda: True,
-            'immediately')
+                            TestCapture.State.setup, lambda: True,
+                            'immediately')
 
-        self.add_transition(TestCapture.State.setup,
-            TestCapture.State.capturing,
+        self.add_transition(
+            TestCapture.State.setup, TestCapture.State.capturing,
             lambda: self.subbehavior_with_name('move').state == behavior.Behavior.State.completed,
             'robot away from ball')
 
-        self.add_transition(TestCapture.State.capturing,
-            TestCapture.State.setup,
+        self.add_transition(
+            TestCapture.State.capturing, TestCapture.State.setup,
             lambda: self.subbehavior_with_name('capture').state == behavior.Behavior.State.completed,
             'successful capture')
 
-
     def on_enter_capturing(self):
-        self.add_subbehavior(skills.capture.Capture(), 'capture', required=True)
+        self.add_subbehavior(skills.capture.Capture(),
+                             'capture',
+                             required=True)
+
     def on_exit_capturing(self):
         self.remove_subbehavior('capture')
 
-
     def on_enter_setup(self):
         m = skills.move.Move()
         m.pos = robocup.Point(0, 1.1)
         self.add_subbehavior(m, 'move', required=True)
+
     def on_exit_setup(self):
         self.remove_subbehavior('move')
 
-
     def execute_running(self):
         for bhvr in self.all_subbehaviors():
             if bhvr.robot != None:
                 self.shell_id = bhvr.robot.shell_id()
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
         if self.shell_id != None:
-            for req in role_assignment.iterate_role_requirements_tree_leaves(reqs):
+            for req in role_assignment.iterate_role_requirements_tree_leaves(
+                    reqs):
                 req.previous_shell_id = self.shell_id
         return reqs

--- a/soccer/gameplay/skills/face.py
+++ b/soccer/gameplay/skills/face.py
@@ -9,61 +9,60 @@
 ## A simple behavior to make a robot move to a given point and face a given direction
 # note: probably not overly useful in real plays, but is useful for testing purposes
 class Face(single_robot_composite_behavior.SingleRobotCompositeBehavior):
-
-    def __init__(self, pos = robocup.Point(0, constants.Field.Length / 4.0), angle = math.pi / 2.0):
+    def __init__(self,
+                 pos=robocup.Point(0, constants.Field.Length / 4.0),
+                 angle=math.pi / 2.0):
         super().__init__(continuous=False)
 
         self.angle = angle
         self.pos = pos
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
             lambda: self.is_at_target_angle() and self.subbehavior_with_name('move').state == behavior.Behavior.State.completed,
             'at target pos and angle')
-        self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
+        self.add_transition(
+            behavior.Behavior.State.completed, behavior.Behavior.State.running,
             lambda: not self.is_at_target_angle() or self.subbehavior_with_name('move').state != behavior.Behavior.State.completed,
             'not at target pos and angle')
 
         m = skills.move.Move(self.pos)
         self.add_subbehavior(m, 'move')
 
-
     ## The position to move to
     @property
     def pos(self):
         return self._pos
+
     @pos.setter
     def pos(self, value):
         self._pos = value
         if self.has_subbehavior_with_name('move'):
             self.subbehavior_with_name('move').pos = self.pos
 
-
     ## The angle (in radians) to face
     @property
     def angle(self):
         return self._angle
+
     @angle.setter
     def angle(self, value):
         self._angle = robocup.fix_angle_radians(value)
 
-
     def is_at_target_angle(self):
         if self.robot != None:
-            diff = abs(robocup.fix_angle_radians(self.robot.angle - self.angle))
+            diff = abs(robocup.fix_angle_radians(self.robot.angle -
+                                                 self.angle))
             return diff < (math.pi / 64.0)
         else:
             return False
 
-
     def calculate_face_target(self):
-        return self.pos + robocup.Point(math.cos(self.angle), math.sin(self.angle))
-
+        return self.pos + robocup.Point(
+            math.cos(self.angle), math.sin(self.angle))
 
     def execute_running(self):
         self.robot.face(self.calculate_face_target())

--- a/soccer/gameplay/tactics/behavior_sequence.py
+++ b/soccer/gameplay/tactics/behavior_sequence.py
@@ -6,39 +6,36 @@
 # If one of these sub-behaviors fails, then the sequence fails and doesn't execute anything more
 # The sequence moves onto the next behavior as soon as the current behavior completes
 class BehaviorSequence(composite_behavior.CompositeBehavior):
-
     def __init__(self, behaviors=None):
-        super().__init__(continuous=True) # Note: we don't know if the sequence will be continuous or not, so we assume it is to be safe
+        super().__init__(
+            continuous=True
+        )  # Note: we don't know if the sequence will be continuous or not, so we assume it is to be safe
 
         self.behaviors = behaviors
 
         self._current_behavior_index = -1
 
-        self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: self.behaviors != None,
-            'has subbehavior sequence')
+        self.add_transition(
+            behavior.Behavior.State.start, behavior.Behavior.State.running,
+            lambda: self.behaviors != None, 'has subbehavior sequence')
 
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.completed,
             lambda: self._current_behavior_index >= len(self.behaviors),
             'all subbehaviors complete')
 
-        self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.failed,
+        self.add_transition(
+            behavior.Behavior.State.running, behavior.Behavior.State.failed,
             lambda: self.current_behavior != None and self.current_behavior.is_in_state(behavior.Behavior.State.failed),
             'subbehavior failed')
 
-
     def on_enter_start(self):
         # reset
         self._current_behavior_index = -1
 
-
     def on_enter_failed(self):
         self._terminate_subbehaviors()
 
-
     def execute_running(self):
         should_advance = False
 
@@ -46,19 +43,21 @@
             # start up our first behavior
             should_advance = True
 
-        if self.current_behavior != None and self.current_behavior.is_done_running():
+        if self.current_behavior != None and self.current_behavior.is_done_running(
+        ):
             # this behavior finished, move onto the next
             should_advance = True
 
         if should_advance:
             if self.current_behavior != None:
                 self.remove_behavior_with_name('current')
-            
+
             self._current_behavior_index += 1
             if self.current_behavior_index < len(self.behaviors):
-                self.add_subbehavior(self.behaviors[self.current_behavior_index], 'current', required=True)
-
-
+                self.add_subbehavior(
+                    self.behaviors[self.current_behavior_index],
+                    'current',
+                    required=True)
 
     def _terminate_subbehaviors(self):
         self.remove_all_subbehaviors()
@@ -69,34 +68,32 @@
             for bhvr in self.behaviors:
                 bhvr.terminate()
 
-
     def on_enter_cancelled(self):
         self._terminate_subbehaviors()
 
-
     @property
     def behaviors(self):
         return self._behaviors
+
     @behaviors.setter
     def behaviors(self, value):
         self._behaviors = value
         self.transition(behavior.Behavior.State.start)
-    
 
     @property
     def current_behavior_index(self):
         return self._current_behavior_index
 
-
     @property
     def current_behavior(self):
         if self.has_subbehavior_with_name('current'):
             return self.subbehavior_with_name('current')
 
-
     def __str__(self):
         desc = super().__str__()
         if self.state == behavior.Behavior.State.running:
-            desc += "\n    executing " + str(self.current_behavior_index + 1) + "/" + str(len(self.behaviors))
+            desc += "\n    executing " + str(self.current_behavior_index +
+                                             1) + "/" + str(len(
+                                                 self.behaviors))
 
         return desc

--- a/soccer/gameplay/tactics/positions/submissive_goalie.py
+++ b/soccer/gameplay/tactics/positions/submissive_goalie.py
@@ -14,15 +14,16 @@
 # The regular goalie does a lot of calculations and figures out where it should be
 # This goalie lets someone else (the Defense tactic) handle calculations and blocks things based on that
 # TODO: merge this back into the regular goalie?
-class SubmissiveGoalie(single_robot_composite_behavior.SingleRobotCompositeBehavior):
+class SubmissiveGoalie(
+        single_robot_composite_behavior.SingleRobotCompositeBehavior):
 
     MaxX = constants.Field.GoalWidth / 2.0
     SegmentY = constants.Robot.Radius + 0.05
 
     # The segment we stay on during the 'block' state
     # It's right in front of the goal
-    RobotSegment = robocup.Segment(robocup.Point(-MaxX, SegmentY),
-                                    robocup.Point(MaxX, SegmentY))
+    RobotSegment = robocup.Segment(
+        robocup.Point(-MaxX, SegmentY), robocup.Point(MaxX, SegmentY))
 
     class State(enum.Enum):
         "Actively blocking based on a given threat"
@@ -32,7 +33,6 @@
         "Get the ball out of our defense area."
         clear = 4
 
-
     def __init__(self):
         super().__init__(continuous=True)
 
@@ -40,47 +40,44 @@
             self.add_state(substate, behavior.Behavior.State.running)
 
         self.add_transition(behavior.Behavior.State.start,
-            SubmissiveGoalie.State.block,
-            lambda: True,
-            "immediately")
-
-
-        non_block_states = [s for s in SubmissiveGoalie.State if s != SubmissiveGoalie.State.block]
+                            SubmissiveGoalie.State.block, lambda: True,
+                            "immediately")
 
-
-        for state in [s2 for s2 in SubmissiveGoalie.State if s2 != SubmissiveGoalie.State.intercept]:
-            self.add_transition(state,
-                SubmissiveGoalie.State.intercept,
+        non_block_states = [s
+                            for s in SubmissiveGoalie.State
+                            if s != SubmissiveGoalie.State.block]
+
+        for state in [s2
+                      for s2 in SubmissiveGoalie.State
+                      if s2 != SubmissiveGoalie.State.intercept]:
+            self.add_transition(
+                state, SubmissiveGoalie.State.intercept,
                 lambda: evaluation.ball.is_moving_towards_our_goal(),
                 "ball coming towards our goal")
 
-        for state in [s2 for s2 in SubmissiveGoalie.State if s2 != SubmissiveGoalie.State.clear]:
-            self.add_transition(state,
-                SubmissiveGoalie.State.clear,
-                lambda: evaluation.ball.is_in_our_goalie_zone() and
-                        not evaluation.ball.is_moving_towards_our_goal() and
-                        main.ball().vel.mag() < 0.4 and
-                        evaluation.ball.opponent_with_ball() is None,
+        for state in [s2
+                      for s2 in SubmissiveGoalie.State
+                      if s2 != SubmissiveGoalie.State.clear]:
+            self.add_transition(
+                state, SubmissiveGoalie.State.clear,
+                lambda: evaluation.ball.is_in_our_goalie_zone() and not evaluation.ball.is_moving_towards_our_goal() and main.ball().vel.mag() < 0.4 and evaluation.ball.opponent_with_ball() is None,
                 "ball in our goalie box, but not headed toward goal")
 
         for state in non_block_states:
-            self.add_transition(state,
-                SubmissiveGoalie.State.block,
-                lambda: not evaluation.ball.is_in_our_goalie_zone() and
-                        not evaluation.ball.is_moving_towards_our_goal(),
+            self.add_transition(
+                state, SubmissiveGoalie.State.block,
+                lambda: not evaluation.ball.is_in_our_goalie_zone() and not evaluation.ball.is_moving_towards_our_goal(),
                 'ball not in goal or moving towards it')
 
-
         self.block_line = None
         self._move_target = robocup.Point(0, 0)
 
-
-
     # the line we expect a threat to shoot from
     # sits on the intersection of this line and the goalie segment
     @property
     def block_line(self):
         return self._block_line
+
     @block_line.setter
     def block_line(self, value):
         self._block_line = value
@@ -88,23 +85,22 @@
         if self.block_line == None:
             self._move_target = SubmissiveGoalie.RobotSegment.center()
         else:
-            self._move_target = SubmissiveGoalie.RobotSegment.nearest_point_to_line(self.block_line)
-
-        self._move_target.x = min(max(self._move_target.x, -SubmissiveGoalie.MaxX), SubmissiveGoalie.MaxX)
+            self._move_target = SubmissiveGoalie.RobotSegment.nearest_point_to_line(
+                self.block_line)
 
+        self._move_target.x = min(
+            max(self._move_target.x, -
+                SubmissiveGoalie.MaxX), SubmissiveGoalie.MaxX)
 
     # The point we'll be going to in order to block the given block_line
     @property
     def move_target(self):
         return self._move_target
 
-
-
     # note that execute_running() gets called BEFORE any of the execute_SUBSTATE methods gets called
     def execute_running(self):
         self.robot.face(main.ball().pos)
 
-
     def on_enter_clear(self):
         # FIXME: what we really want is a less-precise LineKick
         #           this will require a Capture behavior that doesn't wait for the ball to stop
@@ -122,18 +118,17 @@
         kick.chip_power = 1.0
         kick.use_chipper = True
 
-        kick.target = robocup.Segment(robocup.Point(-constants.Field.Width/2, constants.Field.Length),
-            robocup.Point(constants.Field.Width/2, constants.Field.Length))
+        kick.target = robocup.Segment(
+            robocup.Point(-constants.Field.Width / 2, constants.Field.Length),
+            robocup.Point(constants.Field.Width / 2, constants.Field.Length))
 
         # FIXME: if the goalie has a fault, resort to bump
 
         self.add_subbehavior(kick, 'kick-clear', required=True)
 
-
     def on_exit_clear(self):
         self.remove_subbehavior('kick-clear')
 
-
     def on_enter_intercept(self):
         i = skills.intercept.Intercept()
         i.shape_constraint = SubmissiveGoalie.RobotSegment
@@ -142,7 +137,6 @@
     def on_exit_intercept(self):
         self.remove_subbehavior('intercept')
 
-
     def on_enter_block(self):
         move = skills.move.Move()
         self.add_subbehavior(move, 'move', required=True)
@@ -151,12 +145,9 @@
         move = self.subbehavior_with_name('move')
         move.pos = self.move_target
 
-
-
     def on_exit_block(self):
         self.remove_subbehavior('move')
 
-
     def role_requirements(self):
         reqs = super().role_requirements()
 
@@ -164,10 +155,10 @@
             req.required_shell_id = self.shell_id if self.shell_id != None else -1
         return reqs
 
-
     @property
     def shell_id(self):
         return self._shell_id
+
     @shell_id.setter
     def shell_id(self, value):
         self._shell_id = value

--- a/soccer/gameplay/tactics/stopped/circle_near_ball.py
+++ b/soccer/gameplay/tactics/stopped/circle_near_ball.py
@@ -17,27 +17,30 @@
         super().__init__(continuous=True)
 
         self.add_transition(behavior.Behavior.State.start,
-            behavior.Behavior.State.running,
-            lambda: True,
-            'immediately')
+                            behavior.Behavior.State.running, lambda: True,
+                            'immediately')
         self.add_transition(behavior.Behavior.State.running,
-            behavior.Behavior.State.completed,
-            lambda: self.all_subbehaviors_completed(),
-            'all robots reach target positions')
+                            behavior.Behavior.State.completed,
+                            lambda: self.all_subbehaviors_completed(),
+                            'all robots reach target positions')
         self.add_transition(behavior.Behavior.State.completed,
-            behavior.Behavior.State.running,
-            lambda: not self.all_subbehaviors_completed(),
-            "robots aren't lined up")
+                            behavior.Behavior.State.running,
+                            lambda: not self.all_subbehaviors_completed(),
+                            "robots aren't lined up")
 
         i = 0
         for pt in self.get_circle_points(6):
-            self.add_subbehavior(skills.move.Move(pt), name="robot" + str(i), required=False, priority=6 - i)
+            self.add_subbehavior(
+                skills.move.Move(pt),
+                name="robot" + str(i),
+                required=False,
+                priority=6 - i)
             i = i + 1
 
-
     def get_circle_points(self, num_of_points):
         radius = constants.Field.CenterRadius + constants.Robot.Radius + 0.01
-        ball_pos = main.ball().pos if main.ball() != None else robocup.Point(constants.Field.Width / 2, constants.Field.Length / 2)
+        ball_pos = main.ball().pos if main.ball() != None else robocup.Point(
+            constants.Field.Width / 2, constants.Field.Length / 2)
         circle_ball = robocup.Circle(ball_pos, radius)
 
         intersection_points = []
@@ -61,37 +64,48 @@
 
             counter = 1
             while counter < len(angles):
-                candidate_arcs.append(robocup.Arc(circle_ball.center, radius, angles[counter - 1], angles[counter]))
+                candidate_arcs.append(robocup.Arc(circle_ball.center, radius,
+                                                  angles[counter - 1], angles[
+                                                      counter]))
                 counter = counter + 1
-            candidate_arcs.append(robocup.Arc(circle_ball.center, radius, angles[len(angles) - 1], angles[0]))
+            candidate_arcs.append(robocup.Arc(circle_ball.center, radius,
+                                              angles[len(angles) - 1], angles[
+                                                  0]))
 
             i = 0
             while i < len(candidate_arcs):
-                angle_between = candidate_arcs[i].end() - candidate_arcs[i].start()
+                angle_between = candidate_arcs[i].end() - candidate_arcs[
+                    i].start()
                 angle_between = self.normalize_angle(angle_between)
 
                 angle_diff = candidate_arcs[i].start() + (angle_between) / 2.0
                 angle_diff = self.normalize_angle(angle_diff)
 
-                midpoint = (candidate_arcs[i].center() + robocup.Point(radius, 0))
+                midpoint = (
+                    candidate_arcs[i].center() + robocup.Point(radius, 0))
                 midpoint.rotate(candidate_arcs[i].center(), angle_diff)
                 if not constants.Field.FieldRect.contains_point(midpoint):
                     candidate_arcs.pop(i)
                 else:
                     i = i + 1
 
-            candidate_arcs.sort(key=lambda arc: self.normalize_angle(arc.end() - arc.start()), reverse=True)
+            candidate_arcs.sort(
+                key=lambda arc: self.normalize_angle(arc.end() - arc.start()),
+                reverse=True)
 
             if len(candidate_arcs) <= 0:
-                final_arc = robocup.Arc(CircleNearBall.BackupBallLocation, radius, math.pi / 2, 5 * math.pi / 2)
+                final_arc = robocup.Arc(CircleNearBall.BackupBallLocation,
+                                        radius, math.pi / 2, 5 * math.pi / 2)
             else:
                 final_arc = candidate_arcs[0]
         else:
             midpoint = (circle_ball.center + robocup.Point(radius, 0))
             if not constants.Field.FieldRect.contains_point(midpoint):
-                final_arc = robocup.Arc(CircleNearBall.BackupBallLocation, radius, math.pi / 2, 5 * math.pi / 2)
+                final_arc = robocup.Arc(CircleNearBall.BackupBallLocation,
+                                        radius, math.pi / 2, 5 * math.pi / 2)
             else:
-                final_arc = robocup.Arc(circle_ball.center, radius, math.pi / 2, 5 * math.pi / 2)
+                final_arc = robocup.Arc(circle_ball.center, radius, math.pi /
+                                        2, 5 * math.pi / 2)
 
         arc_angle = final_arc.end() - final_arc.start()
         arc_angle = self.normalize_angle(arc_angle)
@@ -99,14 +113,14 @@
         perRobot = arc_angle / (num_of_points + 1)
 
         dirvec = robocup.Point(radius, 0)
-        dirvec.rotate(robocup.Point(0,0), final_arc.start())
-        dirvec.rotate(robocup.Point(0,0), perRobot)
+        dirvec.rotate(robocup.Point(0, 0), final_arc.start())
+        dirvec.rotate(robocup.Point(0, 0), perRobot)
 
         final_points = []
         for i in range(num_of_points):
             pt = final_arc.center() + dirvec
             final_points.append(pt)
-            dirvec.rotate(robocup.Point(0,0), perRobot)
+            dirvec.rotate(robocup.Point(0, 0), perRobot)
 
         return final_points
 
@@ -114,7 +128,7 @@
         num_robots = 0
         for b in self.all_subbehaviors():
             if b.robot is not None:
-                num_robots+=1
+                num_robots += 1
 
         i = 0
         for pt in self.get_circle_points(num_robots):
@@ -128,8 +142,6 @@
                 b.robot.face(main.ball().pos)
                 b.robot.avoid_all_teammates(True)
 
-
-
     # Makes an angle > 0, < pi * 2
     def normalize_angle(self, angle):
         # TODO make this O(1) and move to cpp
@@ -143,7 +155,7 @@
         num_robots = 0
         for b in self.all_subbehaviors():
             if b.robot is not None:
-                num_robots+=1
+                num_robots += 1
 
         i = 0
         for pt in self.get_circle_points(num_robots):

