#pragma once

#include <optional>

#include <Geometry2d/Segment.hpp>
#include <Geometry2d/Point.hpp>
#include "Robot.hpp"
#include "SystemState.hpp"

/**
 * @brief The Window class represents an open shot from a point to a target
 * segment.
 */
class Window {
public:
    Window();

    Window(double t0, double t1);

    double a0;
    double a1;
    double t0;
    double t1;
    Geometry2d::Segment segment;
    double shot_success;

    bool operator==(const Window& other) const {
        return a0 == other.a0 && a1 == other.a1 && t0 == other.t0 &&
               t1 == other.t1;
    }
};

using WindowingResult = std::pair<std::vector<Window>, std::optional<Window>>;

/**
 * @brief The WindowEvaluator class calculates open shots from a point to a
 * target.
 */
class WindowEvaluator {
public:
    /**
     * @brief Constructor
     * @param systemState pointer to global system state object
     */
    WindowEvaluator(Context* context);

    /**
     * @brief Evaluates shot windows to a target point, using a virtual width
     * for the target
     * @param origin The starting point of the shot
     * @param target The target point to aim at
     * @param targetWidth Virtual width to apply to the target
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_pt(Geometry2d::Point origin,
                                  Geometry2d::Point target, float targetWidth);

    /**
     * @brief Evaluates shot windows to a target point
     * @param origin The starting point of the shot
     * @param target The target point to aim at
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_robot(Geometry2d::Point origin,
                                     Geometry2d::Point target);

    /**
     * @brief Evaluates shot windows to the oponents goal segment
     * @param origin The starting point of the shot
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_opp_goal(Geometry2d::Point origin);

    /**
     * @brief Evaluates shot windows to our team's goal segment
     * @param origin The starting point of the shot
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_our_goal(Geometry2d::Point origin);

    /**
     * @brief Evaluates shot windows to a target segment
     * @param origin The starting point of the shot
     * @param target The target segment to aim at
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_seg(Geometry2d::Point origin,
                                   Geometry2d::Segment target);

    /**
     * @brief Initializes configurable fields.
     * @note See configuration documentation for details.
     */
    static void createConfiguration(Configuration* cfg);

    /**
     * @breif Controls the debug drawings generated by the evaluator
     */
    bool debug = false;

    /**
     * @brief Controls whether the evaluator should consider chip shots possible
     */
    bool chip_enabled = false;

    /**
     * @brief Maximum distance to an obstacle to be able to chip over it
     */
    double max_chip_range = 0.3;

    /**
     * @brief Minimum distance to an obstacle to be able to chip over it
     */
    double min_chip_range = 4.0;

    /**
     * @brief Robots that should not be considered obstacles during evaluation
     */
    std::vector<Robot*> excluded_robots;

    /**
     * @brief Locations to pretend are robot obstacles during evaluation
     */
    std::vector<Geometry2d::Point> hypothetical_robot_locations;

private:
    Context* context;

    static void fill_shot_success(Window& window, Geometry2d::Point origin);

    static void obstacle_range(std::vector<Window>& windows, double& t0,
                               double& t1);

    void obstacle_robot(std::vector<Window>& windows, Geometry2d::Point origin,
                        Geometry2d::Segment target, Geometry2d::Point bot_pos);

    static ConfigDouble* angle_score_coefficient;
    static ConfigDouble* distance_score_coefficient;
};
