#pragma once

#include <optional>

#include <rj_geometry/segment.hpp>
#include <rj_geometry/point.hpp>
#include "robot.hpp"
#include "system_state.hpp"

/**
 * @brief The Window class represents an open shot from a point to a target
 * segment.
 */
class Window {
public:
    Window();

    Window(double t0, double t1);

    double a0;
    double a1;
    double t0;
    double t1;
    rj_geometry::Segment segment;
    double shot_success;

    bool operator==(const Window& other) const {
        return a0 == other.a0 && a1 == other.a1 && t0 == other.t0 &&
               t1 == other.t1;
    }
};

using WindowingResult = std::pair<std::vector<Window>, std::optional<Window>>;

constexpr auto windowConfigParamModule = "window_config";


/**
 * @brief The WindowEvaluator class calculates open shots from a point to a
 * target.
 */
class WindowEvaluator {
public:
    /**
     * @brief Constructor
     * @param system_state pointer to global system state object
     */
    WindowEvaluator(Context* context);

    /**
     * @brief Evaluates shot windows to a target point, using a virtual width
     * for the target
     * @param origin The starting point of the shot
     * @param target The target point to aim at
     * @param target_width Virtual width to apply to the target
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_pt(rj_geometry::Point origin,
                                  rj_geometry::Point target, float target_width);

    /**
     * @brief Evaluates shot windows to a target point
     * @param origin The starting point of the shot
     * @param target The target point to aim at
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_robot(rj_geometry::Point origin,
                                     rj_geometry::Point target);

    /**
     * @brief Evaluates shot windows to the oponents goal segment
     * @param origin The starting point of the shot
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_opp_goal(rj_geometry::Point origin);

    /**
     * @brief Evaluates shot windows to our team's goal segment
     * @param origin The starting point of the shot
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_our_goal(rj_geometry::Point origin);

    /**
     * @brief Evaluates shot windows to a target segment
     * @param origin The starting point of the shot
     * @param target The target segment to aim at
     * @return Results of windowing operation
     */
    WindowingResult eval_pt_to_seg(rj_geometry::Point origin,
                                   rj_geometry::Segment target);

    /**
     * @brief Initializes configurable fields.
     * @note See configuration documentation for details.
     */
    static void create_configuration(Configuration* cfg);

    /**
     * @breif Controls the debug drawings generated by the evaluator
     */
    bool debug = false;

    /**
     * @brief Controls whether the evaluator should consider chip shots possible
     */
    bool chip_enabled = false;

    /**
     * @brief Maximum distance to an obstacle to be able to chip over it
     */
    double max_chip_range = 0.3;

    /**
     * @brief Minimum distance to an obstacle to be able to chip over it
     */
    double min_chip_range = 4.0;

    /**
     * @brief Robots that should not be considered obstacles during evaluation
     */
    std::vector<Robot*> excluded_robots;

    /**
     * @brief Locations to pretend are robot obstacles during evaluation
     */
    std::vector<rj_geometry::Point> hypothetical_robot_locations;

    DECLARE_FLOAT64(windowConfigParamModule, angle_score_coefficient);
    DECLARE_FLOAT64(windowConfigParamModule, distance_score_coefficient);
    //static ConfigDouble* angle_score_coefficient;
    //static ConfigDouble* distance_score_coefficient;

private:
    Context* context_;

    static void fill_shot_success(Window& window, rj_geometry::Point origin);

    static void obstacle_range(std::vector<Window>& windows, double& t0,
                               double& t1);

    void obstacle_robot(std::vector<Window>& windows, rj_geometry::Point origin,
                        rj_geometry::Segment target, rj_geometry::Point bot_pos);
    
};
